var F6 = Object.defineProperty
var AR = e => {
  throw TypeError(e)
}
var V6 = (e, t, r) =>
  t in e ? F6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)
var Hu = (e, t, r) => V6(e, typeof t != 'symbol' ? t + '' : t, r),
  NE = (e, t, r) => t.has(e) || AR('Cannot ' + r)
var B = (e, t, r) => (NE(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
  gt = (e, t, r) =>
    t.has(e)
      ? AR('Cannot add the same private member more than once')
      : t instanceof WeakSet
        ? t.add(e)
        : t.set(e, r),
  He = (e, t, r, a) => (NE(e, t, 'write to private field'), a ? a.call(e, r) : t.set(e, r), r),
  zt = (e, t, r) => (NE(e, t, 'access private method'), r)
var lv = (e, t, r, a) => ({
  set _(o) {
    He(e, t, o, r)
  },
  get _() {
    return B(e, t, a)
  }
})
function j6(e, t) {
  for (var r = 0; r < t.length; r++) {
    const a = t[r]
    if (typeof a != 'string' && !Array.isArray(a)) {
      for (const o in a)
        if (o !== 'default' && !(o in e)) {
          const u = Object.getOwnPropertyDescriptor(a, o)
          u && Object.defineProperty(e, o, u.get ? u : { enumerable: !0, get: () => a[o] })
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }))
}
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) a(o)
  new MutationObserver(o => {
    for (const u of o)
      if (u.type === 'childList')
        for (const l of u.addedNodes) l.tagName === 'LINK' && l.rel === 'modulepreload' && a(l)
  }).observe(document, { childList: !0, subtree: !0 })
  function r(o) {
    const u = {}
    return (
      o.integrity && (u.integrity = o.integrity),
      o.referrerPolicy && (u.referrerPolicy = o.referrerPolicy),
      o.crossOrigin === 'use-credentials'
        ? (u.credentials = 'include')
        : o.crossOrigin === 'anonymous'
          ? (u.credentials = 'omit')
          : (u.credentials = 'same-origin'),
      u
    )
  }
  function a(o) {
    if (o.ep) return
    o.ep = !0
    const u = r(o)
    fetch(o.href, u)
  }
})()
function kk(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
var Ak = { exports: {} },
  xx = {},
  Dk = { exports: {} },
  Pv = { exports: {} }
Pv.exports
;(function (e, t) {
  /**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ ;(function () {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
    var r = '18.3.1',
      a = Symbol.for('react.element'),
      o = Symbol.for('react.portal'),
      u = Symbol.for('react.fragment'),
      l = Symbol.for('react.strict_mode'),
      d = Symbol.for('react.profiler'),
      h = Symbol.for('react.provider'),
      p = Symbol.for('react.context'),
      v = Symbol.for('react.forward_ref'),
      g = Symbol.for('react.suspense'),
      E = Symbol.for('react.suspense_list'),
      x = Symbol.for('react.memo'),
      C = Symbol.for('react.lazy'),
      _ = Symbol.for('react.offscreen'),
      k = Symbol.iterator,
      R = '@@iterator'
    function D(T) {
      if (T === null || typeof T != 'object') return null
      var I = (k && T[k]) || T[R]
      return typeof I == 'function' ? I : null
    }
    var A = { current: null },
      L = { transition: null },
      F = { current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1 },
      z = { current: null },
      H = {},
      $ = null
    function Q(T) {
      $ = T
    }
    ;(H.setExtraStackFrame = function (T) {
      $ = T
    }),
      (H.getCurrentStack = null),
      (H.getStackAddendum = function () {
        var T = ''
        $ && (T += $)
        var I = H.getCurrentStack
        return I && (T += I() || ''), T
      })
    var ue = !1,
      se = !1,
      we = !1,
      he = !1,
      G = !1,
      ge = { ReactCurrentDispatcher: A, ReactCurrentBatchConfig: L, ReactCurrentOwner: z }
    ;(ge.ReactDebugCurrentFrame = H), (ge.ReactCurrentActQueue = F)
    function De(T) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), J = 1; J < I; J++)
          K[J - 1] = arguments[J]
        ve('warn', T, K)
      }
    }
    function de(T) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), J = 1; J < I; J++)
          K[J - 1] = arguments[J]
        ve('error', T, K)
      }
    }
    function ve(T, I, K) {
      {
        var J = ge.ReactDebugCurrentFrame,
          xe = J.getStackAddendum()
        xe !== '' && ((I += '%s'), (K = K.concat([xe])))
        var tt = K.map(function (Be) {
          return String(Be)
        })
        tt.unshift('Warning: ' + I), Function.prototype.apply.call(console[T], console, tt)
      }
    }
    var Ke = {}
    function ot(T, I) {
      {
        var K = T.constructor,
          J = (K && (K.displayName || K.name)) || 'ReactClass',
          xe = J + '.' + I
        if (Ke[xe]) return
        de(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          I,
          J
        ),
          (Ke[xe] = !0)
      }
    }
    var Me = {
        isMounted: function (T) {
          return !1
        },
        enqueueForceUpdate: function (T, I, K) {
          ot(T, 'forceUpdate')
        },
        enqueueReplaceState: function (T, I, K, J) {
          ot(T, 'replaceState')
        },
        enqueueSetState: function (T, I, K, J) {
          ot(T, 'setState')
        }
      },
      Ue = Object.assign,
      pe = {}
    Object.freeze(pe)
    function xt(T, I, K) {
      ;(this.props = T), (this.context = I), (this.refs = pe), (this.updater = K || Me)
    }
    ;(xt.prototype.isReactComponent = {}),
      (xt.prototype.setState = function (T, I) {
        if (typeof T != 'object' && typeof T != 'function' && T != null)
          throw new Error(
            'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
          )
        this.updater.enqueueSetState(this, T, I, 'setState')
      }),
      (xt.prototype.forceUpdate = function (T) {
        this.updater.enqueueForceUpdate(this, T, 'forceUpdate')
      })
    {
      var Ye = {
          isMounted: [
            'isMounted',
            'Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.'
          ],
          replaceState: [
            'replaceState',
            'Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).'
          ]
        },
        kt = function (T, I) {
          Object.defineProperty(xt.prototype, T, {
            get: function () {
              De('%s(...) is deprecated in plain JavaScript React classes. %s', I[0], I[1])
            }
          })
        }
      for (var yt in Ye) Ye.hasOwnProperty(yt) && kt(yt, Ye[yt])
    }
    function Et() {}
    Et.prototype = xt.prototype
    function st(T, I, K) {
      ;(this.props = T), (this.context = I), (this.refs = pe), (this.updater = K || Me)
    }
    var At = (st.prototype = new Et())
    ;(At.constructor = st), Ue(At, xt.prototype), (At.isPureReactComponent = !0)
    function en() {
      var T = { current: null }
      return Object.seal(T), T
    }
    var nn = Array.isArray
    function Re(T) {
      return nn(T)
    }
    function Oe(T) {
      {
        var I = typeof Symbol == 'function' && Symbol.toStringTag,
          K = (I && T[Symbol.toStringTag]) || T.constructor.name || 'Object'
        return K
      }
    }
    function Xe(T) {
      try {
        return Dt(T), !1
      } catch {
        return !0
      }
    }
    function Dt(T) {
      return '' + T
    }
    function Vt(T) {
      if (Xe(T))
        return (
          de(
            'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
            Oe(T)
          ),
          Dt(T)
        )
    }
    function Cn(T, I, K) {
      var J = T.displayName
      if (J) return J
      var xe = I.displayName || I.name || ''
      return xe !== '' ? K + '(' + xe + ')' : K
    }
    function xn(T) {
      return T.displayName || 'Context'
    }
    function Pn(T) {
      if (T == null) return null
      if (
        (typeof T.tag == 'number' &&
          de(
            'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
          ),
        typeof T == 'function')
      )
        return T.displayName || T.name || null
      if (typeof T == 'string') return T
      switch (T) {
        case u:
          return 'Fragment'
        case o:
          return 'Portal'
        case d:
          return 'Profiler'
        case l:
          return 'StrictMode'
        case g:
          return 'Suspense'
        case E:
          return 'SuspenseList'
      }
      if (typeof T == 'object')
        switch (T.$$typeof) {
          case p:
            var I = T
            return xn(I) + '.Consumer'
          case h:
            var K = T
            return xn(K._context) + '.Provider'
          case v:
            return Cn(T, T.render, 'ForwardRef')
          case x:
            var J = T.displayName || null
            return J !== null ? J : Pn(T.type) || 'Memo'
          case C: {
            var xe = T,
              tt = xe._payload,
              Be = xe._init
            try {
              return Pn(Be(tt))
            } catch {
              return null
            }
          }
        }
      return null
    }
    var tr = Object.prototype.hasOwnProperty,
      Un = { key: !0, ref: !0, __self: !0, __source: !0 },
      In,
      $n,
      mn
    mn = {}
    function wn(T) {
      if (tr.call(T, 'ref')) {
        var I = Object.getOwnPropertyDescriptor(T, 'ref').get
        if (I && I.isReactWarning) return !1
      }
      return T.ref !== void 0
    }
    function rn(T) {
      if (tr.call(T, 'key')) {
        var I = Object.getOwnPropertyDescriptor(T, 'key').get
        if (I && I.isReactWarning) return !1
      }
      return T.key !== void 0
    }
    function fr(T, I) {
      var K = function () {
        In ||
          ((In = !0),
          de(
            '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            I
          ))
      }
      ;(K.isReactWarning = !0), Object.defineProperty(T, 'key', { get: K, configurable: !0 })
    }
    function jr(T, I) {
      var K = function () {
        $n ||
          (($n = !0),
          de(
            '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            I
          ))
      }
      ;(K.isReactWarning = !0), Object.defineProperty(T, 'ref', { get: K, configurable: !0 })
    }
    function Cr(T) {
      if (typeof T.ref == 'string' && z.current && T.__self && z.current.stateNode !== T.__self) {
        var I = Pn(z.current.type)
        mn[I] ||
          (de(
            'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
            I,
            T.ref
          ),
          (mn[I] = !0))
      }
    }
    var Se = function (T, I, K, J, xe, tt, Be) {
      var ut = { $$typeof: a, type: T, key: I, ref: K, props: Be, _owner: tt }
      return (
        (ut._store = {}),
        Object.defineProperty(ut._store, 'validated', {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }),
        Object.defineProperty(ut, '_self', { configurable: !1, enumerable: !1, writable: !1, value: J }),
        Object.defineProperty(ut, '_source', {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: xe
        }),
        Object.freeze && (Object.freeze(ut.props), Object.freeze(ut)),
        ut
      )
    }
    function $e(T, I, K) {
      var J,
        xe = {},
        tt = null,
        Be = null,
        ut = null,
        Mt = null
      if (I != null) {
        wn(I) && ((Be = I.ref), Cr(I)),
          rn(I) && (Vt(I.key), (tt = '' + I.key)),
          (ut = I.__self === void 0 ? null : I.__self),
          (Mt = I.__source === void 0 ? null : I.__source)
        for (J in I) tr.call(I, J) && !Un.hasOwnProperty(J) && (xe[J] = I[J])
      }
      var an = arguments.length - 2
      if (an === 1) xe.children = K
      else if (an > 1) {
        for (var dn = Array(an), hn = 0; hn < an; hn++) dn[hn] = arguments[hn + 2]
        Object.freeze && Object.freeze(dn), (xe.children = dn)
      }
      if (T && T.defaultProps) {
        var bn = T.defaultProps
        for (J in bn) xe[J] === void 0 && (xe[J] = bn[J])
      }
      if (tt || Be) {
        var Dn = typeof T == 'function' ? T.displayName || T.name || 'Unknown' : T
        tt && fr(xe, Dn), Be && jr(xe, Dn)
      }
      return Se(T, tt, Be, ut, Mt, z.current, xe)
    }
    function pt(T, I) {
      var K = Se(T.type, I, T.ref, T._self, T._source, T._owner, T.props)
      return K
    }
    function St(T, I, K) {
      if (T == null)
        throw new Error(
          'React.cloneElement(...): The argument must be a React element, but you passed ' + T + '.'
        )
      var J,
        xe = Ue({}, T.props),
        tt = T.key,
        Be = T.ref,
        ut = T._self,
        Mt = T._source,
        an = T._owner
      if (I != null) {
        wn(I) && ((Be = I.ref), (an = z.current)), rn(I) && (Vt(I.key), (tt = '' + I.key))
        var dn
        T.type && T.type.defaultProps && (dn = T.type.defaultProps)
        for (J in I)
          tr.call(I, J) &&
            !Un.hasOwnProperty(J) &&
            (I[J] === void 0 && dn !== void 0 ? (xe[J] = dn[J]) : (xe[J] = I[J]))
      }
      var hn = arguments.length - 2
      if (hn === 1) xe.children = K
      else if (hn > 1) {
        for (var bn = Array(hn), Dn = 0; Dn < hn; Dn++) bn[Dn] = arguments[Dn + 2]
        xe.children = bn
      }
      return Se(T.type, tt, Be, ut, Mt, an, xe)
    }
    function _t(T) {
      return typeof T == 'object' && T !== null && T.$$typeof === a
    }
    var gn = '.',
      fn = ':'
    function nr(T) {
      var I = /[=:]/g,
        K = { '=': '=0', ':': '=2' },
        J = T.replace(I, function (xe) {
          return K[xe]
        })
      return '$' + J
    }
    var Nt = !1,
      rr = /\/+/g
    function Wt(T) {
      return T.replace(rr, '$&/')
    }
    function lt(T, I) {
      return typeof T == 'object' && T !== null && T.key != null
        ? (Vt(T.key), nr('' + T.key))
        : I.toString(36)
    }
    function Fn(T, I, K, J, xe) {
      var tt = typeof T
      ;(tt === 'undefined' || tt === 'boolean') && (T = null)
      var Be = !1
      if (T === null) Be = !0
      else
        switch (tt) {
          case 'string':
          case 'number':
            Be = !0
            break
          case 'object':
            switch (T.$$typeof) {
              case a:
              case o:
                Be = !0
            }
        }
      if (Be) {
        var ut = T,
          Mt = xe(ut),
          an = J === '' ? gn + lt(ut, 0) : J
        if (Re(Mt)) {
          var dn = ''
          an != null && (dn = Wt(an) + '/'),
            Fn(Mt, I, dn, '', function (Dg) {
              return Dg
            })
        } else
          Mt != null &&
            (_t(Mt) &&
              (Mt.key && (!ut || ut.key !== Mt.key) && Vt(Mt.key),
              (Mt = pt(
                Mt,
                K + (Mt.key && (!ut || ut.key !== Mt.key) ? Wt('' + Mt.key) + '/' : '') + an
              ))),
            I.push(Mt))
        return 1
      }
      var hn,
        bn,
        Dn = 0,
        Zt = J === '' ? gn : J + fn
      if (Re(T))
        for (var Uo = 0; Uo < T.length; Uo++)
          (hn = T[Uo]), (bn = Zt + lt(hn, Uo)), (Dn += Fn(hn, I, K, bn, xe))
      else {
        var Zl = D(T)
        if (typeof Zl == 'function') {
          var Jc = T
          Zl === Jc.entries &&
            (Nt ||
              De(
                'Using Maps as children is not supported. Use an array of keyed ReactElements instead.'
              ),
            (Nt = !0))
          for (var Ag = Zl.call(Jc), Ka, ef = 0; !(Ka = Ag.next()).done; )
            (hn = Ka.value), (bn = Zt + lt(hn, ef++)), (Dn += Fn(hn, I, K, bn, xe))
        } else if (tt === 'object') {
          var tf = String(T)
          throw new Error(
            'Objects are not valid as a React child (found: ' +
              (tf === '[object Object]' ? 'object with keys {' + Object.keys(T).join(', ') + '}' : tf) +
              '). If you meant to render a collection of children, use an array instead.'
          )
        }
      }
      return Dn
    }
    function wr(T, I, K) {
      if (T == null) return T
      var J = [],
        xe = 0
      return (
        Fn(T, J, '', '', function (tt) {
          return I.call(K, tt, xe++)
        }),
        J
      )
    }
    function Ni(T) {
      var I = 0
      return (
        wr(T, function () {
          I++
        }),
        I
      )
    }
    function ci(T, I, K) {
      wr(
        T,
        function () {
          I.apply(this, arguments)
        },
        K
      )
    }
    function xa(T) {
      return (
        wr(T, function (I) {
          return I
        }) || []
      )
    }
    function fi(T) {
      if (!_t(T))
        throw new Error('React.Children.only expected to receive a single React element child.')
      return T
    }
    function Mi(T) {
      var I = {
        $$typeof: p,
        _currentValue: T,
        _currentValue2: T,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
      }
      I.Provider = { $$typeof: h, _context: I }
      var K = !1,
        J = !1,
        xe = !1
      {
        var tt = { $$typeof: p, _context: I }
        Object.defineProperties(tt, {
          Provider: {
            get: function () {
              return (
                J ||
                  ((J = !0),
                  de(
                    'Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?'
                  )),
                I.Provider
              )
            },
            set: function (Be) {
              I.Provider = Be
            }
          },
          _currentValue: {
            get: function () {
              return I._currentValue
            },
            set: function (Be) {
              I._currentValue = Be
            }
          },
          _currentValue2: {
            get: function () {
              return I._currentValue2
            },
            set: function (Be) {
              I._currentValue2 = Be
            }
          },
          _threadCount: {
            get: function () {
              return I._threadCount
            },
            set: function (Be) {
              I._threadCount = Be
            }
          },
          Consumer: {
            get: function () {
              return (
                K ||
                  ((K = !0),
                  de(
                    'Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
                  )),
                I.Consumer
              )
            }
          },
          displayName: {
            get: function () {
              return I.displayName
            },
            set: function (Be) {
              xe ||
                (De(
                  "Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.",
                  Be
                ),
                (xe = !0))
            }
          }
        }),
          (I.Consumer = tt)
      }
      return (I._currentRenderer = null), (I._currentRenderer2 = null), I
    }
    var Jr = -1,
      di = 0,
      ei = 1,
      Sn = 2
    function ir(T) {
      if (T._status === Jr) {
        var I = T._result,
          K = I()
        if (
          (K.then(
            function (tt) {
              if (T._status === di || T._status === Jr) {
                var Be = T
                ;(Be._status = ei), (Be._result = tt)
              }
            },
            function (tt) {
              if (T._status === di || T._status === Jr) {
                var Be = T
                ;(Be._status = Sn), (Be._result = tt)
              }
            }
          ),
          T._status === Jr)
        ) {
          var J = T
          ;(J._status = di), (J._result = K)
        }
      }
      if (T._status === ei) {
        var xe = T._result
        return (
          xe === void 0 &&
            de(
              `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
              xe
            ),
          'default' in xe ||
            de(
              `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
              xe
            ),
          xe.default
        )
      } else throw T._result
    }
    function P(T) {
      var I = { _status: Jr, _result: T },
        K = { $$typeof: C, _payload: I, _init: ir }
      {
        var J, xe
        Object.defineProperties(K, {
          defaultProps: {
            configurable: !0,
            get: function () {
              return J
            },
            set: function (tt) {
              de(
                'React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
              ),
                (J = tt),
                Object.defineProperty(K, 'defaultProps', { enumerable: !0 })
            }
          },
          propTypes: {
            configurable: !0,
            get: function () {
              return xe
            },
            set: function (tt) {
              de(
                'React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
              ),
                (xe = tt),
                Object.defineProperty(K, 'propTypes', { enumerable: !0 })
            }
          }
        })
      }
      return K
    }
    function ce(T) {
      T != null && T.$$typeof === x
        ? de(
            'forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).'
          )
        : typeof T != 'function'
          ? de('forwardRef requires a render function but was given %s.', T === null ? 'null' : typeof T)
          : T.length !== 0 &&
            T.length !== 2 &&
            de(
              'forwardRef render functions accept exactly two parameters: props and ref. %s',
              T.length === 1
                ? 'Did you forget to use the ref parameter?'
                : 'Any additional parameter will be undefined.'
            ),
        T != null &&
          (T.defaultProps != null || T.propTypes != null) &&
          de(
            'forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?'
          )
      var I = { $$typeof: v, render: T }
      {
        var K
        Object.defineProperty(I, 'displayName', {
          enumerable: !1,
          configurable: !0,
          get: function () {
            return K
          },
          set: function (J) {
            ;(K = J), !T.name && !T.displayName && (T.displayName = J)
          }
        })
      }
      return I
    }
    var Te
    Te = Symbol.for('react.module.reference')
    function M(T) {
      return !!(
        typeof T == 'string' ||
        typeof T == 'function' ||
        T === u ||
        T === d ||
        G ||
        T === l ||
        T === g ||
        T === E ||
        he ||
        T === _ ||
        ue ||
        se ||
        we ||
        (typeof T == 'object' &&
          T !== null &&
          (T.$$typeof === C ||
            T.$$typeof === x ||
            T.$$typeof === h ||
            T.$$typeof === p ||
            T.$$typeof === v ||
            T.$$typeof === Te ||
            T.getModuleId !== void 0))
      )
    }
    function X(T, I) {
      M(T) ||
        de(
          'memo: The first argument must be a component. Instead received: %s',
          T === null ? 'null' : typeof T
        )
      var K = { $$typeof: x, type: T, compare: I === void 0 ? null : I }
      {
        var J
        Object.defineProperty(K, 'displayName', {
          enumerable: !1,
          configurable: !0,
          get: function () {
            return J
          },
          set: function (xe) {
            ;(J = xe), !T.name && !T.displayName && (T.displayName = xe)
          }
        })
      }
      return K
    }
    function ne() {
      var T = A.current
      return (
        T === null &&
          de(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`),
        T
      )
    }
    function Ee(T) {
      var I = ne()
      if (T._context !== void 0) {
        var K = T._context
        K.Consumer === T
          ? de(
              'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?'
            )
          : K.Provider === T &&
            de(
              'Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?'
            )
      }
      return I.useContext(T)
    }
    function _e(T) {
      var I = ne()
      return I.useState(T)
    }
    function Qe(T, I, K) {
      var J = ne()
      return J.useReducer(T, I, K)
    }
    function ke(T) {
      var I = ne()
      return I.useRef(T)
    }
    function ae(T, I) {
      var K = ne()
      return K.useEffect(T, I)
    }
    function V(T, I) {
      var K = ne()
      return K.useInsertionEffect(T, I)
    }
    function re(T, I) {
      var K = ne()
      return K.useLayoutEffect(T, I)
    }
    function ye(T, I) {
      var K = ne()
      return K.useCallback(T, I)
    }
    function qe(T, I) {
      var K = ne()
      return K.useMemo(T, I)
    }
    function tn(T, I, K) {
      var J = ne()
      return J.useImperativeHandle(T, I, K)
    }
    function Qt(T, I) {
      {
        var K = ne()
        return K.useDebugValue(T, I)
      }
    }
    function $t() {
      var T = ne()
      return T.useTransition()
    }
    function Tn(T) {
      var I = ne()
      return I.useDeferredValue(T)
    }
    function vt() {
      var T = ne()
      return T.useId()
    }
    function yn(T, I, K) {
      var J = ne()
      return J.useSyncExternalStore(T, I, K)
    }
    var Gi = 0,
      Mo,
      $c,
      Bc,
      zc,
      Hc,
      Wc,
      Yc
    function Kh() {}
    Kh.__reactDisabledLog = !0
    function _g() {
      {
        if (Gi === 0) {
          ;(Mo = console.log),
            ($c = console.info),
            (Bc = console.warn),
            (zc = console.error),
            (Hc = console.group),
            (Wc = console.groupCollapsed),
            (Yc = console.groupEnd)
          var T = { configurable: !0, enumerable: !0, value: Kh, writable: !0 }
          Object.defineProperties(console, {
            info: T,
            log: T,
            warn: T,
            error: T,
            group: T,
            groupCollapsed: T,
            groupEnd: T
          })
        }
        Gi++
      }
    }
    function qc() {
      {
        if ((Gi--, Gi === 0)) {
          var T = { configurable: !0, enumerable: !0, writable: !0 }
          Object.defineProperties(console, {
            log: Ue({}, T, { value: Mo }),
            info: Ue({}, T, { value: $c }),
            warn: Ue({}, T, { value: Bc }),
            error: Ue({}, T, { value: zc }),
            group: Ue({}, T, { value: Hc }),
            groupCollapsed: Ue({}, T, { value: Wc }),
            groupEnd: Ue({}, T, { value: Yc })
          })
        }
        Gi < 0 && de('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
      }
    }
    var Ls = ge.ReactCurrentDispatcher,
      Li
    function Lo(T, I, K) {
      {
        if (Li === void 0)
          try {
            throw Error()
          } catch (xe) {
            var J = xe.stack.trim().match(/\n( *(at )?)/)
            Li = (J && J[1]) || ''
          }
        return (
          `
` +
          Li +
          T
        )
      }
    }
    var Po = !1,
      Wl
    {
      var Gc = typeof WeakMap == 'function' ? WeakMap : Map
      Wl = new Gc()
    }
    function Zh(T, I) {
      if (!T || Po) return ''
      {
        var K = Wl.get(T)
        if (K !== void 0) return K
      }
      var J
      Po = !0
      var xe = Error.prepareStackTrace
      Error.prepareStackTrace = void 0
      var tt
      ;(tt = Ls.current), (Ls.current = null), _g()
      try {
        if (I) {
          var Be = function () {
            throw Error()
          }
          if (
            (Object.defineProperty(Be.prototype, 'props', {
              set: function () {
                throw Error()
              }
            }),
            typeof Reflect == 'object' && Reflect.construct)
          ) {
            try {
              Reflect.construct(Be, [])
            } catch (Zt) {
              J = Zt
            }
            Reflect.construct(T, [], Be)
          } else {
            try {
              Be.call()
            } catch (Zt) {
              J = Zt
            }
            T.call(Be.prototype)
          }
        } else {
          try {
            throw Error()
          } catch (Zt) {
            J = Zt
          }
          T()
        }
      } catch (Zt) {
        if (Zt && J && typeof Zt.stack == 'string') {
          for (
            var ut = Zt.stack.split(`
`),
              Mt = J.stack.split(`
`),
              an = ut.length - 1,
              dn = Mt.length - 1;
            an >= 1 && dn >= 0 && ut[an] !== Mt[dn];

          )
            dn--
          for (; an >= 1 && dn >= 0; an--, dn--)
            if (ut[an] !== Mt[dn]) {
              if (an !== 1 || dn !== 1)
                do
                  if ((an--, dn--, dn < 0 || ut[an] !== Mt[dn])) {
                    var hn =
                      `
` + ut[an].replace(' at new ', ' at ')
                    return (
                      T.displayName &&
                        hn.includes('<anonymous>') &&
                        (hn = hn.replace('<anonymous>', T.displayName)),
                      typeof T == 'function' && Wl.set(T, hn),
                      hn
                    )
                  }
                while (an >= 1 && dn >= 0)
              break
            }
        }
      } finally {
        ;(Po = !1), (Ls.current = tt), qc(), (Error.prepareStackTrace = xe)
      }
      var bn = T ? T.displayName || T.name : '',
        Dn = bn ? Lo(bn) : ''
      return typeof T == 'function' && Wl.set(T, Dn), Dn
    }
    function Kc(T, I, K) {
      return Zh(T, !1)
    }
    function Og(T) {
      var I = T.prototype
      return !!(I && I.isReactComponent)
    }
    function Io(T, I, K) {
      if (T == null) return ''
      if (typeof T == 'function') return Zh(T, Og(T))
      if (typeof T == 'string') return Lo(T)
      switch (T) {
        case g:
          return Lo('Suspense')
        case E:
          return Lo('SuspenseList')
      }
      if (typeof T == 'object')
        switch (T.$$typeof) {
          case v:
            return Kc(T.render)
          case x:
            return Io(T.type, I, K)
          case C: {
            var J = T,
              xe = J._payload,
              tt = J._init
            try {
              return Io(tt(xe), I, K)
            } catch {}
          }
        }
      return ''
    }
    var Xh = {},
      Zc = ge.ReactDebugCurrentFrame
    function Yl(T) {
      if (T) {
        var I = T._owner,
          K = Io(T.type, T._source, I ? I.type : null)
        Zc.setExtraStackFrame(K)
      } else Zc.setExtraStackFrame(null)
    }
    function Qh(T, I, K, J, xe) {
      {
        var tt = Function.call.bind(tr)
        for (var Be in T)
          if (tt(T, Be)) {
            var ut = void 0
            try {
              if (typeof T[Be] != 'function') {
                var Mt = Error(
                  (J || 'React class') +
                    ': ' +
                    K +
                    ' type `' +
                    Be +
                    '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                    typeof T[Be] +
                    '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
                )
                throw ((Mt.name = 'Invariant Violation'), Mt)
              }
              ut = T[Be](I, Be, J, K, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
            } catch (an) {
              ut = an
            }
            ut &&
              !(ut instanceof Error) &&
              (Yl(xe),
              de(
                '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                J || 'React class',
                K,
                Be,
                typeof ut
              ),
              Yl(null)),
              ut instanceof Error &&
                !(ut.message in Xh) &&
                ((Xh[ut.message] = !0), Yl(xe), de('Failed %s type: %s', K, ut.message), Yl(null))
          }
      }
    }
    function Bt(T) {
      if (T) {
        var I = T._owner,
          K = Io(T.type, T._source, I ? I.type : null)
        Q(K)
      } else Q(null)
    }
    var Xc
    Xc = !1
    function Qc() {
      if (z.current) {
        var T = Pn(z.current.type)
        if (T)
          return (
            `

Check the render method of \`` +
            T +
            '`.'
          )
      }
      return ''
    }
    function bt(T) {
      if (T !== void 0) {
        var I = T.fileName.replace(/^.*[\\\/]/, ''),
          K = T.lineNumber
        return (
          `

Check your code at ` +
          I +
          ':' +
          K +
          '.'
        )
      }
      return ''
    }
    function Jh(T) {
      return T != null ? bt(T.__source) : ''
    }
    var Rr = {}
    function Ps(T) {
      var I = Qc()
      if (!I) {
        var K = typeof T == 'string' ? T : T.displayName || T.name
        K &&
          (I =
            `

Check the top-level render call using <` +
            K +
            '>.')
      }
      return I
    }
    function Fo(T, I) {
      if (!(!T._store || T._store.validated || T.key != null)) {
        T._store.validated = !0
        var K = Ps(I)
        if (!Rr[K]) {
          Rr[K] = !0
          var J = ''
          T &&
            T._owner &&
            T._owner !== z.current &&
            (J = ' It was passed a child from ' + Pn(T._owner.type) + '.'),
            Bt(T),
            de(
              'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
              K,
              J
            ),
            Bt(null)
        }
      }
    }
    function ep(T, I) {
      if (typeof T == 'object') {
        if (Re(T))
          for (var K = 0; K < T.length; K++) {
            var J = T[K]
            _t(J) && Fo(J, I)
          }
        else if (_t(T)) T._store && (T._store.validated = !0)
        else if (T) {
          var xe = D(T)
          if (typeof xe == 'function' && xe !== T.entries)
            for (var tt = xe.call(T), Be; !(Be = tt.next()).done; ) _t(Be.value) && Fo(Be.value, I)
        }
      }
    }
    function ar(T) {
      {
        var I = T.type
        if (I == null || typeof I == 'string') return
        var K
        if (typeof I == 'function') K = I.propTypes
        else if (typeof I == 'object' && (I.$$typeof === v || I.$$typeof === x)) K = I.propTypes
        else return
        if (K) {
          var J = Pn(I)
          Qh(K, T.props, 'prop', J, T)
        } else if (I.PropTypes !== void 0 && !Xc) {
          Xc = !0
          var xe = Pn(I)
          de(
            'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
            xe || 'Unknown'
          )
        }
        typeof I.getDefaultProps == 'function' &&
          !I.getDefaultProps.isReactClassApproved &&
          de(
            'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
          )
      }
    }
    function Rn(T) {
      {
        for (var I = Object.keys(T.props), K = 0; K < I.length; K++) {
          var J = I[K]
          if (J !== 'children' && J !== 'key') {
            Bt(T),
              de(
                'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
                J
              ),
              Bt(null)
            break
          }
        }
        T.ref !== null && (Bt(T), de('Invalid attribute `ref` supplied to `React.Fragment`.'), Bt(null))
      }
    }
    function tp(T, I, K) {
      var J = M(T)
      if (!J) {
        var xe = ''
        ;(T === void 0 || (typeof T == 'object' && T !== null && Object.keys(T).length === 0)) &&
          (xe +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
        var tt = Jh(I)
        tt ? (xe += tt) : (xe += Qc())
        var Be
        T === null
          ? (Be = 'null')
          : Re(T)
            ? (Be = 'array')
            : T !== void 0 && T.$$typeof === a
              ? ((Be = '<' + (Pn(T.type) || 'Unknown') + ' />'),
                (xe = ' Did you accidentally export a JSX literal instead of a component?'))
              : (Be = typeof T),
          de(
            'React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
            Be,
            xe
          )
      }
      var ut = $e.apply(this, arguments)
      if (ut == null) return ut
      if (J) for (var Mt = 2; Mt < arguments.length; Mt++) ep(arguments[Mt], T)
      return T === u ? Rn(ut) : ar(ut), ut
    }
    var hi = !1
    function ti(T) {
      var I = tp.bind(null, T)
      return (
        (I.type = T),
        hi ||
          ((hi = !0),
          De(
            'React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.'
          )),
        Object.defineProperty(I, 'type', {
          enumerable: !1,
          get: function () {
            return (
              De(
                'Factory.type is deprecated. Access the class directly before passing it to createFactory.'
              ),
              Object.defineProperty(this, 'type', { value: T }),
              T
            )
          }
        }),
        I
      )
    }
    function Sa(T, I, K) {
      for (var J = St.apply(this, arguments), xe = 2; xe < arguments.length; xe++)
        ep(arguments[xe], J.type)
      return ar(J), J
    }
    function kg(T, I) {
      var K = L.transition
      L.transition = {}
      var J = L.transition
      L.transition._updatedFibers = new Set()
      try {
        T()
      } finally {
        if (((L.transition = K), K === null && J._updatedFibers)) {
          var xe = J._updatedFibers.size
          xe > 10 &&
            De(
              'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
            ),
            J._updatedFibers.clear()
        }
      }
    }
    var ql = !1,
      Is = null
    function np(T) {
      if (Is === null)
        try {
          var I = ('require' + Math.random()).slice(0, 7),
            K = e && e[I]
          Is = K.call(e, 'timers').setImmediate
        } catch {
          Is = function (xe) {
            ql === !1 &&
              ((ql = !0),
              typeof MessageChannel > 'u' &&
                de(
                  'This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.'
                ))
            var tt = new MessageChannel()
            ;(tt.port1.onmessage = xe), tt.port2.postMessage(void 0)
          }
        }
      return Is(T)
    }
    var Vo = 0,
      rp = !1
    function ip(T) {
      {
        var I = Vo
        Vo++, F.current === null && (F.current = [])
        var K = F.isBatchingLegacy,
          J
        try {
          if (((F.isBatchingLegacy = !0), (J = T()), !K && F.didScheduleLegacyUpdate)) {
            var xe = F.current
            xe !== null && ((F.didScheduleLegacyUpdate = !1), Kl(xe))
          }
        } catch (bn) {
          throw (Ga(I), bn)
        } finally {
          F.isBatchingLegacy = K
        }
        if (J !== null && typeof J == 'object' && typeof J.then == 'function') {
          var tt = J,
            Be = !1,
            ut = {
              then: function (bn, Dn) {
                ;(Be = !0),
                  tt.then(
                    function (Zt) {
                      Ga(I), Vo === 0 ? Gl(Zt, bn, Dn) : bn(Zt)
                    },
                    function (Zt) {
                      Ga(I), Dn(Zt)
                    }
                  )
              }
            }
          return (
            !rp &&
              typeof Promise < 'u' &&
              Promise.resolve()
                .then(function () {})
                .then(function () {
                  Be ||
                    ((rp = !0),
                    de(
                      'You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);'
                    ))
                }),
            ut
          )
        } else {
          var Mt = J
          if ((Ga(I), Vo === 0)) {
            var an = F.current
            an !== null && (Kl(an), (F.current = null))
            var dn = {
              then: function (bn, Dn) {
                F.current === null ? ((F.current = []), Gl(Mt, bn, Dn)) : bn(Mt)
              }
            }
            return dn
          } else {
            var hn = {
              then: function (bn, Dn) {
                bn(Mt)
              }
            }
            return hn
          }
        }
      }
    }
    function Ga(T) {
      T !== Vo - 1 &&
        de(
          'You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. '
        ),
        (Vo = T)
    }
    function Gl(T, I, K) {
      {
        var J = F.current
        if (J !== null)
          try {
            Kl(J),
              np(function () {
                J.length === 0 ? ((F.current = null), I(T)) : Gl(T, I, K)
              })
          } catch (xe) {
            K(xe)
          }
        else I(T)
      }
    }
    var jo = !1
    function Kl(T) {
      if (!jo) {
        jo = !0
        var I = 0
        try {
          for (; I < T.length; I++) {
            var K = T[I]
            do K = K(!0)
            while (K !== null)
          }
          T.length = 0
        } catch (J) {
          throw ((T = T.slice(I + 1)), J)
        } finally {
          jo = !1
        }
      }
    }
    var ap = tp,
      op = Sa,
      sp = ti,
      lp = { map: wr, forEach: ci, count: Ni, toArray: xa, only: fi }
    ;(t.Children = lp),
      (t.Component = xt),
      (t.Fragment = u),
      (t.Profiler = d),
      (t.PureComponent = st),
      (t.StrictMode = l),
      (t.Suspense = g),
      (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ge),
      (t.act = ip),
      (t.cloneElement = op),
      (t.createContext = Mi),
      (t.createElement = ap),
      (t.createFactory = sp),
      (t.createRef = en),
      (t.forwardRef = ce),
      (t.isValidElement = _t),
      (t.lazy = P),
      (t.memo = X),
      (t.startTransition = kg),
      (t.unstable_act = ip),
      (t.useCallback = ye),
      (t.useContext = Ee),
      (t.useDebugValue = Qt),
      (t.useDeferredValue = Tn),
      (t.useEffect = ae),
      (t.useId = vt),
      (t.useImperativeHandle = tn),
      (t.useInsertionEffect = V),
      (t.useLayoutEffect = re),
      (t.useMemo = qe),
      (t.useReducer = Qe),
      (t.useRef = ke),
      (t.useState = _e),
      (t.useSyncExternalStore = yn),
      (t.useTransition = $t),
      (t.version = r),
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
  })()
})(Pv, Pv.exports)
var U6 = Pv.exports
Dk.exports = U6
var w = Dk.exports
const Gt = kk(w),
  Sx = j6({ __proto__: null, default: Gt }, [w])
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  var e = w,
    t = Symbol.for('react.element'),
    r = Symbol.for('react.portal'),
    a = Symbol.for('react.fragment'),
    o = Symbol.for('react.strict_mode'),
    u = Symbol.for('react.profiler'),
    l = Symbol.for('react.provider'),
    d = Symbol.for('react.context'),
    h = Symbol.for('react.forward_ref'),
    p = Symbol.for('react.suspense'),
    v = Symbol.for('react.suspense_list'),
    g = Symbol.for('react.memo'),
    E = Symbol.for('react.lazy'),
    x = Symbol.for('react.offscreen'),
    C = Symbol.iterator,
    _ = '@@iterator'
  function k(P) {
    if (P === null || typeof P != 'object') return null
    var ce = (C && P[C]) || P[_]
    return typeof ce == 'function' ? ce : null
  }
  var R = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  function D(P) {
    {
      for (var ce = arguments.length, Te = new Array(ce > 1 ? ce - 1 : 0), M = 1; M < ce; M++)
        Te[M - 1] = arguments[M]
      A('error', P, Te)
    }
  }
  function A(P, ce, Te) {
    {
      var M = R.ReactDebugCurrentFrame,
        X = M.getStackAddendum()
      X !== '' && ((ce += '%s'), (Te = Te.concat([X])))
      var ne = Te.map(function (Ee) {
        return String(Ee)
      })
      ne.unshift('Warning: ' + ce), Function.prototype.apply.call(console[P], console, ne)
    }
  }
  var L = !1,
    F = !1,
    z = !1,
    H = !1,
    $ = !1,
    Q
  Q = Symbol.for('react.module.reference')
  function ue(P) {
    return !!(
      typeof P == 'string' ||
      typeof P == 'function' ||
      P === a ||
      P === u ||
      $ ||
      P === o ||
      P === p ||
      P === v ||
      H ||
      P === x ||
      L ||
      F ||
      z ||
      (typeof P == 'object' &&
        P !== null &&
        (P.$$typeof === E ||
          P.$$typeof === g ||
          P.$$typeof === l ||
          P.$$typeof === d ||
          P.$$typeof === h ||
          P.$$typeof === Q ||
          P.getModuleId !== void 0))
    )
  }
  function se(P, ce, Te) {
    var M = P.displayName
    if (M) return M
    var X = ce.displayName || ce.name || ''
    return X !== '' ? Te + '(' + X + ')' : Te
  }
  function we(P) {
    return P.displayName || 'Context'
  }
  function he(P) {
    if (P == null) return null
    if (
      (typeof P.tag == 'number' &&
        D(
          'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
        ),
      typeof P == 'function')
    )
      return P.displayName || P.name || null
    if (typeof P == 'string') return P
    switch (P) {
      case a:
        return 'Fragment'
      case r:
        return 'Portal'
      case u:
        return 'Profiler'
      case o:
        return 'StrictMode'
      case p:
        return 'Suspense'
      case v:
        return 'SuspenseList'
    }
    if (typeof P == 'object')
      switch (P.$$typeof) {
        case d:
          var ce = P
          return we(ce) + '.Consumer'
        case l:
          var Te = P
          return we(Te._context) + '.Provider'
        case h:
          return se(P, P.render, 'ForwardRef')
        case g:
          var M = P.displayName || null
          return M !== null ? M : he(P.type) || 'Memo'
        case E: {
          var X = P,
            ne = X._payload,
            Ee = X._init
          try {
            return he(Ee(ne))
          } catch {
            return null
          }
        }
      }
    return null
  }
  var G = Object.assign,
    ge = 0,
    De,
    de,
    ve,
    Ke,
    ot,
    Me,
    Ue
  function pe() {}
  pe.__reactDisabledLog = !0
  function xt() {
    {
      if (ge === 0) {
        ;(De = console.log),
          (de = console.info),
          (ve = console.warn),
          (Ke = console.error),
          (ot = console.group),
          (Me = console.groupCollapsed),
          (Ue = console.groupEnd)
        var P = { configurable: !0, enumerable: !0, value: pe, writable: !0 }
        Object.defineProperties(console, {
          info: P,
          log: P,
          warn: P,
          error: P,
          group: P,
          groupCollapsed: P,
          groupEnd: P
        })
      }
      ge++
    }
  }
  function Ye() {
    {
      if ((ge--, ge === 0)) {
        var P = { configurable: !0, enumerable: !0, writable: !0 }
        Object.defineProperties(console, {
          log: G({}, P, { value: De }),
          info: G({}, P, { value: de }),
          warn: G({}, P, { value: ve }),
          error: G({}, P, { value: Ke }),
          group: G({}, P, { value: ot }),
          groupCollapsed: G({}, P, { value: Me }),
          groupEnd: G({}, P, { value: Ue })
        })
      }
      ge < 0 && D('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
    }
  }
  var kt = R.ReactCurrentDispatcher,
    yt
  function Et(P, ce, Te) {
    {
      if (yt === void 0)
        try {
          throw Error()
        } catch (X) {
          var M = X.stack.trim().match(/\n( *(at )?)/)
          yt = (M && M[1]) || ''
        }
      return (
        `
` +
        yt +
        P
      )
    }
  }
  var st = !1,
    At
  {
    var en = typeof WeakMap == 'function' ? WeakMap : Map
    At = new en()
  }
  function nn(P, ce) {
    if (!P || st) return ''
    {
      var Te = At.get(P)
      if (Te !== void 0) return Te
    }
    var M
    st = !0
    var X = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    var ne
    ;(ne = kt.current), (kt.current = null), xt()
    try {
      if (ce) {
        var Ee = function () {
          throw Error()
        }
        if (
          (Object.defineProperty(Ee.prototype, 'props', {
            set: function () {
              throw Error()
            }
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(Ee, [])
          } catch (qe) {
            M = qe
          }
          Reflect.construct(P, [], Ee)
        } else {
          try {
            Ee.call()
          } catch (qe) {
            M = qe
          }
          P.call(Ee.prototype)
        }
      } else {
        try {
          throw Error()
        } catch (qe) {
          M = qe
        }
        P()
      }
    } catch (qe) {
      if (qe && M && typeof qe.stack == 'string') {
        for (
          var _e = qe.stack.split(`
`),
            Qe = M.stack.split(`
`),
            ke = _e.length - 1,
            ae = Qe.length - 1;
          ke >= 1 && ae >= 0 && _e[ke] !== Qe[ae];

        )
          ae--
        for (; ke >= 1 && ae >= 0; ke--, ae--)
          if (_e[ke] !== Qe[ae]) {
            if (ke !== 1 || ae !== 1)
              do
                if ((ke--, ae--, ae < 0 || _e[ke] !== Qe[ae])) {
                  var V =
                    `
` + _e[ke].replace(' at new ', ' at ')
                  return (
                    P.displayName &&
                      V.includes('<anonymous>') &&
                      (V = V.replace('<anonymous>', P.displayName)),
                    typeof P == 'function' && At.set(P, V),
                    V
                  )
                }
              while (ke >= 1 && ae >= 0)
            break
          }
      }
    } finally {
      ;(st = !1), (kt.current = ne), Ye(), (Error.prepareStackTrace = X)
    }
    var re = P ? P.displayName || P.name : '',
      ye = re ? Et(re) : ''
    return typeof P == 'function' && At.set(P, ye), ye
  }
  function Re(P, ce, Te) {
    return nn(P, !1)
  }
  function Oe(P) {
    var ce = P.prototype
    return !!(ce && ce.isReactComponent)
  }
  function Xe(P, ce, Te) {
    if (P == null) return ''
    if (typeof P == 'function') return nn(P, Oe(P))
    if (typeof P == 'string') return Et(P)
    switch (P) {
      case p:
        return Et('Suspense')
      case v:
        return Et('SuspenseList')
    }
    if (typeof P == 'object')
      switch (P.$$typeof) {
        case h:
          return Re(P.render)
        case g:
          return Xe(P.type, ce, Te)
        case E: {
          var M = P,
            X = M._payload,
            ne = M._init
          try {
            return Xe(ne(X), ce, Te)
          } catch {}
        }
      }
    return ''
  }
  var Dt = Object.prototype.hasOwnProperty,
    Vt = {},
    Cn = R.ReactDebugCurrentFrame
  function xn(P) {
    if (P) {
      var ce = P._owner,
        Te = Xe(P.type, P._source, ce ? ce.type : null)
      Cn.setExtraStackFrame(Te)
    } else Cn.setExtraStackFrame(null)
  }
  function Pn(P, ce, Te, M, X) {
    {
      var ne = Function.call.bind(Dt)
      for (var Ee in P)
        if (ne(P, Ee)) {
          var _e = void 0
          try {
            if (typeof P[Ee] != 'function') {
              var Qe = Error(
                (M || 'React class') +
                  ': ' +
                  Te +
                  ' type `' +
                  Ee +
                  '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                  typeof P[Ee] +
                  '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
              )
              throw ((Qe.name = 'Invariant Violation'), Qe)
            }
            _e = P[Ee](ce, Ee, M, Te, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
          } catch (ke) {
            _e = ke
          }
          _e &&
            !(_e instanceof Error) &&
            (xn(X),
            D(
              '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
              M || 'React class',
              Te,
              Ee,
              typeof _e
            ),
            xn(null)),
            _e instanceof Error &&
              !(_e.message in Vt) &&
              ((Vt[_e.message] = !0), xn(X), D('Failed %s type: %s', Te, _e.message), xn(null))
        }
    }
  }
  var tr = Array.isArray
  function Un(P) {
    return tr(P)
  }
  function In(P) {
    {
      var ce = typeof Symbol == 'function' && Symbol.toStringTag,
        Te = (ce && P[Symbol.toStringTag]) || P.constructor.name || 'Object'
      return Te
    }
  }
  function $n(P) {
    try {
      return mn(P), !1
    } catch {
      return !0
    }
  }
  function mn(P) {
    return '' + P
  }
  function wn(P) {
    if ($n(P))
      return (
        D(
          'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
          In(P)
        ),
        mn(P)
      )
  }
  var rn = R.ReactCurrentOwner,
    fr = { key: !0, ref: !0, __self: !0, __source: !0 },
    jr,
    Cr,
    Se
  Se = {}
  function $e(P) {
    if (Dt.call(P, 'ref')) {
      var ce = Object.getOwnPropertyDescriptor(P, 'ref').get
      if (ce && ce.isReactWarning) return !1
    }
    return P.ref !== void 0
  }
  function pt(P) {
    if (Dt.call(P, 'key')) {
      var ce = Object.getOwnPropertyDescriptor(P, 'key').get
      if (ce && ce.isReactWarning) return !1
    }
    return P.key !== void 0
  }
  function St(P, ce) {
    if (typeof P.ref == 'string' && rn.current && ce && rn.current.stateNode !== ce) {
      var Te = he(rn.current.type)
      Se[Te] ||
        (D(
          'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
          he(rn.current.type),
          P.ref
        ),
        (Se[Te] = !0))
    }
  }
  function _t(P, ce) {
    {
      var Te = function () {
        jr ||
          ((jr = !0),
          D(
            '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            ce
          ))
      }
      ;(Te.isReactWarning = !0), Object.defineProperty(P, 'key', { get: Te, configurable: !0 })
    }
  }
  function gn(P, ce) {
    {
      var Te = function () {
        Cr ||
          ((Cr = !0),
          D(
            '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            ce
          ))
      }
      ;(Te.isReactWarning = !0), Object.defineProperty(P, 'ref', { get: Te, configurable: !0 })
    }
  }
  var fn = function (P, ce, Te, M, X, ne, Ee) {
    var _e = { $$typeof: t, type: P, key: ce, ref: Te, props: Ee, _owner: ne }
    return (
      (_e._store = {}),
      Object.defineProperty(_e._store, 'validated', {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }),
      Object.defineProperty(_e, '_self', { configurable: !1, enumerable: !1, writable: !1, value: M }),
      Object.defineProperty(_e, '_source', { configurable: !1, enumerable: !1, writable: !1, value: X }),
      Object.freeze && (Object.freeze(_e.props), Object.freeze(_e)),
      _e
    )
  }
  function nr(P, ce, Te, M, X) {
    {
      var ne,
        Ee = {},
        _e = null,
        Qe = null
      Te !== void 0 && (wn(Te), (_e = '' + Te)),
        pt(ce) && (wn(ce.key), (_e = '' + ce.key)),
        $e(ce) && ((Qe = ce.ref), St(ce, X))
      for (ne in ce) Dt.call(ce, ne) && !fr.hasOwnProperty(ne) && (Ee[ne] = ce[ne])
      if (P && P.defaultProps) {
        var ke = P.defaultProps
        for (ne in ke) Ee[ne] === void 0 && (Ee[ne] = ke[ne])
      }
      if (_e || Qe) {
        var ae = typeof P == 'function' ? P.displayName || P.name || 'Unknown' : P
        _e && _t(Ee, ae), Qe && gn(Ee, ae)
      }
      return fn(P, _e, Qe, X, M, rn.current, Ee)
    }
  }
  var Nt = R.ReactCurrentOwner,
    rr = R.ReactDebugCurrentFrame
  function Wt(P) {
    if (P) {
      var ce = P._owner,
        Te = Xe(P.type, P._source, ce ? ce.type : null)
      rr.setExtraStackFrame(Te)
    } else rr.setExtraStackFrame(null)
  }
  var lt
  lt = !1
  function Fn(P) {
    return typeof P == 'object' && P !== null && P.$$typeof === t
  }
  function wr() {
    {
      if (Nt.current) {
        var P = he(Nt.current.type)
        if (P)
          return (
            `

Check the render method of \`` +
            P +
            '`.'
          )
      }
      return ''
    }
  }
  function Ni(P) {
    {
      if (P !== void 0) {
        var ce = P.fileName.replace(/^.*[\\\/]/, ''),
          Te = P.lineNumber
        return (
          `

Check your code at ` +
          ce +
          ':' +
          Te +
          '.'
        )
      }
      return ''
    }
  }
  var ci = {}
  function xa(P) {
    {
      var ce = wr()
      if (!ce) {
        var Te = typeof P == 'string' ? P : P.displayName || P.name
        Te &&
          (ce =
            `

Check the top-level render call using <` +
            Te +
            '>.')
      }
      return ce
    }
  }
  function fi(P, ce) {
    {
      if (!P._store || P._store.validated || P.key != null) return
      P._store.validated = !0
      var Te = xa(ce)
      if (ci[Te]) return
      ci[Te] = !0
      var M = ''
      P &&
        P._owner &&
        P._owner !== Nt.current &&
        (M = ' It was passed a child from ' + he(P._owner.type) + '.'),
        Wt(P),
        D(
          'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
          Te,
          M
        ),
        Wt(null)
    }
  }
  function Mi(P, ce) {
    {
      if (typeof P != 'object') return
      if (Un(P))
        for (var Te = 0; Te < P.length; Te++) {
          var M = P[Te]
          Fn(M) && fi(M, ce)
        }
      else if (Fn(P)) P._store && (P._store.validated = !0)
      else if (P) {
        var X = k(P)
        if (typeof X == 'function' && X !== P.entries)
          for (var ne = X.call(P), Ee; !(Ee = ne.next()).done; ) Fn(Ee.value) && fi(Ee.value, ce)
      }
    }
  }
  function Jr(P) {
    {
      var ce = P.type
      if (ce == null || typeof ce == 'string') return
      var Te
      if (typeof ce == 'function') Te = ce.propTypes
      else if (typeof ce == 'object' && (ce.$$typeof === h || ce.$$typeof === g)) Te = ce.propTypes
      else return
      if (Te) {
        var M = he(ce)
        Pn(Te, P.props, 'prop', M, P)
      } else if (ce.PropTypes !== void 0 && !lt) {
        lt = !0
        var X = he(ce)
        D(
          'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
          X || 'Unknown'
        )
      }
      typeof ce.getDefaultProps == 'function' &&
        !ce.getDefaultProps.isReactClassApproved &&
        D(
          'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
        )
    }
  }
  function di(P) {
    {
      for (var ce = Object.keys(P.props), Te = 0; Te < ce.length; Te++) {
        var M = ce[Te]
        if (M !== 'children' && M !== 'key') {
          Wt(P),
            D(
              'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
              M
            ),
            Wt(null)
          break
        }
      }
      P.ref !== null && (Wt(P), D('Invalid attribute `ref` supplied to `React.Fragment`.'), Wt(null))
    }
  }
  var ei = {}
  function Sn(P, ce, Te, M, X, ne) {
    {
      var Ee = ue(P)
      if (!Ee) {
        var _e = ''
        ;(P === void 0 || (typeof P == 'object' && P !== null && Object.keys(P).length === 0)) &&
          (_e +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
        var Qe = Ni(X)
        Qe ? (_e += Qe) : (_e += wr())
        var ke
        P === null
          ? (ke = 'null')
          : Un(P)
            ? (ke = 'array')
            : P !== void 0 && P.$$typeof === t
              ? ((ke = '<' + (he(P.type) || 'Unknown') + ' />'),
                (_e = ' Did you accidentally export a JSX literal instead of a component?'))
              : (ke = typeof P),
          D(
            'React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
            ke,
            _e
          )
      }
      var ae = nr(P, ce, Te, X, ne)
      if (ae == null) return ae
      if (Ee) {
        var V = ce.children
        if (V !== void 0)
          if (M)
            if (Un(V)) {
              for (var re = 0; re < V.length; re++) Mi(V[re], P)
              Object.freeze && Object.freeze(V)
            } else
              D(
                'React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.'
              )
          else Mi(V, P)
      }
      if (Dt.call(ce, 'key')) {
        var ye = he(P),
          qe = Object.keys(ce).filter(function ($t) {
            return $t !== 'key'
          }),
          tn = qe.length > 0 ? '{key: someKey, ' + qe.join(': ..., ') + ': ...}' : '{key: someKey}'
        if (!ei[ye + tn]) {
          var Qt = qe.length > 0 ? '{' + qe.join(': ..., ') + ': ...}' : '{}'
          D(
            `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
            tn,
            ye,
            Qt,
            ye
          ),
            (ei[ye + tn] = !0)
        }
      }
      return P === a ? di(ae) : Jr(ae), ae
    }
  }
  var ir = Sn
  ;(xx.Fragment = a), (xx.jsxDEV = ir)
})()
Ak.exports = xx
var le = Ak.exports,
  Tx = {},
  Nk = { exports: {} },
  Si = {},
  Mk = { exports: {} },
  Lk = {}
;(function (e) {
  /**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ ;(function () {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
    var t = !1,
      r = !1,
      a = 5
    function o(Se, $e) {
      var pt = Se.length
      Se.push($e), d(Se, $e, pt)
    }
    function u(Se) {
      return Se.length === 0 ? null : Se[0]
    }
    function l(Se) {
      if (Se.length === 0) return null
      var $e = Se[0],
        pt = Se.pop()
      return pt !== $e && ((Se[0] = pt), h(Se, pt, 0)), $e
    }
    function d(Se, $e, pt) {
      for (var St = pt; St > 0; ) {
        var _t = (St - 1) >>> 1,
          gn = Se[_t]
        if (p(gn, $e) > 0) (Se[_t] = $e), (Se[St] = gn), (St = _t)
        else return
      }
    }
    function h(Se, $e, pt) {
      for (var St = pt, _t = Se.length, gn = _t >>> 1; St < gn; ) {
        var fn = (St + 1) * 2 - 1,
          nr = Se[fn],
          Nt = fn + 1,
          rr = Se[Nt]
        if (p(nr, $e) < 0)
          Nt < _t && p(rr, nr) < 0
            ? ((Se[St] = rr), (Se[Nt] = $e), (St = Nt))
            : ((Se[St] = nr), (Se[fn] = $e), (St = fn))
        else if (Nt < _t && p(rr, $e) < 0) (Se[St] = rr), (Se[Nt] = $e), (St = Nt)
        else return
      }
    }
    function p(Se, $e) {
      var pt = Se.sortIndex - $e.sortIndex
      return pt !== 0 ? pt : Se.id - $e.id
    }
    var v = 1,
      g = 2,
      E = 3,
      x = 4,
      C = 5
    function _(Se, $e) {}
    var k = typeof performance == 'object' && typeof performance.now == 'function'
    if (k) {
      var R = performance
      e.unstable_now = function () {
        return R.now()
      }
    } else {
      var D = Date,
        A = D.now()
      e.unstable_now = function () {
        return D.now() - A
      }
    }
    var L = 1073741823,
      F = -1,
      z = 250,
      H = 5e3,
      $ = 1e4,
      Q = L,
      ue = [],
      se = [],
      we = 1,
      he = null,
      G = E,
      ge = !1,
      De = !1,
      de = !1,
      ve = typeof setTimeout == 'function' ? setTimeout : null,
      Ke = typeof clearTimeout == 'function' ? clearTimeout : null,
      ot = typeof setImmediate < 'u' ? setImmediate : null
    typeof navigator < 'u' &&
      navigator.scheduling !== void 0 &&
      navigator.scheduling.isInputPending !== void 0 &&
      navigator.scheduling.isInputPending.bind(navigator.scheduling)
    function Me(Se) {
      for (var $e = u(se); $e !== null; ) {
        if ($e.callback === null) l(se)
        else if ($e.startTime <= Se) l(se), ($e.sortIndex = $e.expirationTime), o(ue, $e)
        else return
        $e = u(se)
      }
    }
    function Ue(Se) {
      if (((de = !1), Me(Se), !De))
        if (u(ue) !== null) (De = !0), wn(pe)
        else {
          var $e = u(se)
          $e !== null && rn(Ue, $e.startTime - Se)
        }
    }
    function pe(Se, $e) {
      ;(De = !1), de && ((de = !1), fr()), (ge = !0)
      var pt = G
      try {
        var St
        if (!r) return xt(Se, $e)
      } finally {
        ;(he = null), (G = pt), (ge = !1)
      }
    }
    function xt(Se, $e) {
      var pt = $e
      for (Me(pt), he = u(ue); he !== null && !t && !(he.expirationTime > pt && (!Se || xn())); ) {
        var St = he.callback
        if (typeof St == 'function') {
          ;(he.callback = null), (G = he.priorityLevel)
          var _t = he.expirationTime <= pt,
            gn = St(_t)
          ;(pt = e.unstable_now()),
            typeof gn == 'function' ? (he.callback = gn) : he === u(ue) && l(ue),
            Me(pt)
        } else l(ue)
        he = u(ue)
      }
      if (he !== null) return !0
      var fn = u(se)
      return fn !== null && rn(Ue, fn.startTime - pt), !1
    }
    function Ye(Se, $e) {
      switch (Se) {
        case v:
        case g:
        case E:
        case x:
        case C:
          break
        default:
          Se = E
      }
      var pt = G
      G = Se
      try {
        return $e()
      } finally {
        G = pt
      }
    }
    function kt(Se) {
      var $e
      switch (G) {
        case v:
        case g:
        case E:
          $e = E
          break
        default:
          $e = G
          break
      }
      var pt = G
      G = $e
      try {
        return Se()
      } finally {
        G = pt
      }
    }
    function yt(Se) {
      var $e = G
      return function () {
        var pt = G
        G = $e
        try {
          return Se.apply(this, arguments)
        } finally {
          G = pt
        }
      }
    }
    function Et(Se, $e, pt) {
      var St = e.unstable_now(),
        _t
      if (typeof pt == 'object' && pt !== null) {
        var gn = pt.delay
        typeof gn == 'number' && gn > 0 ? (_t = St + gn) : (_t = St)
      } else _t = St
      var fn
      switch (Se) {
        case v:
          fn = F
          break
        case g:
          fn = z
          break
        case C:
          fn = Q
          break
        case x:
          fn = $
          break
        case E:
        default:
          fn = H
          break
      }
      var nr = _t + fn,
        Nt = {
          id: we++,
          callback: $e,
          priorityLevel: Se,
          startTime: _t,
          expirationTime: nr,
          sortIndex: -1
        }
      return (
        _t > St
          ? ((Nt.sortIndex = _t),
            o(se, Nt),
            u(ue) === null && Nt === u(se) && (de ? fr() : (de = !0), rn(Ue, _t - St)))
          : ((Nt.sortIndex = nr), o(ue, Nt), !De && !ge && ((De = !0), wn(pe))),
        Nt
      )
    }
    function st() {}
    function At() {
      !De && !ge && ((De = !0), wn(pe))
    }
    function en() {
      return u(ue)
    }
    function nn(Se) {
      Se.callback = null
    }
    function Re() {
      return G
    }
    var Oe = !1,
      Xe = null,
      Dt = -1,
      Vt = a,
      Cn = -1
    function xn() {
      var Se = e.unstable_now() - Cn
      return !(Se < Vt)
    }
    function Pn() {}
    function tr(Se) {
      if (Se < 0 || Se > 125) {
        console.error(
          'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
        )
        return
      }
      Se > 0 ? (Vt = Math.floor(1e3 / Se)) : (Vt = a)
    }
    var Un = function () {
        if (Xe !== null) {
          var Se = e.unstable_now()
          Cn = Se
          var $e = !0,
            pt = !0
          try {
            pt = Xe($e, Se)
          } finally {
            pt ? In() : ((Oe = !1), (Xe = null))
          }
        } else Oe = !1
      },
      In
    if (typeof ot == 'function')
      In = function () {
        ot(Un)
      }
    else if (typeof MessageChannel < 'u') {
      var $n = new MessageChannel(),
        mn = $n.port2
      ;($n.port1.onmessage = Un),
        (In = function () {
          mn.postMessage(null)
        })
    } else
      In = function () {
        ve(Un, 0)
      }
    function wn(Se) {
      ;(Xe = Se), Oe || ((Oe = !0), In())
    }
    function rn(Se, $e) {
      Dt = ve(function () {
        Se(e.unstable_now())
      }, $e)
    }
    function fr() {
      Ke(Dt), (Dt = -1)
    }
    var jr = Pn,
      Cr = null
    ;(e.unstable_IdlePriority = C),
      (e.unstable_ImmediatePriority = v),
      (e.unstable_LowPriority = x),
      (e.unstable_NormalPriority = E),
      (e.unstable_Profiling = Cr),
      (e.unstable_UserBlockingPriority = g),
      (e.unstable_cancelCallback = nn),
      (e.unstable_continueExecution = At),
      (e.unstable_forceFrameRate = tr),
      (e.unstable_getCurrentPriorityLevel = Re),
      (e.unstable_getFirstCallbackNode = en),
      (e.unstable_next = kt),
      (e.unstable_pauseExecution = st),
      (e.unstable_requestPaint = jr),
      (e.unstable_runWithPriority = Ye),
      (e.unstable_scheduleCallback = Et),
      (e.unstable_shouldYield = xn),
      (e.unstable_wrapCallback = yt),
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
  })()
})(Lk)
Mk.exports = Lk
var $6 = Mk.exports
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
  var e = w,
    t = $6,
    r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    a = !1
  function o(n) {
    a = n
  }
  function u(n) {
    if (!a) {
      for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), c = 1; c < i; c++)
        s[c - 1] = arguments[c]
      d('warn', n, s)
    }
  }
  function l(n) {
    if (!a) {
      for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), c = 1; c < i; c++)
        s[c - 1] = arguments[c]
      d('error', n, s)
    }
  }
  function d(n, i, s) {
    {
      var c = r.ReactDebugCurrentFrame,
        f = c.getStackAddendum()
      f !== '' && ((i += '%s'), (s = s.concat([f])))
      var m = s.map(function (y) {
        return String(y)
      })
      m.unshift('Warning: ' + i), Function.prototype.apply.call(console[n], console, m)
    }
  }
  var h = 0,
    p = 1,
    v = 2,
    g = 3,
    E = 4,
    x = 5,
    C = 6,
    _ = 7,
    k = 8,
    R = 9,
    D = 10,
    A = 11,
    L = 12,
    F = 13,
    z = 14,
    H = 15,
    $ = 16,
    Q = 17,
    ue = 18,
    se = 19,
    we = 21,
    he = 22,
    G = 23,
    ge = 24,
    De = 25,
    de = !0,
    ve = !1,
    Ke = !1,
    ot = !1,
    Me = !1,
    Ue = !0,
    pe = !1,
    xt = !0,
    Ye = !0,
    kt = !0,
    yt = !0,
    Et = new Set(),
    st = {},
    At = {}
  function en(n, i) {
    nn(n, i), nn(n + 'Capture', i)
  }
  function nn(n, i) {
    st[n] &&
      l('EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.', n),
      (st[n] = i)
    {
      var s = n.toLowerCase()
      ;(At[s] = n), n === 'onDoubleClick' && (At.ondblclick = n)
    }
    for (var c = 0; c < i.length; c++) Et.add(i[c])
  }
  var Re =
      typeof window < 'u' && typeof window.document < 'u' && typeof window.document.createElement < 'u',
    Oe = Object.prototype.hasOwnProperty
  function Xe(n) {
    {
      var i = typeof Symbol == 'function' && Symbol.toStringTag,
        s = (i && n[Symbol.toStringTag]) || n.constructor.name || 'Object'
      return s
    }
  }
  function Dt(n) {
    try {
      return Vt(n), !1
    } catch {
      return !0
    }
  }
  function Vt(n) {
    return '' + n
  }
  function Cn(n, i) {
    if (Dt(n))
      return (
        l(
          'The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.',
          i,
          Xe(n)
        ),
        Vt(n)
      )
  }
  function xn(n) {
    if (Dt(n))
      return (
        l(
          'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
          Xe(n)
        ),
        Vt(n)
      )
  }
  function Pn(n, i) {
    if (Dt(n))
      return (
        l(
          'The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.',
          i,
          Xe(n)
        ),
        Vt(n)
      )
  }
  function tr(n, i) {
    if (Dt(n))
      return (
        l(
          'The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.',
          i,
          Xe(n)
        ),
        Vt(n)
      )
  }
  function Un(n) {
    if (Dt(n))
      return (
        l(
          'The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.',
          Xe(n)
        ),
        Vt(n)
      )
  }
  function In(n) {
    if (Dt(n))
      return (
        l(
          'Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.',
          Xe(n)
        ),
        Vt(n)
      )
  }
  var $n = 0,
    mn = 1,
    wn = 2,
    rn = 3,
    fr = 4,
    jr = 5,
    Cr = 6,
    Se =
      ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    $e = Se + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    pt = new RegExp('^[' + Se + '][' + $e + ']*$'),
    St = {},
    _t = {}
  function gn(n) {
    return Oe.call(_t, n)
      ? !0
      : Oe.call(St, n)
        ? !1
        : pt.test(n)
          ? ((_t[n] = !0), !0)
          : ((St[n] = !0), l('Invalid attribute name: `%s`', n), !1)
  }
  function fn(n, i, s) {
    return i !== null
      ? i.type === $n
      : s
        ? !1
        : n.length > 2 && (n[0] === 'o' || n[0] === 'O') && (n[1] === 'n' || n[1] === 'N')
  }
  function nr(n, i, s, c) {
    if (s !== null && s.type === $n) return !1
    switch (typeof i) {
      case 'function':
      case 'symbol':
        return !0
      case 'boolean': {
        if (c) return !1
        if (s !== null) return !s.acceptsBooleans
        var f = n.toLowerCase().slice(0, 5)
        return f !== 'data-' && f !== 'aria-'
      }
      default:
        return !1
    }
  }
  function Nt(n, i, s, c) {
    if (i === null || typeof i > 'u' || nr(n, i, s, c)) return !0
    if (c) return !1
    if (s !== null)
      switch (s.type) {
        case rn:
          return !i
        case fr:
          return i === !1
        case jr:
          return isNaN(i)
        case Cr:
          return isNaN(i) || i < 1
      }
    return !1
  }
  function rr(n) {
    return lt.hasOwnProperty(n) ? lt[n] : null
  }
  function Wt(n, i, s, c, f, m, y) {
    ;(this.acceptsBooleans = i === wn || i === rn || i === fr),
      (this.attributeName = c),
      (this.attributeNamespace = f),
      (this.mustUseProperty = s),
      (this.propertyName = n),
      (this.type = i),
      (this.sanitizeURL = m),
      (this.removeEmptyString = y)
  }
  var lt = {},
    Fn = [
      'children',
      'dangerouslySetInnerHTML',
      'defaultValue',
      'defaultChecked',
      'innerHTML',
      'suppressContentEditableWarning',
      'suppressHydrationWarning',
      'style'
    ]
  Fn.forEach(function (n) {
    lt[n] = new Wt(n, $n, !1, n, null, !1, !1)
  }),
    [
      ['acceptCharset', 'accept-charset'],
      ['className', 'class'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv']
    ].forEach(function (n) {
      var i = n[0],
        s = n[1]
      lt[i] = new Wt(i, mn, !1, s, null, !1, !1)
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (n) {
      lt[n] = new Wt(n, wn, !1, n.toLowerCase(), null, !1, !1)
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (n) {
      lt[n] = new Wt(n, wn, !1, n, null, !1, !1)
    }),
    [
      'allowFullScreen',
      'async',
      'autoFocus',
      'autoPlay',
      'controls',
      'default',
      'defer',
      'disabled',
      'disablePictureInPicture',
      'disableRemotePlayback',
      'formNoValidate',
      'hidden',
      'loop',
      'noModule',
      'noValidate',
      'open',
      'playsInline',
      'readOnly',
      'required',
      'reversed',
      'scoped',
      'seamless',
      'itemScope'
    ].forEach(function (n) {
      lt[n] = new Wt(n, rn, !1, n.toLowerCase(), null, !1, !1)
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (n) {
      lt[n] = new Wt(n, rn, !0, n, null, !1, !1)
    }),
    ['capture', 'download'].forEach(function (n) {
      lt[n] = new Wt(n, fr, !1, n, null, !1, !1)
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (n) {
      lt[n] = new Wt(n, Cr, !1, n, null, !1, !1)
    }),
    ['rowSpan', 'start'].forEach(function (n) {
      lt[n] = new Wt(n, jr, !1, n.toLowerCase(), null, !1, !1)
    })
  var wr = /[\-\:]([a-z])/g,
    Ni = function (n) {
      return n[1].toUpperCase()
    }
  ;[
    'accent-height',
    'alignment-baseline',
    'arabic-form',
    'baseline-shift',
    'cap-height',
    'clip-path',
    'clip-rule',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'dominant-baseline',
    'enable-background',
    'fill-opacity',
    'fill-rule',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'glyph-name',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'horiz-adv-x',
    'horiz-origin-x',
    'image-rendering',
    'letter-spacing',
    'lighting-color',
    'marker-end',
    'marker-mid',
    'marker-start',
    'overline-position',
    'overline-thickness',
    'paint-order',
    'panose-1',
    'pointer-events',
    'rendering-intent',
    'shape-rendering',
    'stop-color',
    'stop-opacity',
    'strikethrough-position',
    'strikethrough-thickness',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'underline-position',
    'underline-thickness',
    'unicode-bidi',
    'unicode-range',
    'units-per-em',
    'v-alphabetic',
    'v-hanging',
    'v-ideographic',
    'v-mathematical',
    'vector-effect',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'word-spacing',
    'writing-mode',
    'xmlns:xlink',
    'x-height'
  ].forEach(function (n) {
    var i = n.replace(wr, Ni)
    lt[i] = new Wt(i, mn, !1, n, null, !1, !1)
  }),
    ['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(
      function (n) {
        var i = n.replace(wr, Ni)
        lt[i] = new Wt(i, mn, !1, n, 'http://www.w3.org/1999/xlink', !1, !1)
      }
    ),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (n) {
      var i = n.replace(wr, Ni)
      lt[i] = new Wt(i, mn, !1, n, 'http://www.w3.org/XML/1998/namespace', !1, !1)
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (n) {
      lt[n] = new Wt(n, mn, !1, n.toLowerCase(), null, !1, !1)
    })
  var ci = 'xlinkHref'
  ;(lt[ci] = new Wt('xlinkHref', mn, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (n) {
      lt[n] = new Wt(n, mn, !1, n.toLowerCase(), null, !0, !0)
    })
  var xa =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i,
    fi = !1
  function Mi(n) {
    !fi &&
      xa.test(n) &&
      ((fi = !0),
      l(
        'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
        JSON.stringify(n)
      ))
  }
  function Jr(n, i, s, c) {
    if (c.mustUseProperty) {
      var f = c.propertyName
      return n[f]
    } else {
      Cn(s, i), c.sanitizeURL && Mi('' + s)
      var m = c.attributeName,
        y = null
      if (c.type === fr) {
        if (n.hasAttribute(m)) {
          var b = n.getAttribute(m)
          return b === '' ? !0 : Nt(i, s, c, !1) ? b : b === '' + s ? s : b
        }
      } else if (n.hasAttribute(m)) {
        if (Nt(i, s, c, !1)) return n.getAttribute(m)
        if (c.type === rn) return s
        y = n.getAttribute(m)
      }
      return Nt(i, s, c, !1) ? (y === null ? s : y) : y === '' + s ? s : y
    }
  }
  function di(n, i, s, c) {
    {
      if (!gn(i)) return
      if (!n.hasAttribute(i)) return s === void 0 ? void 0 : null
      var f = n.getAttribute(i)
      return Cn(s, i), f === '' + s ? s : f
    }
  }
  function ei(n, i, s, c) {
    var f = rr(i)
    if (!fn(i, f, c)) {
      if ((Nt(i, s, f, c) && (s = null), c || f === null)) {
        if (gn(i)) {
          var m = i
          s === null ? n.removeAttribute(m) : (Cn(s, i), n.setAttribute(m, '' + s))
        }
        return
      }
      var y = f.mustUseProperty
      if (y) {
        var b = f.propertyName
        if (s === null) {
          var S = f.type
          n[b] = S === rn ? !1 : ''
        } else n[b] = s
        return
      }
      var O = f.attributeName,
        N = f.attributeNamespace
      if (s === null) n.removeAttribute(O)
      else {
        var U = f.type,
          j
        U === rn || (U === fr && s === !0)
          ? (j = '')
          : (Cn(s, O), (j = '' + s), f.sanitizeURL && Mi(j.toString())),
          N ? n.setAttributeNS(N, O, j) : n.setAttribute(O, j)
      }
    }
  }
  var Sn = Symbol.for('react.element'),
    ir = Symbol.for('react.portal'),
    P = Symbol.for('react.fragment'),
    ce = Symbol.for('react.strict_mode'),
    Te = Symbol.for('react.profiler'),
    M = Symbol.for('react.provider'),
    X = Symbol.for('react.context'),
    ne = Symbol.for('react.forward_ref'),
    Ee = Symbol.for('react.suspense'),
    _e = Symbol.for('react.suspense_list'),
    Qe = Symbol.for('react.memo'),
    ke = Symbol.for('react.lazy'),
    ae = Symbol.for('react.scope'),
    V = Symbol.for('react.debug_trace_mode'),
    re = Symbol.for('react.offscreen'),
    ye = Symbol.for('react.legacy_hidden'),
    qe = Symbol.for('react.cache'),
    tn = Symbol.for('react.tracing_marker'),
    Qt = Symbol.iterator,
    $t = '@@iterator'
  function Tn(n) {
    if (n === null || typeof n != 'object') return null
    var i = (Qt && n[Qt]) || n[$t]
    return typeof i == 'function' ? i : null
  }
  var vt = Object.assign,
    yn = 0,
    Gi,
    Mo,
    $c,
    Bc,
    zc,
    Hc,
    Wc
  function Yc() {}
  Yc.__reactDisabledLog = !0
  function Kh() {
    {
      if (yn === 0) {
        ;(Gi = console.log),
          (Mo = console.info),
          ($c = console.warn),
          (Bc = console.error),
          (zc = console.group),
          (Hc = console.groupCollapsed),
          (Wc = console.groupEnd)
        var n = { configurable: !0, enumerable: !0, value: Yc, writable: !0 }
        Object.defineProperties(console, {
          info: n,
          log: n,
          warn: n,
          error: n,
          group: n,
          groupCollapsed: n,
          groupEnd: n
        })
      }
      yn++
    }
  }
  function _g() {
    {
      if ((yn--, yn === 0)) {
        var n = { configurable: !0, enumerable: !0, writable: !0 }
        Object.defineProperties(console, {
          log: vt({}, n, { value: Gi }),
          info: vt({}, n, { value: Mo }),
          warn: vt({}, n, { value: $c }),
          error: vt({}, n, { value: Bc }),
          group: vt({}, n, { value: zc }),
          groupCollapsed: vt({}, n, { value: Hc }),
          groupEnd: vt({}, n, { value: Wc })
        })
      }
      yn < 0 && l('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
    }
  }
  var qc = r.ReactCurrentDispatcher,
    Ls
  function Li(n, i, s) {
    {
      if (Ls === void 0)
        try {
          throw Error()
        } catch (f) {
          var c = f.stack.trim().match(/\n( *(at )?)/)
          Ls = (c && c[1]) || ''
        }
      return (
        `
` +
        Ls +
        n
      )
    }
  }
  var Lo = !1,
    Po
  {
    var Wl = typeof WeakMap == 'function' ? WeakMap : Map
    Po = new Wl()
  }
  function Gc(n, i) {
    if (!n || Lo) return ''
    {
      var s = Po.get(n)
      if (s !== void 0) return s
    }
    var c
    Lo = !0
    var f = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    var m
    ;(m = qc.current), (qc.current = null), Kh()
    try {
      if (i) {
        var y = function () {
          throw Error()
        }
        if (
          (Object.defineProperty(y.prototype, 'props', {
            set: function () {
              throw Error()
            }
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(y, [])
          } catch (Z) {
            c = Z
          }
          Reflect.construct(n, [], y)
        } else {
          try {
            y.call()
          } catch (Z) {
            c = Z
          }
          n.call(y.prototype)
        }
      } else {
        try {
          throw Error()
        } catch (Z) {
          c = Z
        }
        n()
      }
    } catch (Z) {
      if (Z && c && typeof Z.stack == 'string') {
        for (
          var b = Z.stack.split(`
`),
            S = c.stack.split(`
`),
            O = b.length - 1,
            N = S.length - 1;
          O >= 1 && N >= 0 && b[O] !== S[N];

        )
          N--
        for (; O >= 1 && N >= 0; O--, N--)
          if (b[O] !== S[N]) {
            if (O !== 1 || N !== 1)
              do
                if ((O--, N--, N < 0 || b[O] !== S[N])) {
                  var U =
                    `
` + b[O].replace(' at new ', ' at ')
                  return (
                    n.displayName &&
                      U.includes('<anonymous>') &&
                      (U = U.replace('<anonymous>', n.displayName)),
                    typeof n == 'function' && Po.set(n, U),
                    U
                  )
                }
              while (O >= 1 && N >= 0)
            break
          }
      }
    } finally {
      ;(Lo = !1), (qc.current = m), _g(), (Error.prepareStackTrace = f)
    }
    var j = n ? n.displayName || n.name : '',
      q = j ? Li(j) : ''
    return typeof n == 'function' && Po.set(n, q), q
  }
  function Zh(n, i, s) {
    return Gc(n, !0)
  }
  function Kc(n, i, s) {
    return Gc(n, !1)
  }
  function Og(n) {
    var i = n.prototype
    return !!(i && i.isReactComponent)
  }
  function Io(n, i, s) {
    if (n == null) return ''
    if (typeof n == 'function') return Gc(n, Og(n))
    if (typeof n == 'string') return Li(n)
    switch (n) {
      case Ee:
        return Li('Suspense')
      case _e:
        return Li('SuspenseList')
    }
    if (typeof n == 'object')
      switch (n.$$typeof) {
        case ne:
          return Kc(n.render)
        case Qe:
          return Io(n.type, i, s)
        case ke: {
          var c = n,
            f = c._payload,
            m = c._init
          try {
            return Io(m(f), i, s)
          } catch {}
        }
      }
    return ''
  }
  function Xh(n) {
    switch ((n._debugOwner && n._debugOwner.type, n._debugSource, n.tag)) {
      case x:
        return Li(n.type)
      case $:
        return Li('Lazy')
      case F:
        return Li('Suspense')
      case se:
        return Li('SuspenseList')
      case h:
      case v:
      case H:
        return Kc(n.type)
      case A:
        return Kc(n.type.render)
      case p:
        return Zh(n.type)
      default:
        return ''
    }
  }
  function Zc(n) {
    try {
      var i = '',
        s = n
      do (i += Xh(s)), (s = s.return)
      while (s)
      return i
    } catch (c) {
      return (
        `
Error generating stack: ` +
        c.message +
        `
` +
        c.stack
      )
    }
  }
  function Yl(n, i, s) {
    var c = n.displayName
    if (c) return c
    var f = i.displayName || i.name || ''
    return f !== '' ? s + '(' + f + ')' : s
  }
  function Qh(n) {
    return n.displayName || 'Context'
  }
  function Bt(n) {
    if (n == null) return null
    if (
      (typeof n.tag == 'number' &&
        l(
          'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
        ),
      typeof n == 'function')
    )
      return n.displayName || n.name || null
    if (typeof n == 'string') return n
    switch (n) {
      case P:
        return 'Fragment'
      case ir:
        return 'Portal'
      case Te:
        return 'Profiler'
      case ce:
        return 'StrictMode'
      case Ee:
        return 'Suspense'
      case _e:
        return 'SuspenseList'
    }
    if (typeof n == 'object')
      switch (n.$$typeof) {
        case X:
          var i = n
          return Qh(i) + '.Consumer'
        case M:
          var s = n
          return Qh(s._context) + '.Provider'
        case ne:
          return Yl(n, n.render, 'ForwardRef')
        case Qe:
          var c = n.displayName || null
          return c !== null ? c : Bt(n.type) || 'Memo'
        case ke: {
          var f = n,
            m = f._payload,
            y = f._init
          try {
            return Bt(y(m))
          } catch {
            return null
          }
        }
      }
    return null
  }
  function Xc(n, i, s) {
    var c = i.displayName || i.name || ''
    return n.displayName || (c !== '' ? s + '(' + c + ')' : s)
  }
  function Qc(n) {
    return n.displayName || 'Context'
  }
  function bt(n) {
    var i = n.tag,
      s = n.type
    switch (i) {
      case ge:
        return 'Cache'
      case R:
        var c = s
        return Qc(c) + '.Consumer'
      case D:
        var f = s
        return Qc(f._context) + '.Provider'
      case ue:
        return 'DehydratedFragment'
      case A:
        return Xc(s, s.render, 'ForwardRef')
      case _:
        return 'Fragment'
      case x:
        return s
      case E:
        return 'Portal'
      case g:
        return 'Root'
      case C:
        return 'Text'
      case $:
        return Bt(s)
      case k:
        return s === ce ? 'StrictMode' : 'Mode'
      case he:
        return 'Offscreen'
      case L:
        return 'Profiler'
      case we:
        return 'Scope'
      case F:
        return 'Suspense'
      case se:
        return 'SuspenseList'
      case De:
        return 'TracingMarker'
      case p:
      case h:
      case Q:
      case v:
      case z:
      case H:
        if (typeof s == 'function') return s.displayName || s.name || null
        if (typeof s == 'string') return s
        break
    }
    return null
  }
  var Jh = r.ReactDebugCurrentFrame,
    Rr = null,
    Ps = !1
  function Fo() {
    {
      if (Rr === null) return null
      var n = Rr._debugOwner
      if (n !== null && typeof n < 'u') return bt(n)
    }
    return null
  }
  function ep() {
    return Rr === null ? '' : Zc(Rr)
  }
  function ar() {
    ;(Jh.getCurrentStack = null), (Rr = null), (Ps = !1)
  }
  function Rn(n) {
    ;(Jh.getCurrentStack = n === null ? null : ep), (Rr = n), (Ps = !1)
  }
  function tp() {
    return Rr
  }
  function hi(n) {
    Ps = n
  }
  function ti(n) {
    return '' + n
  }
  function Sa(n) {
    switch (typeof n) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return n
      case 'object':
        return In(n), n
      default:
        return ''
    }
  }
  var kg = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 }
  function ql(n, i) {
    kg[i.type] ||
      i.onChange ||
      i.onInput ||
      i.readOnly ||
      i.disabled ||
      i.value == null ||
      l(
        'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.'
      ),
      i.onChange ||
        i.readOnly ||
        i.disabled ||
        i.checked == null ||
        l(
          'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.'
        )
  }
  function Is(n) {
    var i = n.type,
      s = n.nodeName
    return s && s.toLowerCase() === 'input' && (i === 'checkbox' || i === 'radio')
  }
  function np(n) {
    return n._valueTracker
  }
  function Vo(n) {
    n._valueTracker = null
  }
  function rp(n) {
    var i = ''
    return n && (Is(n) ? (i = n.checked ? 'true' : 'false') : (i = n.value)), i
  }
  function ip(n) {
    var i = Is(n) ? 'checked' : 'value',
      s = Object.getOwnPropertyDescriptor(n.constructor.prototype, i)
    In(n[i])
    var c = '' + n[i]
    if (
      !(
        n.hasOwnProperty(i) ||
        typeof s > 'u' ||
        typeof s.get != 'function' ||
        typeof s.set != 'function'
      )
    ) {
      var f = s.get,
        m = s.set
      Object.defineProperty(n, i, {
        configurable: !0,
        get: function () {
          return f.call(this)
        },
        set: function (b) {
          In(b), (c = '' + b), m.call(this, b)
        }
      }),
        Object.defineProperty(n, i, { enumerable: s.enumerable })
      var y = {
        getValue: function () {
          return c
        },
        setValue: function (b) {
          In(b), (c = '' + b)
        },
        stopTracking: function () {
          Vo(n), delete n[i]
        }
      }
      return y
    }
  }
  function Ga(n) {
    np(n) || (n._valueTracker = ip(n))
  }
  function Gl(n) {
    if (!n) return !1
    var i = np(n)
    if (!i) return !0
    var s = i.getValue(),
      c = rp(n)
    return c !== s ? (i.setValue(c), !0) : !1
  }
  function jo(n) {
    if (((n = n || (typeof document < 'u' ? document : void 0)), typeof n > 'u')) return null
    try {
      return n.activeElement || n.body
    } catch {
      return n.body
    }
  }
  var Kl = !1,
    ap = !1,
    op = !1,
    sp = !1
  function lp(n) {
    var i = n.type === 'checkbox' || n.type === 'radio'
    return i ? n.checked != null : n.value != null
  }
  function T(n, i) {
    var s = n,
      c = i.checked,
      f = vt({}, i, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: c ?? s._wrapperState.initialChecked
      })
    return f
  }
  function I(n, i) {
    ql('input', i),
      i.checked !== void 0 &&
        i.defaultChecked !== void 0 &&
        !ap &&
        (l(
          '%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          Fo() || 'A component',
          i.type
        ),
        (ap = !0)),
      i.value !== void 0 &&
        i.defaultValue !== void 0 &&
        !Kl &&
        (l(
          '%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          Fo() || 'A component',
          i.type
        ),
        (Kl = !0))
    var s = n,
      c = i.defaultValue == null ? '' : i.defaultValue
    s._wrapperState = {
      initialChecked: i.checked != null ? i.checked : i.defaultChecked,
      initialValue: Sa(i.value != null ? i.value : c),
      controlled: lp(i)
    }
  }
  function K(n, i) {
    var s = n,
      c = i.checked
    c != null && ei(s, 'checked', c, !1)
  }
  function J(n, i) {
    var s = n
    {
      var c = lp(i)
      !s._wrapperState.controlled &&
        c &&
        !sp &&
        (l(
          'A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
        ),
        (sp = !0)),
        s._wrapperState.controlled &&
          !c &&
          !op &&
          (l(
            'A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
          ),
          (op = !0))
    }
    K(n, i)
    var f = Sa(i.value),
      m = i.type
    if (f != null)
      m === 'number'
        ? ((f === 0 && s.value === '') || s.value != f) && (s.value = ti(f))
        : s.value !== ti(f) && (s.value = ti(f))
    else if (m === 'submit' || m === 'reset') {
      s.removeAttribute('value')
      return
    }
    i.hasOwnProperty('value')
      ? ut(s, i.type, f)
      : i.hasOwnProperty('defaultValue') && ut(s, i.type, Sa(i.defaultValue)),
      i.checked == null && i.defaultChecked != null && (s.defaultChecked = !!i.defaultChecked)
  }
  function xe(n, i, s) {
    var c = n
    if (i.hasOwnProperty('value') || i.hasOwnProperty('defaultValue')) {
      var f = i.type,
        m = f === 'submit' || f === 'reset'
      if (m && (i.value === void 0 || i.value === null)) return
      var y = ti(c._wrapperState.initialValue)
      s || (y !== c.value && (c.value = y)), (c.defaultValue = y)
    }
    var b = c.name
    b !== '' && (c.name = ''),
      (c.defaultChecked = !c.defaultChecked),
      (c.defaultChecked = !!c._wrapperState.initialChecked),
      b !== '' && (c.name = b)
  }
  function tt(n, i) {
    var s = n
    J(s, i), Be(s, i)
  }
  function Be(n, i) {
    var s = i.name
    if (i.type === 'radio' && s != null) {
      for (var c = n; c.parentNode; ) c = c.parentNode
      Cn(s, 'name')
      for (
        var f = c.querySelectorAll('input[name=' + JSON.stringify('' + s) + '][type="radio"]'), m = 0;
        m < f.length;
        m++
      ) {
        var y = f[m]
        if (!(y === n || y.form !== n.form)) {
          var b = Gp(y)
          if (!b)
            throw new Error(
              'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'
            )
          Gl(y), J(y, b)
        }
      }
    }
  }
  function ut(n, i, s) {
    ;(i !== 'number' || jo(n.ownerDocument) !== n) &&
      (s == null
        ? (n.defaultValue = ti(n._wrapperState.initialValue))
        : n.defaultValue !== ti(s) && (n.defaultValue = ti(s)))
  }
  var Mt = !1,
    an = !1,
    dn = !1
  function hn(n, i) {
    i.value == null &&
      (typeof i.children == 'object' && i.children !== null
        ? e.Children.forEach(i.children, function (s) {
            s != null &&
              (typeof s == 'string' ||
                typeof s == 'number' ||
                an ||
                ((an = !0),
                l(
                  'Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.'
                )))
          })
        : i.dangerouslySetInnerHTML != null &&
          (dn ||
            ((dn = !0),
            l(
              'Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.'
            )))),
      i.selected != null &&
        !Mt &&
        (l(
          'Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.'
        ),
        (Mt = !0))
  }
  function bn(n, i) {
    i.value != null && n.setAttribute('value', ti(Sa(i.value)))
  }
  var Dn = Array.isArray
  function Zt(n) {
    return Dn(n)
  }
  var Uo
  Uo = !1
  function Zl() {
    var n = Fo()
    return n
      ? `

Check the render method of \`` +
          n +
          '`.'
      : ''
  }
  var Jc = ['value', 'defaultValue']
  function Ag(n) {
    {
      ql('select', n)
      for (var i = 0; i < Jc.length; i++) {
        var s = Jc[i]
        if (n[s] != null) {
          var c = Zt(n[s])
          n.multiple && !c
            ? l('The `%s` prop supplied to <select> must be an array if `multiple` is true.%s', s, Zl())
            : !n.multiple &&
              c &&
              l(
                'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s',
                s,
                Zl()
              )
        }
      }
    }
  }
  function Ka(n, i, s, c) {
    var f = n.options
    if (i) {
      for (var m = s, y = {}, b = 0; b < m.length; b++) y['$' + m[b]] = !0
      for (var S = 0; S < f.length; S++) {
        var O = y.hasOwnProperty('$' + f[S].value)
        f[S].selected !== O && (f[S].selected = O), O && c && (f[S].defaultSelected = !0)
      }
    } else {
      for (var N = ti(Sa(s)), U = null, j = 0; j < f.length; j++) {
        if (f[j].value === N) {
          ;(f[j].selected = !0), c && (f[j].defaultSelected = !0)
          return
        }
        U === null && !f[j].disabled && (U = f[j])
      }
      U !== null && (U.selected = !0)
    }
  }
  function ef(n, i) {
    return vt({}, i, { value: void 0 })
  }
  function tf(n, i) {
    var s = n
    Ag(i),
      (s._wrapperState = { wasMultiple: !!i.multiple }),
      i.value !== void 0 &&
        i.defaultValue !== void 0 &&
        !Uo &&
        (l(
          'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components'
        ),
        (Uo = !0))
  }
  function Dg(n, i) {
    var s = n
    s.multiple = !!i.multiple
    var c = i.value
    c != null
      ? Ka(s, !!i.multiple, c, !1)
      : i.defaultValue != null && Ka(s, !!i.multiple, i.defaultValue, !0)
  }
  function xM(n, i) {
    var s = n,
      c = s._wrapperState.wasMultiple
    s._wrapperState.wasMultiple = !!i.multiple
    var f = i.value
    f != null
      ? Ka(s, !!i.multiple, f, !1)
      : c !== !!i.multiple &&
        (i.defaultValue != null
          ? Ka(s, !!i.multiple, i.defaultValue, !0)
          : Ka(s, !!i.multiple, i.multiple ? [] : '', !1))
  }
  function SM(n, i) {
    var s = n,
      c = i.value
    c != null && Ka(s, !!i.multiple, c, !1)
  }
  var T1 = !1
  function Ng(n, i) {
    var s = n
    if (i.dangerouslySetInnerHTML != null)
      throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.')
    var c = vt({}, i, {
      value: void 0,
      defaultValue: void 0,
      children: ti(s._wrapperState.initialValue)
    })
    return c
  }
  function C1(n, i) {
    var s = n
    ql('textarea', i),
      i.value !== void 0 &&
        i.defaultValue !== void 0 &&
        !T1 &&
        (l(
          '%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          Fo() || 'A component'
        ),
        (T1 = !0))
    var c = i.value
    if (c == null) {
      var f = i.children,
        m = i.defaultValue
      if (f != null) {
        l('Use the `defaultValue` or `value` props instead of setting children on <textarea>.')
        {
          if (m != null)
            throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.')
          if (Zt(f)) {
            if (f.length > 1) throw new Error('<textarea> can only have at most one child.')
            f = f[0]
          }
          m = f
        }
      }
      m == null && (m = ''), (c = m)
    }
    s._wrapperState = { initialValue: Sa(c) }
  }
  function w1(n, i) {
    var s = n,
      c = Sa(i.value),
      f = Sa(i.defaultValue)
    if (c != null) {
      var m = ti(c)
      m !== s.value && (s.value = m),
        i.defaultValue == null && s.defaultValue !== m && (s.defaultValue = m)
    }
    f != null && (s.defaultValue = ti(f))
  }
  function R1(n, i) {
    var s = n,
      c = s.textContent
    c === s._wrapperState.initialValue && c !== '' && c !== null && (s.value = c)
  }
  function TM(n, i) {
    w1(n, i)
  }
  var Za = 'http://www.w3.org/1999/xhtml',
    CM = 'http://www.w3.org/1998/Math/MathML',
    Mg = 'http://www.w3.org/2000/svg'
  function Lg(n) {
    switch (n) {
      case 'svg':
        return Mg
      case 'math':
        return CM
      default:
        return Za
    }
  }
  function Pg(n, i) {
    return n == null || n === Za ? Lg(i) : n === Mg && i === 'foreignObject' ? Za : n
  }
  var wM = function (n) {
      return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
        ? function (i, s, c, f) {
            MSApp.execUnsafeLocalFunction(function () {
              return n(i, s, c, f)
            })
          }
        : n
    },
    up,
    _1 = wM(function (n, i) {
      if (n.namespaceURI === Mg && !('innerHTML' in n)) {
        ;(up = up || document.createElement('div')),
          (up.innerHTML = '<svg>' + i.valueOf().toString() + '</svg>')
        for (var s = up.firstChild; n.firstChild; ) n.removeChild(n.firstChild)
        for (; s.firstChild; ) n.appendChild(s.firstChild)
        return
      }
      n.innerHTML = i
    }),
    ni = 1,
    Xa = 3,
    Bn = 8,
    Qa = 9,
    Ig = 11,
    cp = function (n, i) {
      if (i) {
        var s = n.firstChild
        if (s && s === n.lastChild && s.nodeType === Xa) {
          s.nodeValue = i
          return
        }
      }
      n.textContent = i
    },
    RM = {
      animation: [
        'animationDelay',
        'animationDirection',
        'animationDuration',
        'animationFillMode',
        'animationIterationCount',
        'animationName',
        'animationPlayState',
        'animationTimingFunction'
      ],
      background: [
        'backgroundAttachment',
        'backgroundClip',
        'backgroundColor',
        'backgroundImage',
        'backgroundOrigin',
        'backgroundPositionX',
        'backgroundPositionY',
        'backgroundRepeat',
        'backgroundSize'
      ],
      backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
      border: [
        'borderBottomColor',
        'borderBottomStyle',
        'borderBottomWidth',
        'borderImageOutset',
        'borderImageRepeat',
        'borderImageSlice',
        'borderImageSource',
        'borderImageWidth',
        'borderLeftColor',
        'borderLeftStyle',
        'borderLeftWidth',
        'borderRightColor',
        'borderRightStyle',
        'borderRightWidth',
        'borderTopColor',
        'borderTopStyle',
        'borderTopWidth'
      ],
      borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
      borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
      borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
      borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
      borderImage: [
        'borderImageOutset',
        'borderImageRepeat',
        'borderImageSlice',
        'borderImageSource',
        'borderImageWidth'
      ],
      borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
      borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
      borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
      borderRadius: [
        'borderBottomLeftRadius',
        'borderBottomRightRadius',
        'borderTopLeftRadius',
        'borderTopRightRadius'
      ],
      borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
      borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
      borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
      borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
      columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
      columns: ['columnCount', 'columnWidth'],
      flex: ['flexBasis', 'flexGrow', 'flexShrink'],
      flexFlow: ['flexDirection', 'flexWrap'],
      font: [
        'fontFamily',
        'fontFeatureSettings',
        'fontKerning',
        'fontLanguageOverride',
        'fontSize',
        'fontSizeAdjust',
        'fontStretch',
        'fontStyle',
        'fontVariant',
        'fontVariantAlternates',
        'fontVariantCaps',
        'fontVariantEastAsian',
        'fontVariantLigatures',
        'fontVariantNumeric',
        'fontVariantPosition',
        'fontWeight',
        'lineHeight'
      ],
      fontVariant: [
        'fontVariantAlternates',
        'fontVariantCaps',
        'fontVariantEastAsian',
        'fontVariantLigatures',
        'fontVariantNumeric',
        'fontVariantPosition'
      ],
      gap: ['columnGap', 'rowGap'],
      grid: [
        'gridAutoColumns',
        'gridAutoFlow',
        'gridAutoRows',
        'gridTemplateAreas',
        'gridTemplateColumns',
        'gridTemplateRows'
      ],
      gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
      gridColumn: ['gridColumnEnd', 'gridColumnStart'],
      gridColumnGap: ['columnGap'],
      gridGap: ['columnGap', 'rowGap'],
      gridRow: ['gridRowEnd', 'gridRowStart'],
      gridRowGap: ['rowGap'],
      gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
      listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
      margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
      marker: ['markerEnd', 'markerMid', 'markerStart'],
      mask: [
        'maskClip',
        'maskComposite',
        'maskImage',
        'maskMode',
        'maskOrigin',
        'maskPositionX',
        'maskPositionY',
        'maskRepeat',
        'maskSize'
      ],
      maskPosition: ['maskPositionX', 'maskPositionY'],
      outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
      overflow: ['overflowX', 'overflowY'],
      padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
      placeContent: ['alignContent', 'justifyContent'],
      placeItems: ['alignItems', 'justifyItems'],
      placeSelf: ['alignSelf', 'justifySelf'],
      textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
      textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
      transition: [
        'transitionDelay',
        'transitionDuration',
        'transitionProperty',
        'transitionTimingFunction'
      ],
      wordWrap: ['overflowWrap']
    },
    nf = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }
  function _M(n, i) {
    return n + i.charAt(0).toUpperCase() + i.substring(1)
  }
  var OM = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(nf).forEach(function (n) {
    OM.forEach(function (i) {
      nf[_M(i, n)] = nf[n]
    })
  })
  function Fg(n, i, s) {
    var c = i == null || typeof i == 'boolean' || i === ''
    return c
      ? ''
      : !s && typeof i == 'number' && i !== 0 && !(nf.hasOwnProperty(n) && nf[n])
        ? i + 'px'
        : (tr(i, n), ('' + i).trim())
  }
  var kM = /([A-Z])/g,
    AM = /^ms-/
  function DM(n) {
    return n.replace(kM, '-$1').toLowerCase().replace(AM, '-ms-')
  }
  var O1 = function () {}
  {
    var NM = /^(?:webkit|moz|o)[A-Z]/,
      MM = /^-ms-/,
      LM = /-(.)/g,
      k1 = /;\s*$/,
      Xl = {},
      Vg = {},
      A1 = !1,
      D1 = !1,
      PM = function (n) {
        return n.replace(LM, function (i, s) {
          return s.toUpperCase()
        })
      },
      IM = function (n) {
        ;(Xl.hasOwnProperty(n) && Xl[n]) ||
          ((Xl[n] = !0),
          l('Unsupported style property %s. Did you mean %s?', n, PM(n.replace(MM, 'ms-'))))
      },
      FM = function (n) {
        ;(Xl.hasOwnProperty(n) && Xl[n]) ||
          ((Xl[n] = !0),
          l(
            'Unsupported vendor-prefixed style property %s. Did you mean %s?',
            n,
            n.charAt(0).toUpperCase() + n.slice(1)
          ))
      },
      VM = function (n, i) {
        ;(Vg.hasOwnProperty(i) && Vg[i]) ||
          ((Vg[i] = !0),
          l(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            n,
            i.replace(k1, '')
          ))
      },
      jM = function (n, i) {
        A1 || ((A1 = !0), l('`NaN` is an invalid value for the `%s` css style property.', n))
      },
      UM = function (n, i) {
        D1 || ((D1 = !0), l('`Infinity` is an invalid value for the `%s` css style property.', n))
      }
    O1 = function (n, i) {
      n.indexOf('-') > -1 ? IM(n) : NM.test(n) ? FM(n) : k1.test(i) && VM(n, i),
        typeof i == 'number' && (isNaN(i) ? jM(n, i) : isFinite(i) || UM(n, i))
    }
  }
  var $M = O1
  function BM(n) {
    {
      var i = '',
        s = ''
      for (var c in n)
        if (n.hasOwnProperty(c)) {
          var f = n[c]
          if (f != null) {
            var m = c.indexOf('--') === 0
            ;(i += s + (m ? c : DM(c)) + ':'), (i += Fg(c, f, m)), (s = ';')
          }
        }
      return i || null
    }
  }
  function N1(n, i) {
    var s = n.style
    for (var c in i)
      if (i.hasOwnProperty(c)) {
        var f = c.indexOf('--') === 0
        f || $M(c, i[c])
        var m = Fg(c, i[c], f)
        c === 'float' && (c = 'cssFloat'), f ? s.setProperty(c, m) : (s[c] = m)
      }
  }
  function zM(n) {
    return n == null || typeof n == 'boolean' || n === ''
  }
  function M1(n) {
    var i = {}
    for (var s in n) for (var c = RM[s] || [s], f = 0; f < c.length; f++) i[c[f]] = s
    return i
  }
  function HM(n, i) {
    {
      if (!i) return
      var s = M1(n),
        c = M1(i),
        f = {}
      for (var m in s) {
        var y = s[m],
          b = c[m]
        if (b && y !== b) {
          var S = y + ',' + b
          if (f[S]) continue
          ;(f[S] = !0),
            l(
              "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
              zM(n[y]) ? 'Removing' : 'Updating',
              y,
              b
            )
        }
      }
    }
  }
  var WM = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    },
    YM = vt({ menuitem: !0 }, WM),
    qM = '__html'
  function jg(n, i) {
    if (i) {
      if (YM[n] && (i.children != null || i.dangerouslySetInnerHTML != null))
        throw new Error(
          n +
            ' is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.'
        )
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null)
          throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.')
        if (typeof i.dangerouslySetInnerHTML != 'object' || !(qM in i.dangerouslySetInnerHTML))
          throw new Error(
            '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.'
          )
      }
      if (
        (!i.suppressContentEditableWarning &&
          i.contentEditable &&
          i.children != null &&
          l(
            'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.'
          ),
        i.style != null && typeof i.style != 'object')
      )
        throw new Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        )
    }
  }
  function Fs(n, i) {
    if (n.indexOf('-') === -1) return typeof i.is == 'string'
    switch (n) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  var fp = {
      accept: 'accept',
      acceptcharset: 'acceptCharset',
      'accept-charset': 'acceptCharset',
      accesskey: 'accessKey',
      action: 'action',
      allowfullscreen: 'allowFullScreen',
      alt: 'alt',
      as: 'as',
      async: 'async',
      autocapitalize: 'autoCapitalize',
      autocomplete: 'autoComplete',
      autocorrect: 'autoCorrect',
      autofocus: 'autoFocus',
      autoplay: 'autoPlay',
      autosave: 'autoSave',
      capture: 'capture',
      cellpadding: 'cellPadding',
      cellspacing: 'cellSpacing',
      challenge: 'challenge',
      charset: 'charSet',
      checked: 'checked',
      children: 'children',
      cite: 'cite',
      class: 'className',
      classid: 'classID',
      classname: 'className',
      cols: 'cols',
      colspan: 'colSpan',
      content: 'content',
      contenteditable: 'contentEditable',
      contextmenu: 'contextMenu',
      controls: 'controls',
      controlslist: 'controlsList',
      coords: 'coords',
      crossorigin: 'crossOrigin',
      dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
      data: 'data',
      datetime: 'dateTime',
      default: 'default',
      defaultchecked: 'defaultChecked',
      defaultvalue: 'defaultValue',
      defer: 'defer',
      dir: 'dir',
      disabled: 'disabled',
      disablepictureinpicture: 'disablePictureInPicture',
      disableremoteplayback: 'disableRemotePlayback',
      download: 'download',
      draggable: 'draggable',
      enctype: 'encType',
      enterkeyhint: 'enterKeyHint',
      for: 'htmlFor',
      form: 'form',
      formmethod: 'formMethod',
      formaction: 'formAction',
      formenctype: 'formEncType',
      formnovalidate: 'formNoValidate',
      formtarget: 'formTarget',
      frameborder: 'frameBorder',
      headers: 'headers',
      height: 'height',
      hidden: 'hidden',
      high: 'high',
      href: 'href',
      hreflang: 'hrefLang',
      htmlfor: 'htmlFor',
      httpequiv: 'httpEquiv',
      'http-equiv': 'httpEquiv',
      icon: 'icon',
      id: 'id',
      imagesizes: 'imageSizes',
      imagesrcset: 'imageSrcSet',
      innerhtml: 'innerHTML',
      inputmode: 'inputMode',
      integrity: 'integrity',
      is: 'is',
      itemid: 'itemID',
      itemprop: 'itemProp',
      itemref: 'itemRef',
      itemscope: 'itemScope',
      itemtype: 'itemType',
      keyparams: 'keyParams',
      keytype: 'keyType',
      kind: 'kind',
      label: 'label',
      lang: 'lang',
      list: 'list',
      loop: 'loop',
      low: 'low',
      manifest: 'manifest',
      marginwidth: 'marginWidth',
      marginheight: 'marginHeight',
      max: 'max',
      maxlength: 'maxLength',
      media: 'media',
      mediagroup: 'mediaGroup',
      method: 'method',
      min: 'min',
      minlength: 'minLength',
      multiple: 'multiple',
      muted: 'muted',
      name: 'name',
      nomodule: 'noModule',
      nonce: 'nonce',
      novalidate: 'noValidate',
      open: 'open',
      optimum: 'optimum',
      pattern: 'pattern',
      placeholder: 'placeholder',
      playsinline: 'playsInline',
      poster: 'poster',
      preload: 'preload',
      profile: 'profile',
      radiogroup: 'radioGroup',
      readonly: 'readOnly',
      referrerpolicy: 'referrerPolicy',
      rel: 'rel',
      required: 'required',
      reversed: 'reversed',
      role: 'role',
      rows: 'rows',
      rowspan: 'rowSpan',
      sandbox: 'sandbox',
      scope: 'scope',
      scoped: 'scoped',
      scrolling: 'scrolling',
      seamless: 'seamless',
      selected: 'selected',
      shape: 'shape',
      size: 'size',
      sizes: 'sizes',
      span: 'span',
      spellcheck: 'spellCheck',
      src: 'src',
      srcdoc: 'srcDoc',
      srclang: 'srcLang',
      srcset: 'srcSet',
      start: 'start',
      step: 'step',
      style: 'style',
      summary: 'summary',
      tabindex: 'tabIndex',
      target: 'target',
      title: 'title',
      type: 'type',
      usemap: 'useMap',
      value: 'value',
      width: 'width',
      wmode: 'wmode',
      wrap: 'wrap',
      about: 'about',
      accentheight: 'accentHeight',
      'accent-height': 'accentHeight',
      accumulate: 'accumulate',
      additive: 'additive',
      alignmentbaseline: 'alignmentBaseline',
      'alignment-baseline': 'alignmentBaseline',
      allowreorder: 'allowReorder',
      alphabetic: 'alphabetic',
      amplitude: 'amplitude',
      arabicform: 'arabicForm',
      'arabic-form': 'arabicForm',
      ascent: 'ascent',
      attributename: 'attributeName',
      attributetype: 'attributeType',
      autoreverse: 'autoReverse',
      azimuth: 'azimuth',
      basefrequency: 'baseFrequency',
      baselineshift: 'baselineShift',
      'baseline-shift': 'baselineShift',
      baseprofile: 'baseProfile',
      bbox: 'bbox',
      begin: 'begin',
      bias: 'bias',
      by: 'by',
      calcmode: 'calcMode',
      capheight: 'capHeight',
      'cap-height': 'capHeight',
      clip: 'clip',
      clippath: 'clipPath',
      'clip-path': 'clipPath',
      clippathunits: 'clipPathUnits',
      cliprule: 'clipRule',
      'clip-rule': 'clipRule',
      color: 'color',
      colorinterpolation: 'colorInterpolation',
      'color-interpolation': 'colorInterpolation',
      colorinterpolationfilters: 'colorInterpolationFilters',
      'color-interpolation-filters': 'colorInterpolationFilters',
      colorprofile: 'colorProfile',
      'color-profile': 'colorProfile',
      colorrendering: 'colorRendering',
      'color-rendering': 'colorRendering',
      contentscripttype: 'contentScriptType',
      contentstyletype: 'contentStyleType',
      cursor: 'cursor',
      cx: 'cx',
      cy: 'cy',
      d: 'd',
      datatype: 'datatype',
      decelerate: 'decelerate',
      descent: 'descent',
      diffuseconstant: 'diffuseConstant',
      direction: 'direction',
      display: 'display',
      divisor: 'divisor',
      dominantbaseline: 'dominantBaseline',
      'dominant-baseline': 'dominantBaseline',
      dur: 'dur',
      dx: 'dx',
      dy: 'dy',
      edgemode: 'edgeMode',
      elevation: 'elevation',
      enablebackground: 'enableBackground',
      'enable-background': 'enableBackground',
      end: 'end',
      exponent: 'exponent',
      externalresourcesrequired: 'externalResourcesRequired',
      fill: 'fill',
      fillopacity: 'fillOpacity',
      'fill-opacity': 'fillOpacity',
      fillrule: 'fillRule',
      'fill-rule': 'fillRule',
      filter: 'filter',
      filterres: 'filterRes',
      filterunits: 'filterUnits',
      floodopacity: 'floodOpacity',
      'flood-opacity': 'floodOpacity',
      floodcolor: 'floodColor',
      'flood-color': 'floodColor',
      focusable: 'focusable',
      fontfamily: 'fontFamily',
      'font-family': 'fontFamily',
      fontsize: 'fontSize',
      'font-size': 'fontSize',
      fontsizeadjust: 'fontSizeAdjust',
      'font-size-adjust': 'fontSizeAdjust',
      fontstretch: 'fontStretch',
      'font-stretch': 'fontStretch',
      fontstyle: 'fontStyle',
      'font-style': 'fontStyle',
      fontvariant: 'fontVariant',
      'font-variant': 'fontVariant',
      fontweight: 'fontWeight',
      'font-weight': 'fontWeight',
      format: 'format',
      from: 'from',
      fx: 'fx',
      fy: 'fy',
      g1: 'g1',
      g2: 'g2',
      glyphname: 'glyphName',
      'glyph-name': 'glyphName',
      glyphorientationhorizontal: 'glyphOrientationHorizontal',
      'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
      glyphorientationvertical: 'glyphOrientationVertical',
      'glyph-orientation-vertical': 'glyphOrientationVertical',
      glyphref: 'glyphRef',
      gradienttransform: 'gradientTransform',
      gradientunits: 'gradientUnits',
      hanging: 'hanging',
      horizadvx: 'horizAdvX',
      'horiz-adv-x': 'horizAdvX',
      horizoriginx: 'horizOriginX',
      'horiz-origin-x': 'horizOriginX',
      ideographic: 'ideographic',
      imagerendering: 'imageRendering',
      'image-rendering': 'imageRendering',
      in2: 'in2',
      in: 'in',
      inlist: 'inlist',
      intercept: 'intercept',
      k1: 'k1',
      k2: 'k2',
      k3: 'k3',
      k4: 'k4',
      k: 'k',
      kernelmatrix: 'kernelMatrix',
      kernelunitlength: 'kernelUnitLength',
      kerning: 'kerning',
      keypoints: 'keyPoints',
      keysplines: 'keySplines',
      keytimes: 'keyTimes',
      lengthadjust: 'lengthAdjust',
      letterspacing: 'letterSpacing',
      'letter-spacing': 'letterSpacing',
      lightingcolor: 'lightingColor',
      'lighting-color': 'lightingColor',
      limitingconeangle: 'limitingConeAngle',
      local: 'local',
      markerend: 'markerEnd',
      'marker-end': 'markerEnd',
      markerheight: 'markerHeight',
      markermid: 'markerMid',
      'marker-mid': 'markerMid',
      markerstart: 'markerStart',
      'marker-start': 'markerStart',
      markerunits: 'markerUnits',
      markerwidth: 'markerWidth',
      mask: 'mask',
      maskcontentunits: 'maskContentUnits',
      maskunits: 'maskUnits',
      mathematical: 'mathematical',
      mode: 'mode',
      numoctaves: 'numOctaves',
      offset: 'offset',
      opacity: 'opacity',
      operator: 'operator',
      order: 'order',
      orient: 'orient',
      orientation: 'orientation',
      origin: 'origin',
      overflow: 'overflow',
      overlineposition: 'overlinePosition',
      'overline-position': 'overlinePosition',
      overlinethickness: 'overlineThickness',
      'overline-thickness': 'overlineThickness',
      paintorder: 'paintOrder',
      'paint-order': 'paintOrder',
      panose1: 'panose1',
      'panose-1': 'panose1',
      pathlength: 'pathLength',
      patterncontentunits: 'patternContentUnits',
      patterntransform: 'patternTransform',
      patternunits: 'patternUnits',
      pointerevents: 'pointerEvents',
      'pointer-events': 'pointerEvents',
      points: 'points',
      pointsatx: 'pointsAtX',
      pointsaty: 'pointsAtY',
      pointsatz: 'pointsAtZ',
      prefix: 'prefix',
      preservealpha: 'preserveAlpha',
      preserveaspectratio: 'preserveAspectRatio',
      primitiveunits: 'primitiveUnits',
      property: 'property',
      r: 'r',
      radius: 'radius',
      refx: 'refX',
      refy: 'refY',
      renderingintent: 'renderingIntent',
      'rendering-intent': 'renderingIntent',
      repeatcount: 'repeatCount',
      repeatdur: 'repeatDur',
      requiredextensions: 'requiredExtensions',
      requiredfeatures: 'requiredFeatures',
      resource: 'resource',
      restart: 'restart',
      result: 'result',
      results: 'results',
      rotate: 'rotate',
      rx: 'rx',
      ry: 'ry',
      scale: 'scale',
      security: 'security',
      seed: 'seed',
      shaperendering: 'shapeRendering',
      'shape-rendering': 'shapeRendering',
      slope: 'slope',
      spacing: 'spacing',
      specularconstant: 'specularConstant',
      specularexponent: 'specularExponent',
      speed: 'speed',
      spreadmethod: 'spreadMethod',
      startoffset: 'startOffset',
      stddeviation: 'stdDeviation',
      stemh: 'stemh',
      stemv: 'stemv',
      stitchtiles: 'stitchTiles',
      stopcolor: 'stopColor',
      'stop-color': 'stopColor',
      stopopacity: 'stopOpacity',
      'stop-opacity': 'stopOpacity',
      strikethroughposition: 'strikethroughPosition',
      'strikethrough-position': 'strikethroughPosition',
      strikethroughthickness: 'strikethroughThickness',
      'strikethrough-thickness': 'strikethroughThickness',
      string: 'string',
      stroke: 'stroke',
      strokedasharray: 'strokeDasharray',
      'stroke-dasharray': 'strokeDasharray',
      strokedashoffset: 'strokeDashoffset',
      'stroke-dashoffset': 'strokeDashoffset',
      strokelinecap: 'strokeLinecap',
      'stroke-linecap': 'strokeLinecap',
      strokelinejoin: 'strokeLinejoin',
      'stroke-linejoin': 'strokeLinejoin',
      strokemiterlimit: 'strokeMiterlimit',
      'stroke-miterlimit': 'strokeMiterlimit',
      strokewidth: 'strokeWidth',
      'stroke-width': 'strokeWidth',
      strokeopacity: 'strokeOpacity',
      'stroke-opacity': 'strokeOpacity',
      suppresscontenteditablewarning: 'suppressContentEditableWarning',
      suppresshydrationwarning: 'suppressHydrationWarning',
      surfacescale: 'surfaceScale',
      systemlanguage: 'systemLanguage',
      tablevalues: 'tableValues',
      targetx: 'targetX',
      targety: 'targetY',
      textanchor: 'textAnchor',
      'text-anchor': 'textAnchor',
      textdecoration: 'textDecoration',
      'text-decoration': 'textDecoration',
      textlength: 'textLength',
      textrendering: 'textRendering',
      'text-rendering': 'textRendering',
      to: 'to',
      transform: 'transform',
      typeof: 'typeof',
      u1: 'u1',
      u2: 'u2',
      underlineposition: 'underlinePosition',
      'underline-position': 'underlinePosition',
      underlinethickness: 'underlineThickness',
      'underline-thickness': 'underlineThickness',
      unicode: 'unicode',
      unicodebidi: 'unicodeBidi',
      'unicode-bidi': 'unicodeBidi',
      unicoderange: 'unicodeRange',
      'unicode-range': 'unicodeRange',
      unitsperem: 'unitsPerEm',
      'units-per-em': 'unitsPerEm',
      unselectable: 'unselectable',
      valphabetic: 'vAlphabetic',
      'v-alphabetic': 'vAlphabetic',
      values: 'values',
      vectoreffect: 'vectorEffect',
      'vector-effect': 'vectorEffect',
      version: 'version',
      vertadvy: 'vertAdvY',
      'vert-adv-y': 'vertAdvY',
      vertoriginx: 'vertOriginX',
      'vert-origin-x': 'vertOriginX',
      vertoriginy: 'vertOriginY',
      'vert-origin-y': 'vertOriginY',
      vhanging: 'vHanging',
      'v-hanging': 'vHanging',
      videographic: 'vIdeographic',
      'v-ideographic': 'vIdeographic',
      viewbox: 'viewBox',
      viewtarget: 'viewTarget',
      visibility: 'visibility',
      vmathematical: 'vMathematical',
      'v-mathematical': 'vMathematical',
      vocab: 'vocab',
      widths: 'widths',
      wordspacing: 'wordSpacing',
      'word-spacing': 'wordSpacing',
      writingmode: 'writingMode',
      'writing-mode': 'writingMode',
      x1: 'x1',
      x2: 'x2',
      x: 'x',
      xchannelselector: 'xChannelSelector',
      xheight: 'xHeight',
      'x-height': 'xHeight',
      xlinkactuate: 'xlinkActuate',
      'xlink:actuate': 'xlinkActuate',
      xlinkarcrole: 'xlinkArcrole',
      'xlink:arcrole': 'xlinkArcrole',
      xlinkhref: 'xlinkHref',
      'xlink:href': 'xlinkHref',
      xlinkrole: 'xlinkRole',
      'xlink:role': 'xlinkRole',
      xlinkshow: 'xlinkShow',
      'xlink:show': 'xlinkShow',
      xlinktitle: 'xlinkTitle',
      'xlink:title': 'xlinkTitle',
      xlinktype: 'xlinkType',
      'xlink:type': 'xlinkType',
      xmlbase: 'xmlBase',
      'xml:base': 'xmlBase',
      xmllang: 'xmlLang',
      'xml:lang': 'xmlLang',
      xmlns: 'xmlns',
      'xml:space': 'xmlSpace',
      xmlnsxlink: 'xmlnsXlink',
      'xmlns:xlink': 'xmlnsXlink',
      xmlspace: 'xmlSpace',
      y1: 'y1',
      y2: 'y2',
      y: 'y',
      ychannelselector: 'yChannelSelector',
      z: 'z',
      zoomandpan: 'zoomAndPan'
    },
    L1 = {
      'aria-current': 0,
      'aria-description': 0,
      'aria-details': 0,
      'aria-disabled': 0,
      'aria-hidden': 0,
      'aria-invalid': 0,
      'aria-keyshortcuts': 0,
      'aria-label': 0,
      'aria-roledescription': 0,
      'aria-autocomplete': 0,
      'aria-checked': 0,
      'aria-expanded': 0,
      'aria-haspopup': 0,
      'aria-level': 0,
      'aria-modal': 0,
      'aria-multiline': 0,
      'aria-multiselectable': 0,
      'aria-orientation': 0,
      'aria-placeholder': 0,
      'aria-pressed': 0,
      'aria-readonly': 0,
      'aria-required': 0,
      'aria-selected': 0,
      'aria-sort': 0,
      'aria-valuemax': 0,
      'aria-valuemin': 0,
      'aria-valuenow': 0,
      'aria-valuetext': 0,
      'aria-atomic': 0,
      'aria-busy': 0,
      'aria-live': 0,
      'aria-relevant': 0,
      'aria-dropeffect': 0,
      'aria-grabbed': 0,
      'aria-activedescendant': 0,
      'aria-colcount': 0,
      'aria-colindex': 0,
      'aria-colspan': 0,
      'aria-controls': 0,
      'aria-describedby': 0,
      'aria-errormessage': 0,
      'aria-flowto': 0,
      'aria-labelledby': 0,
      'aria-owns': 0,
      'aria-posinset': 0,
      'aria-rowcount': 0,
      'aria-rowindex': 0,
      'aria-rowspan': 0,
      'aria-setsize': 0
    },
    Ql = {},
    GM = new RegExp('^(aria)-[' + $e + ']*$'),
    KM = new RegExp('^(aria)[A-Z][' + $e + ']*$')
  function ZM(n, i) {
    {
      if (Oe.call(Ql, i) && Ql[i]) return !0
      if (KM.test(i)) {
        var s = 'aria-' + i.slice(4).toLowerCase(),
          c = L1.hasOwnProperty(s) ? s : null
        if (c == null)
          return (
            l(
              'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
              i
            ),
            (Ql[i] = !0),
            !0
          )
        if (i !== c) return l('Invalid ARIA attribute `%s`. Did you mean `%s`?', i, c), (Ql[i] = !0), !0
      }
      if (GM.test(i)) {
        var f = i.toLowerCase(),
          m = L1.hasOwnProperty(f) ? f : null
        if (m == null) return (Ql[i] = !0), !1
        if (i !== m) return l('Unknown ARIA attribute `%s`. Did you mean `%s`?', i, m), (Ql[i] = !0), !0
      }
    }
    return !0
  }
  function XM(n, i) {
    {
      var s = []
      for (var c in i) {
        var f = ZM(n, c)
        f || s.push(c)
      }
      var m = s
        .map(function (y) {
          return '`' + y + '`'
        })
        .join(', ')
      s.length === 1
        ? l(
            'Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
            m,
            n
          )
        : s.length > 1 &&
          l(
            'Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
            m,
            n
          )
    }
  }
  function QM(n, i) {
    Fs(n, i) || XM(n, i)
  }
  var P1 = !1
  function JM(n, i) {
    {
      if (n !== 'input' && n !== 'textarea' && n !== 'select') return
      i != null &&
        i.value === null &&
        !P1 &&
        ((P1 = !0),
        n === 'select' && i.multiple
          ? l(
              '`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
              n
            )
          : l(
              '`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
              n
            ))
    }
  }
  var I1 = function () {}
  {
    var Ur = {},
      F1 = /^on./,
      e3 = /^on[^A-Z]/,
      t3 = new RegExp('^(aria)-[' + $e + ']*$'),
      n3 = new RegExp('^(aria)[A-Z][' + $e + ']*$')
    I1 = function (n, i, s, c) {
      if (Oe.call(Ur, i) && Ur[i]) return !0
      var f = i.toLowerCase()
      if (f === 'onfocusin' || f === 'onfocusout')
        return (
          l(
            'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.'
          ),
          (Ur[i] = !0),
          !0
        )
      if (c != null) {
        var m = c.registrationNameDependencies,
          y = c.possibleRegistrationNames
        if (m.hasOwnProperty(i)) return !0
        var b = y.hasOwnProperty(f) ? y[f] : null
        if (b != null)
          return l('Invalid event handler property `%s`. Did you mean `%s`?', i, b), (Ur[i] = !0), !0
        if (F1.test(i))
          return l('Unknown event handler property `%s`. It will be ignored.', i), (Ur[i] = !0), !0
      } else if (F1.test(i))
        return (
          e3.test(i) &&
            l(
              'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
              i
            ),
          (Ur[i] = !0),
          !0
        )
      if (t3.test(i) || n3.test(i)) return !0
      if (f === 'innerhtml')
        return (
          l(
            'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.'
          ),
          (Ur[i] = !0),
          !0
        )
      if (f === 'aria')
        return (
          l(
            'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.'
          ),
          (Ur[i] = !0),
          !0
        )
      if (f === 'is' && s !== null && s !== void 0 && typeof s != 'string')
        return (
          l(
            'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
            typeof s
          ),
          (Ur[i] = !0),
          !0
        )
      if (typeof s == 'number' && isNaN(s))
        return (
          l('Received NaN for the `%s` attribute. If this is expected, cast the value to a string.', i),
          (Ur[i] = !0),
          !0
        )
      var S = rr(i),
        O = S !== null && S.type === $n
      if (fp.hasOwnProperty(f)) {
        var N = fp[f]
        if (N !== i) return l('Invalid DOM property `%s`. Did you mean `%s`?', i, N), (Ur[i] = !0), !0
      } else if (!O && i !== f)
        return (
          l(
            'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
            i,
            f
          ),
          (Ur[i] = !0),
          !0
        )
      return typeof s == 'boolean' && nr(i, s, S, !1)
        ? (s
            ? l(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                s,
                i,
                i,
                s,
                i
              )
            : l(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                s,
                i,
                i,
                s,
                i,
                i,
                i
              ),
          (Ur[i] = !0),
          !0)
        : O
          ? !0
          : nr(i, s, S, !1)
            ? ((Ur[i] = !0), !1)
            : ((s === 'false' || s === 'true') &&
                S !== null &&
                S.type === rn &&
                (l(
                  'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
                  s,
                  i,
                  s === 'false'
                    ? 'The browser will interpret it as a truthy value.'
                    : 'Although this works, it will not work as expected if you pass the string "false".',
                  i,
                  s
                ),
                (Ur[i] = !0)),
              !0)
    }
  }
  var r3 = function (n, i, s) {
    {
      var c = []
      for (var f in i) {
        var m = I1(n, f, i[f], s)
        m || c.push(f)
      }
      var y = c
        .map(function (b) {
          return '`' + b + '`'
        })
        .join(', ')
      c.length === 1
        ? l(
            'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
            y,
            n
          )
        : c.length > 1 &&
          l(
            'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
            y,
            n
          )
    }
  }
  function i3(n, i, s) {
    Fs(n, i) || r3(n, i, s)
  }
  var V1 = 1,
    Ug = 2,
    rf = 4,
    a3 = V1 | Ug | rf,
    af = null
  function o3(n) {
    af !== null &&
      l(
        'Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.'
      ),
      (af = n)
  }
  function s3() {
    af === null &&
      l(
        'Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.'
      ),
      (af = null)
  }
  function l3(n) {
    return n === af
  }
  function $g(n) {
    var i = n.target || n.srcElement || window
    return (
      i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === Xa ? i.parentNode : i
    )
  }
  var Bg = null,
    Jl = null,
    eu = null
  function j1(n) {
    var i = Go(n)
    if (i) {
      if (typeof Bg != 'function')
        throw new Error(
          'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'
        )
      var s = i.stateNode
      if (s) {
        var c = Gp(s)
        Bg(i.stateNode, i.type, c)
      }
    }
  }
  function u3(n) {
    Bg = n
  }
  function U1(n) {
    Jl ? (eu ? eu.push(n) : (eu = [n])) : (Jl = n)
  }
  function c3() {
    return Jl !== null || eu !== null
  }
  function $1() {
    if (Jl) {
      var n = Jl,
        i = eu
      if (((Jl = null), (eu = null), j1(n), i)) for (var s = 0; s < i.length; s++) j1(i[s])
    }
  }
  var B1 = function (n, i) {
      return n(i)
    },
    z1 = function () {},
    zg = !1
  function f3() {
    var n = c3()
    n && (z1(), $1())
  }
  function H1(n, i, s) {
    if (zg) return n(i, s)
    zg = !0
    try {
      return B1(n, i, s)
    } finally {
      ;(zg = !1), f3()
    }
  }
  function d3(n, i, s) {
    ;(B1 = n), (z1 = s)
  }
  function h3(n) {
    return n === 'button' || n === 'input' || n === 'select' || n === 'textarea'
  }
  function p3(n, i, s) {
    switch (n) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        return !!(s.disabled && h3(i))
      default:
        return !1
    }
  }
  function of(n, i) {
    var s = n.stateNode
    if (s === null) return null
    var c = Gp(s)
    if (c === null) return null
    var f = c[i]
    if (p3(i, n.type, c)) return null
    if (f && typeof f != 'function')
      throw new Error(
        'Expected `' + i + '` listener to be a function, instead got a value of `' + typeof f + '` type.'
      )
    return f
  }
  var Hg = !1
  if (Re)
    try {
      var sf = {}
      Object.defineProperty(sf, 'passive', {
        get: function () {
          Hg = !0
        }
      }),
        window.addEventListener('test', sf, sf),
        window.removeEventListener('test', sf, sf)
    } catch {
      Hg = !1
    }
  function W1(n, i, s, c, f, m, y, b, S) {
    var O = Array.prototype.slice.call(arguments, 3)
    try {
      i.apply(s, O)
    } catch (N) {
      this.onError(N)
    }
  }
  var Y1 = W1
  if (
    typeof window < 'u' &&
    typeof window.dispatchEvent == 'function' &&
    typeof document < 'u' &&
    typeof document.createEvent == 'function'
  ) {
    var Wg = document.createElement('react')
    Y1 = function (i, s, c, f, m, y, b, S, O) {
      if (typeof document > 'u' || document === null)
        throw new Error(
          'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'
        )
      var N = document.createEvent('Event'),
        U = !1,
        j = !0,
        q = window.event,
        Z = Object.getOwnPropertyDescriptor(window, 'event')
      function ee() {
        Wg.removeEventListener(te, Ze, !1),
          typeof window.event < 'u' && window.hasOwnProperty('event') && (window.event = q)
      }
      var Ae = Array.prototype.slice.call(arguments, 3)
      function Ze() {
        ;(U = !0), ee(), s.apply(c, Ae), (j = !1)
      }
      var We,
        It = !1,
        Ot = !1
      function W(Y) {
        if (
          ((We = Y.error),
          (It = !0),
          We === null && Y.colno === 0 && Y.lineno === 0 && (Ot = !0),
          Y.defaultPrevented && We != null && typeof We == 'object')
        )
          try {
            We._suppressLogging = !0
          } catch {}
      }
      var te = 'react-' + (i || 'invokeguardedcallback')
      if (
        (window.addEventListener('error', W),
        Wg.addEventListener(te, Ze, !1),
        N.initEvent(te, !1, !1),
        Wg.dispatchEvent(N),
        Z && Object.defineProperty(window, 'event', Z),
        U &&
          j &&
          (It
            ? Ot &&
              (We = new Error(
                "A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information."
              ))
            : (We = new Error(
                `An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`
              )),
          this.onError(We)),
        window.removeEventListener('error', W),
        !U)
      )
        return ee(), W1.apply(this, arguments)
    }
  }
  var m3 = Y1,
    tu = !1,
    dp = null,
    hp = !1,
    Yg = null,
    v3 = {
      onError: function (n) {
        ;(tu = !0), (dp = n)
      }
    }
  function qg(n, i, s, c, f, m, y, b, S) {
    ;(tu = !1), (dp = null), m3.apply(v3, arguments)
  }
  function g3(n, i, s, c, f, m, y, b, S) {
    if ((qg.apply(this, arguments), tu)) {
      var O = Gg()
      hp || ((hp = !0), (Yg = O))
    }
  }
  function y3() {
    if (hp) {
      var n = Yg
      throw ((hp = !1), (Yg = null), n)
    }
  }
  function b3() {
    return tu
  }
  function Gg() {
    if (tu) {
      var n = dp
      return (tu = !1), (dp = null), n
    } else
      throw new Error(
        'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.'
      )
  }
  function nu(n) {
    return n._reactInternals
  }
  function E3(n) {
    return n._reactInternals !== void 0
  }
  function x3(n, i) {
    n._reactInternals = i
  }
  var et = 0,
    ru = 1,
    zn = 2,
    jt = 4,
    Vs = 16,
    lf = 32,
    Kg = 64,
    Xt = 128,
    Ja = 256,
    $o = 512,
    js = 1024,
    Ki = 2048,
    eo = 4096,
    Us = 8192,
    pp = 16384,
    S3 = Ki | jt | Kg | $o | js | pp,
    T3 = 32767,
    uf = 32768,
    $r = 65536,
    Zg = 131072,
    q1 = 1048576,
    Xg = 2097152,
    $s = 4194304,
    Qg = 8388608,
    to = 16777216,
    mp = 33554432,
    Jg = jt | js | 0,
    e0 = zn | jt | Vs | lf | $o | eo | Us,
    cf = jt | Kg | $o | Us,
    iu = Ki | Vs,
    no = $s | Qg | Xg,
    C3 = r.ReactCurrentOwner
  function Bs(n) {
    var i = n,
      s = n
    if (n.alternate) for (; i.return; ) i = i.return
    else {
      var c = i
      do (i = c), (i.flags & (zn | eo)) !== et && (s = i.return), (c = i.return)
      while (c)
    }
    return i.tag === g ? s : null
  }
  function G1(n) {
    if (n.tag === F) {
      var i = n.memoizedState
      if (i === null) {
        var s = n.alternate
        s !== null && (i = s.memoizedState)
      }
      if (i !== null) return i.dehydrated
    }
    return null
  }
  function K1(n) {
    return n.tag === g ? n.stateNode.containerInfo : null
  }
  function w3(n) {
    return Bs(n) === n
  }
  function R3(n) {
    {
      var i = C3.current
      if (i !== null && i.tag === p) {
        var s = i,
          c = s.stateNode
        c._warnedAboutRefsInRender ||
          l(
            '%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
            bt(s) || 'A component'
          ),
          (c._warnedAboutRefsInRender = !0)
      }
    }
    var f = nu(n)
    return f ? Bs(f) === f : !1
  }
  function Z1(n) {
    if (Bs(n) !== n) throw new Error('Unable to find node on an unmounted component.')
  }
  function X1(n) {
    var i = n.alternate
    if (!i) {
      var s = Bs(n)
      if (s === null) throw new Error('Unable to find node on an unmounted component.')
      return s !== n ? null : n
    }
    for (var c = n, f = i; ; ) {
      var m = c.return
      if (m === null) break
      var y = m.alternate
      if (y === null) {
        var b = m.return
        if (b !== null) {
          c = f = b
          continue
        }
        break
      }
      if (m.child === y.child) {
        for (var S = m.child; S; ) {
          if (S === c) return Z1(m), n
          if (S === f) return Z1(m), i
          S = S.sibling
        }
        throw new Error('Unable to find node on an unmounted component.')
      }
      if (c.return !== f.return) (c = m), (f = y)
      else {
        for (var O = !1, N = m.child; N; ) {
          if (N === c) {
            ;(O = !0), (c = m), (f = y)
            break
          }
          if (N === f) {
            ;(O = !0), (f = m), (c = y)
            break
          }
          N = N.sibling
        }
        if (!O) {
          for (N = y.child; N; ) {
            if (N === c) {
              ;(O = !0), (c = y), (f = m)
              break
            }
            if (N === f) {
              ;(O = !0), (f = y), (c = m)
              break
            }
            N = N.sibling
          }
          if (!O)
            throw new Error(
              'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'
            )
        }
      }
      if (c.alternate !== f)
        throw new Error(
          "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
        )
    }
    if (c.tag !== g) throw new Error('Unable to find node on an unmounted component.')
    return c.stateNode.current === c ? n : i
  }
  function Q1(n) {
    var i = X1(n)
    return i !== null ? J1(i) : null
  }
  function J1(n) {
    if (n.tag === x || n.tag === C) return n
    for (var i = n.child; i !== null; ) {
      var s = J1(i)
      if (s !== null) return s
      i = i.sibling
    }
    return null
  }
  function _3(n) {
    var i = X1(n)
    return i !== null ? eT(i) : null
  }
  function eT(n) {
    if (n.tag === x || n.tag === C) return n
    for (var i = n.child; i !== null; ) {
      if (i.tag !== E) {
        var s = eT(i)
        if (s !== null) return s
      }
      i = i.sibling
    }
    return null
  }
  var tT = t.unstable_scheduleCallback,
    O3 = t.unstable_cancelCallback,
    k3 = t.unstable_shouldYield,
    A3 = t.unstable_requestPaint,
    or = t.unstable_now,
    D3 = t.unstable_getCurrentPriorityLevel,
    vp = t.unstable_ImmediatePriority,
    t0 = t.unstable_UserBlockingPriority,
    zs = t.unstable_NormalPriority,
    N3 = t.unstable_LowPriority,
    n0 = t.unstable_IdlePriority,
    M3 = t.unstable_yieldValue,
    L3 = t.unstable_setDisableYieldValue,
    au = null,
    _r = null,
    Le = null,
    Ta = !1,
    Zi = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u'
  function P3(n) {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u') return !1
    var i = __REACT_DEVTOOLS_GLOBAL_HOOK__
    if (i.isDisabled) return !0
    if (!i.supportsFiber)
      return (
        l(
          'The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools'
        ),
        !0
      )
    try {
      Ye && (n = vt({}, n, { getLaneLabelMap: $3, injectProfilingHooks: U3 })),
        (au = i.inject(n)),
        (_r = i)
    } catch (s) {
      l('React instrumentation encountered an error: %s.', s)
    }
    return !!i.checkDCE
  }
  function I3(n, i) {
    if (_r && typeof _r.onScheduleFiberRoot == 'function')
      try {
        _r.onScheduleFiberRoot(au, n, i)
      } catch (s) {
        Ta || ((Ta = !0), l('React instrumentation encountered an error: %s', s))
      }
  }
  function F3(n, i) {
    if (_r && typeof _r.onCommitFiberRoot == 'function')
      try {
        var s = (n.current.flags & Xt) === Xt
        if (kt) {
          var c
          switch (i) {
            case vi:
              c = vp
              break
            case io:
              c = t0
              break
            case ao:
              c = zs
              break
            case Tp:
              c = n0
              break
            default:
              c = zs
              break
          }
          _r.onCommitFiberRoot(au, n, c, s)
        }
      } catch (f) {
        Ta || ((Ta = !0), l('React instrumentation encountered an error: %s', f))
      }
  }
  function V3(n) {
    if (_r && typeof _r.onPostCommitFiberRoot == 'function')
      try {
        _r.onPostCommitFiberRoot(au, n)
      } catch (i) {
        Ta || ((Ta = !0), l('React instrumentation encountered an error: %s', i))
      }
  }
  function j3(n) {
    if (_r && typeof _r.onCommitFiberUnmount == 'function')
      try {
        _r.onCommitFiberUnmount(au, n)
      } catch (i) {
        Ta || ((Ta = !0), l('React instrumentation encountered an error: %s', i))
      }
  }
  function sr(n) {
    if ((typeof M3 == 'function' && (L3(n), o(n)), _r && typeof _r.setStrictMode == 'function'))
      try {
        _r.setStrictMode(au, n)
      } catch (i) {
        Ta || ((Ta = !0), l('React instrumentation encountered an error: %s', i))
      }
  }
  function U3(n) {
    Le = n
  }
  function $3() {
    {
      for (var n = new Map(), i = 1, s = 0; s < i0; s++) {
        var c = sL(i)
        n.set(i, c), (i *= 2)
      }
      return n
    }
  }
  function B3(n) {
    Le !== null && typeof Le.markCommitStarted == 'function' && Le.markCommitStarted(n)
  }
  function nT() {
    Le !== null && typeof Le.markCommitStopped == 'function' && Le.markCommitStopped()
  }
  function ff(n) {
    Le !== null && typeof Le.markComponentRenderStarted == 'function' && Le.markComponentRenderStarted(n)
  }
  function ou() {
    Le !== null && typeof Le.markComponentRenderStopped == 'function' && Le.markComponentRenderStopped()
  }
  function z3(n) {
    Le !== null &&
      typeof Le.markComponentPassiveEffectMountStarted == 'function' &&
      Le.markComponentPassiveEffectMountStarted(n)
  }
  function H3() {
    Le !== null &&
      typeof Le.markComponentPassiveEffectMountStopped == 'function' &&
      Le.markComponentPassiveEffectMountStopped()
  }
  function W3(n) {
    Le !== null &&
      typeof Le.markComponentPassiveEffectUnmountStarted == 'function' &&
      Le.markComponentPassiveEffectUnmountStarted(n)
  }
  function Y3() {
    Le !== null &&
      typeof Le.markComponentPassiveEffectUnmountStopped == 'function' &&
      Le.markComponentPassiveEffectUnmountStopped()
  }
  function q3(n) {
    Le !== null &&
      typeof Le.markComponentLayoutEffectMountStarted == 'function' &&
      Le.markComponentLayoutEffectMountStarted(n)
  }
  function G3() {
    Le !== null &&
      typeof Le.markComponentLayoutEffectMountStopped == 'function' &&
      Le.markComponentLayoutEffectMountStopped()
  }
  function rT(n) {
    Le !== null &&
      typeof Le.markComponentLayoutEffectUnmountStarted == 'function' &&
      Le.markComponentLayoutEffectUnmountStarted(n)
  }
  function iT() {
    Le !== null &&
      typeof Le.markComponentLayoutEffectUnmountStopped == 'function' &&
      Le.markComponentLayoutEffectUnmountStopped()
  }
  function K3(n, i, s) {
    Le !== null && typeof Le.markComponentErrored == 'function' && Le.markComponentErrored(n, i, s)
  }
  function Z3(n, i, s) {
    Le !== null && typeof Le.markComponentSuspended == 'function' && Le.markComponentSuspended(n, i, s)
  }
  function X3(n) {
    Le !== null && typeof Le.markLayoutEffectsStarted == 'function' && Le.markLayoutEffectsStarted(n)
  }
  function Q3() {
    Le !== null && typeof Le.markLayoutEffectsStopped == 'function' && Le.markLayoutEffectsStopped()
  }
  function J3(n) {
    Le !== null && typeof Le.markPassiveEffectsStarted == 'function' && Le.markPassiveEffectsStarted(n)
  }
  function eL() {
    Le !== null && typeof Le.markPassiveEffectsStopped == 'function' && Le.markPassiveEffectsStopped()
  }
  function aT(n) {
    Le !== null && typeof Le.markRenderStarted == 'function' && Le.markRenderStarted(n)
  }
  function tL() {
    Le !== null && typeof Le.markRenderYielded == 'function' && Le.markRenderYielded()
  }
  function oT() {
    Le !== null && typeof Le.markRenderStopped == 'function' && Le.markRenderStopped()
  }
  function nL(n) {
    Le !== null && typeof Le.markRenderScheduled == 'function' && Le.markRenderScheduled(n)
  }
  function rL(n, i) {
    Le !== null && typeof Le.markForceUpdateScheduled == 'function' && Le.markForceUpdateScheduled(n, i)
  }
  function r0(n, i) {
    Le !== null && typeof Le.markStateUpdateScheduled == 'function' && Le.markStateUpdateScheduled(n, i)
  }
  var Je = 0,
    Lt = 1,
    on = 2,
    Nn = 8,
    Ca = 16,
    sT = Math.clz32 ? Math.clz32 : oL,
    iL = Math.log,
    aL = Math.LN2
  function oL(n) {
    var i = n >>> 0
    return i === 0 ? 32 : (31 - ((iL(i) / aL) | 0)) | 0
  }
  var i0 = 31,
    fe = 0,
    lr = 0,
    ct = 1,
    su = 2,
    ro = 4,
    Hs = 8,
    wa = 16,
    df = 32,
    lu = 4194240,
    hf = 64,
    a0 = 128,
    o0 = 256,
    s0 = 512,
    l0 = 1024,
    u0 = 2048,
    c0 = 4096,
    f0 = 8192,
    d0 = 16384,
    h0 = 32768,
    p0 = 65536,
    m0 = 131072,
    v0 = 262144,
    g0 = 524288,
    y0 = 1048576,
    b0 = 2097152,
    gp = 130023424,
    uu = 4194304,
    E0 = 8388608,
    x0 = 16777216,
    S0 = 33554432,
    T0 = 67108864,
    lT = uu,
    pf = 134217728,
    uT = 268435455,
    mf = 268435456,
    Ws = 536870912,
    pi = 1073741824
  function sL(n) {
    {
      if (n & ct) return 'Sync'
      if (n & su) return 'InputContinuousHydration'
      if (n & ro) return 'InputContinuous'
      if (n & Hs) return 'DefaultHydration'
      if (n & wa) return 'Default'
      if (n & df) return 'TransitionHydration'
      if (n & lu) return 'Transition'
      if (n & gp) return 'Retry'
      if (n & pf) return 'SelectiveHydration'
      if (n & mf) return 'IdleHydration'
      if (n & Ws) return 'Idle'
      if (n & pi) return 'Offscreen'
    }
  }
  var vn = -1,
    yp = hf,
    bp = uu
  function vf(n) {
    switch (Ys(n)) {
      case ct:
        return ct
      case su:
        return su
      case ro:
        return ro
      case Hs:
        return Hs
      case wa:
        return wa
      case df:
        return df
      case hf:
      case a0:
      case o0:
      case s0:
      case l0:
      case u0:
      case c0:
      case f0:
      case d0:
      case h0:
      case p0:
      case m0:
      case v0:
      case g0:
      case y0:
      case b0:
        return n & lu
      case uu:
      case E0:
      case x0:
      case S0:
      case T0:
        return n & gp
      case pf:
        return pf
      case mf:
        return mf
      case Ws:
        return Ws
      case pi:
        return pi
      default:
        return l('Should have found matching lanes. This is a bug in React.'), n
    }
  }
  function Ep(n, i) {
    var s = n.pendingLanes
    if (s === fe) return fe
    var c = fe,
      f = n.suspendedLanes,
      m = n.pingedLanes,
      y = s & uT
    if (y !== fe) {
      var b = y & ~f
      if (b !== fe) c = vf(b)
      else {
        var S = y & m
        S !== fe && (c = vf(S))
      }
    } else {
      var O = s & ~f
      O !== fe ? (c = vf(O)) : m !== fe && (c = vf(m))
    }
    if (c === fe) return fe
    if (i !== fe && i !== c && (i & f) === fe) {
      var N = Ys(c),
        U = Ys(i)
      if (N >= U || (N === wa && (U & lu) !== fe)) return i
    }
    ;(c & ro) !== fe && (c |= s & wa)
    var j = n.entangledLanes
    if (j !== fe)
      for (var q = n.entanglements, Z = c & j; Z > 0; ) {
        var ee = qs(Z),
          Ae = 1 << ee
        ;(c |= q[ee]), (Z &= ~Ae)
      }
    return c
  }
  function lL(n, i) {
    for (var s = n.eventTimes, c = vn; i > 0; ) {
      var f = qs(i),
        m = 1 << f,
        y = s[f]
      y > c && (c = y), (i &= ~m)
    }
    return c
  }
  function uL(n, i) {
    switch (n) {
      case ct:
      case su:
      case ro:
        return i + 250
      case Hs:
      case wa:
      case df:
      case hf:
      case a0:
      case o0:
      case s0:
      case l0:
      case u0:
      case c0:
      case f0:
      case d0:
      case h0:
      case p0:
      case m0:
      case v0:
      case g0:
      case y0:
      case b0:
        return i + 5e3
      case uu:
      case E0:
      case x0:
      case S0:
      case T0:
        return vn
      case pf:
      case mf:
      case Ws:
      case pi:
        return vn
      default:
        return l('Should have found matching lanes. This is a bug in React.'), vn
    }
  }
  function cL(n, i) {
    for (
      var s = n.pendingLanes, c = n.suspendedLanes, f = n.pingedLanes, m = n.expirationTimes, y = s;
      y > 0;

    ) {
      var b = qs(y),
        S = 1 << b,
        O = m[b]
      O === vn
        ? ((S & c) === fe || (S & f) !== fe) && (m[b] = uL(S, i))
        : O <= i && (n.expiredLanes |= S),
        (y &= ~S)
    }
  }
  function fL(n) {
    return vf(n.pendingLanes)
  }
  function C0(n) {
    var i = n.pendingLanes & ~pi
    return i !== fe ? i : i & pi ? pi : fe
  }
  function dL(n) {
    return (n & ct) !== fe
  }
  function w0(n) {
    return (n & uT) !== fe
  }
  function cT(n) {
    return (n & gp) === n
  }
  function hL(n) {
    var i = ct | ro | wa
    return (n & i) === fe
  }
  function pL(n) {
    return (n & lu) === n
  }
  function xp(n, i) {
    var s = su | ro | Hs | wa
    return (i & s) !== fe
  }
  function mL(n, i) {
    return (i & n.expiredLanes) !== fe
  }
  function fT(n) {
    return (n & lu) !== fe
  }
  function dT() {
    var n = yp
    return (yp <<= 1), (yp & lu) === fe && (yp = hf), n
  }
  function vL() {
    var n = bp
    return (bp <<= 1), (bp & gp) === fe && (bp = uu), n
  }
  function Ys(n) {
    return n & -n
  }
  function gf(n) {
    return Ys(n)
  }
  function qs(n) {
    return 31 - sT(n)
  }
  function R0(n) {
    return qs(n)
  }
  function mi(n, i) {
    return (n & i) !== fe
  }
  function cu(n, i) {
    return (n & i) === i
  }
  function Tt(n, i) {
    return n | i
  }
  function Sp(n, i) {
    return n & ~i
  }
  function hT(n, i) {
    return n & i
  }
  function cZ(n) {
    return n
  }
  function gL(n, i) {
    return n !== lr && n < i ? n : i
  }
  function _0(n) {
    for (var i = [], s = 0; s < i0; s++) i.push(n)
    return i
  }
  function yf(n, i, s) {
    ;(n.pendingLanes |= i), i !== Ws && ((n.suspendedLanes = fe), (n.pingedLanes = fe))
    var c = n.eventTimes,
      f = R0(i)
    c[f] = s
  }
  function yL(n, i) {
    ;(n.suspendedLanes |= i), (n.pingedLanes &= ~i)
    for (var s = n.expirationTimes, c = i; c > 0; ) {
      var f = qs(c),
        m = 1 << f
      ;(s[f] = vn), (c &= ~m)
    }
  }
  function pT(n, i, s) {
    n.pingedLanes |= n.suspendedLanes & i
  }
  function bL(n, i) {
    var s = n.pendingLanes & ~i
    ;(n.pendingLanes = i),
      (n.suspendedLanes = fe),
      (n.pingedLanes = fe),
      (n.expiredLanes &= i),
      (n.mutableReadLanes &= i),
      (n.entangledLanes &= i)
    for (var c = n.entanglements, f = n.eventTimes, m = n.expirationTimes, y = s; y > 0; ) {
      var b = qs(y),
        S = 1 << b
      ;(c[b] = fe), (f[b] = vn), (m[b] = vn), (y &= ~S)
    }
  }
  function O0(n, i) {
    for (var s = (n.entangledLanes |= i), c = n.entanglements, f = s; f; ) {
      var m = qs(f),
        y = 1 << m
      ;(y & i) | (c[m] & i) && (c[m] |= i), (f &= ~y)
    }
  }
  function EL(n, i) {
    var s = Ys(i),
      c
    switch (s) {
      case ro:
        c = su
        break
      case wa:
        c = Hs
        break
      case hf:
      case a0:
      case o0:
      case s0:
      case l0:
      case u0:
      case c0:
      case f0:
      case d0:
      case h0:
      case p0:
      case m0:
      case v0:
      case g0:
      case y0:
      case b0:
      case uu:
      case E0:
      case x0:
      case S0:
      case T0:
        c = df
        break
      case Ws:
        c = mf
        break
      default:
        c = lr
        break
    }
    return (c & (n.suspendedLanes | i)) !== lr ? lr : c
  }
  function mT(n, i, s) {
    if (Zi)
      for (var c = n.pendingUpdatersLaneMap; s > 0; ) {
        var f = R0(s),
          m = 1 << f,
          y = c[f]
        y.add(i), (s &= ~m)
      }
  }
  function vT(n, i) {
    if (Zi)
      for (var s = n.pendingUpdatersLaneMap, c = n.memoizedUpdaters; i > 0; ) {
        var f = R0(i),
          m = 1 << f,
          y = s[f]
        y.size > 0 &&
          (y.forEach(function (b) {
            var S = b.alternate
            ;(S === null || !c.has(S)) && c.add(b)
          }),
          y.clear()),
          (i &= ~m)
      }
  }
  function gT(n, i) {
    return null
  }
  var vi = ct,
    io = ro,
    ao = wa,
    Tp = Ws,
    bf = lr
  function Xi() {
    return bf
  }
  function ur(n) {
    bf = n
  }
  function xL(n, i) {
    var s = bf
    try {
      return (bf = n), i()
    } finally {
      bf = s
    }
  }
  function SL(n, i) {
    return n !== 0 && n < i ? n : i
  }
  function TL(n, i) {
    return n > i ? n : i
  }
  function k0(n, i) {
    return n !== 0 && n < i
  }
  function yT(n) {
    var i = Ys(n)
    return k0(vi, i) ? (k0(io, i) ? (w0(i) ? ao : Tp) : io) : vi
  }
  function Cp(n) {
    var i = n.current.memoizedState
    return i.isDehydrated
  }
  var bT
  function CL(n) {
    bT = n
  }
  function wL(n) {
    bT(n)
  }
  var A0
  function RL(n) {
    A0 = n
  }
  var ET
  function _L(n) {
    ET = n
  }
  var xT
  function OL(n) {
    xT = n
  }
  var ST
  function kL(n) {
    ST = n
  }
  var D0 = !1,
    wp = [],
    Bo = null,
    zo = null,
    Ho = null,
    Ef = new Map(),
    xf = new Map(),
    Wo = [],
    AL = [
      'mousedown',
      'mouseup',
      'touchcancel',
      'touchend',
      'touchstart',
      'auxclick',
      'dblclick',
      'pointercancel',
      'pointerdown',
      'pointerup',
      'dragend',
      'dragstart',
      'drop',
      'compositionend',
      'compositionstart',
      'keydown',
      'keypress',
      'keyup',
      'input',
      'textInput',
      'copy',
      'cut',
      'paste',
      'click',
      'change',
      'contextmenu',
      'reset',
      'submit'
    ]
  function DL(n) {
    return AL.indexOf(n) > -1
  }
  function NL(n, i, s, c, f) {
    return { blockedOn: n, domEventName: i, eventSystemFlags: s, nativeEvent: f, targetContainers: [c] }
  }
  function TT(n, i) {
    switch (n) {
      case 'focusin':
      case 'focusout':
        Bo = null
        break
      case 'dragenter':
      case 'dragleave':
        zo = null
        break
      case 'mouseover':
      case 'mouseout':
        Ho = null
        break
      case 'pointerover':
      case 'pointerout': {
        var s = i.pointerId
        Ef.delete(s)
        break
      }
      case 'gotpointercapture':
      case 'lostpointercapture': {
        var c = i.pointerId
        xf.delete(c)
        break
      }
    }
  }
  function Sf(n, i, s, c, f, m) {
    if (n === null || n.nativeEvent !== m) {
      var y = NL(i, s, c, f, m)
      if (i !== null) {
        var b = Go(i)
        b !== null && A0(b)
      }
      return y
    }
    n.eventSystemFlags |= c
    var S = n.targetContainers
    return f !== null && S.indexOf(f) === -1 && S.push(f), n
  }
  function ML(n, i, s, c, f) {
    switch (i) {
      case 'focusin': {
        var m = f
        return (Bo = Sf(Bo, n, i, s, c, m)), !0
      }
      case 'dragenter': {
        var y = f
        return (zo = Sf(zo, n, i, s, c, y)), !0
      }
      case 'mouseover': {
        var b = f
        return (Ho = Sf(Ho, n, i, s, c, b)), !0
      }
      case 'pointerover': {
        var S = f,
          O = S.pointerId
        return Ef.set(O, Sf(Ef.get(O) || null, n, i, s, c, S)), !0
      }
      case 'gotpointercapture': {
        var N = f,
          U = N.pointerId
        return xf.set(U, Sf(xf.get(U) || null, n, i, s, c, N)), !0
      }
    }
    return !1
  }
  function CT(n) {
    var i = Zs(n.target)
    if (i !== null) {
      var s = Bs(i)
      if (s !== null) {
        var c = s.tag
        if (c === F) {
          var f = G1(s)
          if (f !== null) {
            ;(n.blockedOn = f),
              ST(n.priority, function () {
                ET(s)
              })
            return
          }
        } else if (c === g) {
          var m = s.stateNode
          if (Cp(m)) {
            n.blockedOn = K1(s)
            return
          }
        }
      }
    }
    n.blockedOn = null
  }
  function LL(n) {
    for (
      var i = xT(), s = { blockedOn: null, target: n, priority: i }, c = 0;
      c < Wo.length && k0(i, Wo[c].priority);
      c++
    );
    Wo.splice(c, 0, s), c === 0 && CT(s)
  }
  function Rp(n) {
    if (n.blockedOn !== null) return !1
    for (var i = n.targetContainers; i.length > 0; ) {
      var s = i[0],
        c = L0(n.domEventName, n.eventSystemFlags, s, n.nativeEvent)
      if (c === null) {
        var f = n.nativeEvent,
          m = new f.constructor(f.type, f)
        o3(m), f.target.dispatchEvent(m), s3()
      } else {
        var y = Go(c)
        return y !== null && A0(y), (n.blockedOn = c), !1
      }
      i.shift()
    }
    return !0
  }
  function wT(n, i, s) {
    Rp(n) && s.delete(i)
  }
  function PL() {
    ;(D0 = !1),
      Bo !== null && Rp(Bo) && (Bo = null),
      zo !== null && Rp(zo) && (zo = null),
      Ho !== null && Rp(Ho) && (Ho = null),
      Ef.forEach(wT),
      xf.forEach(wT)
  }
  function Tf(n, i) {
    n.blockedOn === i &&
      ((n.blockedOn = null),
      D0 || ((D0 = !0), t.unstable_scheduleCallback(t.unstable_NormalPriority, PL)))
  }
  function Cf(n) {
    if (wp.length > 0) {
      Tf(wp[0], n)
      for (var i = 1; i < wp.length; i++) {
        var s = wp[i]
        s.blockedOn === n && (s.blockedOn = null)
      }
    }
    Bo !== null && Tf(Bo, n), zo !== null && Tf(zo, n), Ho !== null && Tf(Ho, n)
    var c = function (b) {
      return Tf(b, n)
    }
    Ef.forEach(c), xf.forEach(c)
    for (var f = 0; f < Wo.length; f++) {
      var m = Wo[f]
      m.blockedOn === n && (m.blockedOn = null)
    }
    for (; Wo.length > 0; ) {
      var y = Wo[0]
      if (y.blockedOn !== null) break
      CT(y), y.blockedOn === null && Wo.shift()
    }
  }
  var fu = r.ReactCurrentBatchConfig,
    N0 = !0
  function RT(n) {
    N0 = !!n
  }
  function IL() {
    return N0
  }
  function FL(n, i, s) {
    var c = _T(i),
      f
    switch (c) {
      case vi:
        f = VL
        break
      case io:
        f = jL
        break
      case ao:
      default:
        f = M0
        break
    }
    return f.bind(null, i, s, n)
  }
  function VL(n, i, s, c) {
    var f = Xi(),
      m = fu.transition
    fu.transition = null
    try {
      ur(vi), M0(n, i, s, c)
    } finally {
      ur(f), (fu.transition = m)
    }
  }
  function jL(n, i, s, c) {
    var f = Xi(),
      m = fu.transition
    fu.transition = null
    try {
      ur(io), M0(n, i, s, c)
    } finally {
      ur(f), (fu.transition = m)
    }
  }
  function M0(n, i, s, c) {
    N0 && UL(n, i, s, c)
  }
  function UL(n, i, s, c) {
    var f = L0(n, i, s, c)
    if (f === null) {
      G0(n, i, c, _p, s), TT(n, c)
      return
    }
    if (ML(f, n, i, s, c)) {
      c.stopPropagation()
      return
    }
    if ((TT(n, c), i & rf && DL(n))) {
      for (; f !== null; ) {
        var m = Go(f)
        m !== null && wL(m)
        var y = L0(n, i, s, c)
        if ((y === null && G0(n, i, c, _p, s), y === f)) break
        f = y
      }
      f !== null && c.stopPropagation()
      return
    }
    G0(n, i, c, null, s)
  }
  var _p = null
  function L0(n, i, s, c) {
    _p = null
    var f = $g(c),
      m = Zs(f)
    if (m !== null) {
      var y = Bs(m)
      if (y === null) m = null
      else {
        var b = y.tag
        if (b === F) {
          var S = G1(y)
          if (S !== null) return S
          m = null
        } else if (b === g) {
          var O = y.stateNode
          if (Cp(O)) return K1(y)
          m = null
        } else y !== m && (m = null)
      }
    }
    return (_p = m), null
  }
  function _T(n) {
    switch (n) {
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return vi
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'toggle':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return io
      case 'message': {
        var i = D3()
        switch (i) {
          case vp:
            return vi
          case t0:
            return io
          case zs:
          case N3:
            return ao
          case n0:
            return Tp
          default:
            return ao
        }
      }
      default:
        return ao
    }
  }
  function $L(n, i, s) {
    return n.addEventListener(i, s, !1), s
  }
  function BL(n, i, s) {
    return n.addEventListener(i, s, !0), s
  }
  function zL(n, i, s, c) {
    return n.addEventListener(i, s, { capture: !0, passive: c }), s
  }
  function HL(n, i, s, c) {
    return n.addEventListener(i, s, { passive: c }), s
  }
  var wf = null,
    P0 = null,
    Rf = null
  function WL(n) {
    return (wf = n), (P0 = kT()), !0
  }
  function YL() {
    ;(wf = null), (P0 = null), (Rf = null)
  }
  function OT() {
    if (Rf) return Rf
    var n,
      i = P0,
      s = i.length,
      c,
      f = kT(),
      m = f.length
    for (n = 0; n < s && i[n] === f[n]; n++);
    var y = s - n
    for (c = 1; c <= y && i[s - c] === f[m - c]; c++);
    var b = c > 1 ? 1 - c : void 0
    return (Rf = f.slice(n, b)), Rf
  }
  function kT() {
    return 'value' in wf ? wf.value : wf.textContent
  }
  function Op(n) {
    var i,
      s = n.keyCode
    return (
      'charCode' in n ? ((i = n.charCode), i === 0 && s === 13 && (i = 13)) : (i = s),
      i === 10 && (i = 13),
      i >= 32 || i === 13 ? i : 0
    )
  }
  function kp() {
    return !0
  }
  function AT() {
    return !1
  }
  function gi(n) {
    function i(s, c, f, m, y) {
      ;(this._reactName = s),
        (this._targetInst = f),
        (this.type = c),
        (this.nativeEvent = m),
        (this.target = y),
        (this.currentTarget = null)
      for (var b in n)
        if (n.hasOwnProperty(b)) {
          var S = n[b]
          S ? (this[b] = S(m)) : (this[b] = m[b])
        }
      var O = m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1
      return (
        O ? (this.isDefaultPrevented = kp) : (this.isDefaultPrevented = AT),
        (this.isPropagationStopped = AT),
        this
      )
    }
    return (
      vt(i.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var s = this.nativeEvent
          s &&
            (s.preventDefault
              ? s.preventDefault()
              : typeof s.returnValue != 'unknown' && (s.returnValue = !1),
            (this.isDefaultPrevented = kp))
        },
        stopPropagation: function () {
          var s = this.nativeEvent
          s &&
            (s.stopPropagation
              ? s.stopPropagation()
              : typeof s.cancelBubble != 'unknown' && (s.cancelBubble = !0),
            (this.isPropagationStopped = kp))
        },
        persist: function () {},
        isPersistent: kp
      }),
      i
    )
  }
  var du = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (n) {
        return n.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    I0 = gi(du),
    _f = vt({}, du, { view: 0, detail: 0 }),
    qL = gi(_f),
    F0,
    V0,
    Of
  function GL(n) {
    n !== Of &&
      (Of && n.type === 'mousemove'
        ? ((F0 = n.screenX - Of.screenX), (V0 = n.screenY - Of.screenY))
        : ((F0 = 0), (V0 = 0)),
      (Of = n))
  }
  var Ap = vt({}, _f, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: U0,
      button: 0,
      buttons: 0,
      relatedTarget: function (n) {
        return n.relatedTarget === void 0
          ? n.fromElement === n.srcElement
            ? n.toElement
            : n.fromElement
          : n.relatedTarget
      },
      movementX: function (n) {
        return 'movementX' in n ? n.movementX : (GL(n), F0)
      },
      movementY: function (n) {
        return 'movementY' in n ? n.movementY : V0
      }
    }),
    DT = gi(Ap),
    KL = vt({}, Ap, { dataTransfer: 0 }),
    ZL = gi(KL),
    XL = vt({}, _f, { relatedTarget: 0 }),
    j0 = gi(XL),
    QL = vt({}, du, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    JL = gi(QL),
    e4 = vt({}, du, {
      clipboardData: function (n) {
        return 'clipboardData' in n ? n.clipboardData : window.clipboardData
      }
    }),
    t4 = gi(e4),
    n4 = vt({}, du, { data: 0 }),
    NT = gi(n4),
    r4 = NT,
    i4 = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified'
    },
    a4 = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta'
    }
  function o4(n) {
    if (n.key) {
      var i = i4[n.key] || n.key
      if (i !== 'Unidentified') return i
    }
    if (n.type === 'keypress') {
      var s = Op(n)
      return s === 13 ? 'Enter' : String.fromCharCode(s)
    }
    return n.type === 'keydown' || n.type === 'keyup' ? a4[n.keyCode] || 'Unidentified' : ''
  }
  var s4 = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
  function l4(n) {
    var i = this,
      s = i.nativeEvent
    if (s.getModifierState) return s.getModifierState(n)
    var c = s4[n]
    return c ? !!s[c] : !1
  }
  function U0(n) {
    return l4
  }
  var u4 = vt({}, _f, {
      key: o4,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: U0,
      charCode: function (n) {
        return n.type === 'keypress' ? Op(n) : 0
      },
      keyCode: function (n) {
        return n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0
      },
      which: function (n) {
        return n.type === 'keypress' ? Op(n) : n.type === 'keydown' || n.type === 'keyup' ? n.keyCode : 0
      }
    }),
    c4 = gi(u4),
    f4 = vt({}, Ap, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    MT = gi(f4),
    d4 = vt({}, _f, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: U0
    }),
    h4 = gi(d4),
    p4 = vt({}, du, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    m4 = gi(p4),
    v4 = vt({}, Ap, {
      deltaX: function (n) {
        return 'deltaX' in n ? n.deltaX : 'wheelDeltaX' in n ? -n.wheelDeltaX : 0
      },
      deltaY: function (n) {
        return 'deltaY' in n
          ? n.deltaY
          : 'wheelDeltaY' in n
            ? -n.wheelDeltaY
            : 'wheelDelta' in n
              ? -n.wheelDelta
              : 0
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    g4 = gi(v4),
    y4 = [9, 13, 27, 32],
    LT = 229,
    $0 = Re && 'CompositionEvent' in window,
    kf = null
  Re && 'documentMode' in document && (kf = document.documentMode)
  var b4 = Re && 'TextEvent' in window && !kf,
    PT = Re && (!$0 || (kf && kf > 8 && kf <= 11)),
    IT = 32,
    FT = String.fromCharCode(IT)
  function E4() {
    en('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
      en('onCompositionEnd', [
        'compositionend',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown'
      ]),
      en('onCompositionStart', [
        'compositionstart',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown'
      ]),
      en('onCompositionUpdate', [
        'compositionupdate',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown'
      ])
  }
  var VT = !1
  function x4(n) {
    return (n.ctrlKey || n.altKey || n.metaKey) && !(n.ctrlKey && n.altKey)
  }
  function S4(n) {
    switch (n) {
      case 'compositionstart':
        return 'onCompositionStart'
      case 'compositionend':
        return 'onCompositionEnd'
      case 'compositionupdate':
        return 'onCompositionUpdate'
    }
  }
  function T4(n, i) {
    return n === 'keydown' && i.keyCode === LT
  }
  function jT(n, i) {
    switch (n) {
      case 'keyup':
        return y4.indexOf(i.keyCode) !== -1
      case 'keydown':
        return i.keyCode !== LT
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function UT(n) {
    var i = n.detail
    return typeof i == 'object' && 'data' in i ? i.data : null
  }
  function $T(n) {
    return n.locale === 'ko'
  }
  var hu = !1
  function C4(n, i, s, c, f) {
    var m, y
    if (
      ($0
        ? (m = S4(i))
        : hu
          ? jT(i, c) && (m = 'onCompositionEnd')
          : T4(i, c) && (m = 'onCompositionStart'),
      !m)
    )
      return null
    PT &&
      !$T(c) &&
      (!hu && m === 'onCompositionStart' ? (hu = WL(f)) : m === 'onCompositionEnd' && hu && (y = OT()))
    var b = Pp(s, m)
    if (b.length > 0) {
      var S = new NT(m, i, null, c, f)
      if ((n.push({ event: S, listeners: b }), y)) S.data = y
      else {
        var O = UT(c)
        O !== null && (S.data = O)
      }
    }
  }
  function w4(n, i) {
    switch (n) {
      case 'compositionend':
        return UT(i)
      case 'keypress':
        var s = i.which
        return s !== IT ? null : ((VT = !0), FT)
      case 'textInput':
        var c = i.data
        return c === FT && VT ? null : c
      default:
        return null
    }
  }
  function R4(n, i) {
    if (hu) {
      if (n === 'compositionend' || (!$0 && jT(n, i))) {
        var s = OT()
        return YL(), (hu = !1), s
      }
      return null
    }
    switch (n) {
      case 'paste':
        return null
      case 'keypress':
        if (!x4(i)) {
          if (i.char && i.char.length > 1) return i.char
          if (i.which) return String.fromCharCode(i.which)
        }
        return null
      case 'compositionend':
        return PT && !$T(i) ? null : i.data
      default:
        return null
    }
  }
  function _4(n, i, s, c, f) {
    var m
    if ((b4 ? (m = w4(i, c)) : (m = R4(i, c)), !m)) return null
    var y = Pp(s, 'onBeforeInput')
    if (y.length > 0) {
      var b = new r4('onBeforeInput', 'beforeinput', null, c, f)
      n.push({ event: b, listeners: y }), (b.data = m)
    }
  }
  function O4(n, i, s, c, f, m, y) {
    C4(n, i, s, c, f), _4(n, i, s, c, f)
  }
  var k4 = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  }
  function BT(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase()
    return i === 'input' ? !!k4[n.type] : i === 'textarea'
  }
  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */ function A4(n) {
    if (!Re) return !1
    var i = 'on' + n,
      s = i in document
    if (!s) {
      var c = document.createElement('div')
      c.setAttribute(i, 'return;'), (s = typeof c[i] == 'function')
    }
    return s
  }
  function D4() {
    en('onChange', [
      'change',
      'click',
      'focusin',
      'focusout',
      'input',
      'keydown',
      'keyup',
      'selectionchange'
    ])
  }
  function zT(n, i, s, c) {
    U1(c)
    var f = Pp(i, 'onChange')
    if (f.length > 0) {
      var m = new I0('onChange', 'change', null, s, c)
      n.push({ event: m, listeners: f })
    }
  }
  var Af = null,
    Df = null
  function N4(n) {
    var i = n.nodeName && n.nodeName.toLowerCase()
    return i === 'select' || (i === 'input' && n.type === 'file')
  }
  function M4(n) {
    var i = []
    zT(i, Df, n, $g(n)), H1(L4, i)
  }
  function L4(n) {
    sC(n, 0)
  }
  function Dp(n) {
    var i = bu(n)
    if (Gl(i)) return n
  }
  function P4(n, i) {
    if (n === 'change') return i
  }
  var HT = !1
  Re && (HT = A4('input') && (!document.documentMode || document.documentMode > 9))
  function I4(n, i) {
    ;(Af = n), (Df = i), Af.attachEvent('onpropertychange', YT)
  }
  function WT() {
    Af && (Af.detachEvent('onpropertychange', YT), (Af = null), (Df = null))
  }
  function YT(n) {
    n.propertyName === 'value' && Dp(Df) && M4(n)
  }
  function F4(n, i, s) {
    n === 'focusin' ? (WT(), I4(i, s)) : n === 'focusout' && WT()
  }
  function V4(n, i) {
    if (n === 'selectionchange' || n === 'keyup' || n === 'keydown') return Dp(Df)
  }
  function j4(n) {
    var i = n.nodeName
    return i && i.toLowerCase() === 'input' && (n.type === 'checkbox' || n.type === 'radio')
  }
  function U4(n, i) {
    if (n === 'click') return Dp(i)
  }
  function $4(n, i) {
    if (n === 'input' || n === 'change') return Dp(i)
  }
  function B4(n) {
    var i = n._wrapperState
    !i || !i.controlled || n.type !== 'number' || ut(n, 'number', n.value)
  }
  function z4(n, i, s, c, f, m, y) {
    var b = s ? bu(s) : window,
      S,
      O
    if ((N4(b) ? (S = P4) : BT(b) ? (HT ? (S = $4) : ((S = V4), (O = F4))) : j4(b) && (S = U4), S)) {
      var N = S(i, s)
      if (N) {
        zT(n, N, c, f)
        return
      }
    }
    O && O(i, b, s), i === 'focusout' && B4(b)
  }
  function H4() {
    nn('onMouseEnter', ['mouseout', 'mouseover']),
      nn('onMouseLeave', ['mouseout', 'mouseover']),
      nn('onPointerEnter', ['pointerout', 'pointerover']),
      nn('onPointerLeave', ['pointerout', 'pointerover'])
  }
  function W4(n, i, s, c, f, m, y) {
    var b = i === 'mouseover' || i === 'pointerover',
      S = i === 'mouseout' || i === 'pointerout'
    if (b && !l3(c)) {
      var O = c.relatedTarget || c.fromElement
      if (O && (Zs(O) || Yf(O))) return
    }
    if (!(!S && !b)) {
      var N
      if (f.window === f) N = f
      else {
        var U = f.ownerDocument
        U ? (N = U.defaultView || U.parentWindow) : (N = window)
      }
      var j, q
      if (S) {
        var Z = c.relatedTarget || c.toElement
        if (((j = s), (q = Z ? Zs(Z) : null), q !== null)) {
          var ee = Bs(q)
          ;(q !== ee || (q.tag !== x && q.tag !== C)) && (q = null)
        }
      } else (j = null), (q = s)
      if (j !== q) {
        var Ae = DT,
          Ze = 'onMouseLeave',
          We = 'onMouseEnter',
          It = 'mouse'
        ;(i === 'pointerout' || i === 'pointerover') &&
          ((Ae = MT), (Ze = 'onPointerLeave'), (We = 'onPointerEnter'), (It = 'pointer'))
        var Ot = j == null ? N : bu(j),
          W = q == null ? N : bu(q),
          te = new Ae(Ze, It + 'leave', j, c, f)
        ;(te.target = Ot), (te.relatedTarget = W)
        var Y = null,
          me = Zs(f)
        if (me === s) {
          var Fe = new Ae(We, It + 'enter', q, c, f)
          ;(Fe.target = W), (Fe.relatedTarget = Ot), (Y = Fe)
        }
        m5(n, te, Y, j, q)
      }
    }
  }
  function Y4(n, i) {
    return (n === i && (n !== 0 || 1 / n === 1 / i)) || (n !== n && i !== i)
  }
  var yi = typeof Object.is == 'function' ? Object.is : Y4
  function Nf(n, i) {
    if (yi(n, i)) return !0
    if (typeof n != 'object' || n === null || typeof i != 'object' || i === null) return !1
    var s = Object.keys(n),
      c = Object.keys(i)
    if (s.length !== c.length) return !1
    for (var f = 0; f < s.length; f++) {
      var m = s[f]
      if (!Oe.call(i, m) || !yi(n[m], i[m])) return !1
    }
    return !0
  }
  function qT(n) {
    for (; n && n.firstChild; ) n = n.firstChild
    return n
  }
  function q4(n) {
    for (; n; ) {
      if (n.nextSibling) return n.nextSibling
      n = n.parentNode
    }
  }
  function GT(n, i) {
    for (var s = qT(n), c = 0, f = 0; s; ) {
      if (s.nodeType === Xa) {
        if (((f = c + s.textContent.length), c <= i && f >= i)) return { node: s, offset: i - c }
        c = f
      }
      s = qT(q4(s))
    }
  }
  function G4(n) {
    var i = n.ownerDocument,
      s = (i && i.defaultView) || window,
      c = s.getSelection && s.getSelection()
    if (!c || c.rangeCount === 0) return null
    var f = c.anchorNode,
      m = c.anchorOffset,
      y = c.focusNode,
      b = c.focusOffset
    try {
      f.nodeType, y.nodeType
    } catch {
      return null
    }
    return K4(n, f, m, y, b)
  }
  function K4(n, i, s, c, f) {
    var m = 0,
      y = -1,
      b = -1,
      S = 0,
      O = 0,
      N = n,
      U = null
    e: for (;;) {
      for (
        var j = null;
        N === i && (s === 0 || N.nodeType === Xa) && (y = m + s),
          N === c && (f === 0 || N.nodeType === Xa) && (b = m + f),
          N.nodeType === Xa && (m += N.nodeValue.length),
          (j = N.firstChild) !== null;

      )
        (U = N), (N = j)
      for (;;) {
        if (N === n) break e
        if (
          (U === i && ++S === s && (y = m),
          U === c && ++O === f && (b = m),
          (j = N.nextSibling) !== null)
        )
          break
        ;(N = U), (U = N.parentNode)
      }
      N = j
    }
    return y === -1 || b === -1 ? null : { start: y, end: b }
  }
  function Z4(n, i) {
    var s = n.ownerDocument || document,
      c = (s && s.defaultView) || window
    if (c.getSelection) {
      var f = c.getSelection(),
        m = n.textContent.length,
        y = Math.min(i.start, m),
        b = i.end === void 0 ? y : Math.min(i.end, m)
      if (!f.extend && y > b) {
        var S = b
        ;(b = y), (y = S)
      }
      var O = GT(n, y),
        N = GT(n, b)
      if (O && N) {
        if (
          f.rangeCount === 1 &&
          f.anchorNode === O.node &&
          f.anchorOffset === O.offset &&
          f.focusNode === N.node &&
          f.focusOffset === N.offset
        )
          return
        var U = s.createRange()
        U.setStart(O.node, O.offset),
          f.removeAllRanges(),
          y > b
            ? (f.addRange(U), f.extend(N.node, N.offset))
            : (U.setEnd(N.node, N.offset), f.addRange(U))
      }
    }
  }
  function KT(n) {
    return n && n.nodeType === Xa
  }
  function ZT(n, i) {
    return !n || !i
      ? !1
      : n === i
        ? !0
        : KT(n)
          ? !1
          : KT(i)
            ? ZT(n, i.parentNode)
            : 'contains' in n
              ? n.contains(i)
              : n.compareDocumentPosition
                ? !!(n.compareDocumentPosition(i) & 16)
                : !1
  }
  function X4(n) {
    return n && n.ownerDocument && ZT(n.ownerDocument.documentElement, n)
  }
  function Q4(n) {
    try {
      return typeof n.contentWindow.location.href == 'string'
    } catch {
      return !1
    }
  }
  function XT() {
    for (var n = window, i = jo(); i instanceof n.HTMLIFrameElement; ) {
      if (Q4(i)) n = i.contentWindow
      else return i
      i = jo(n.document)
    }
    return i
  }
  function B0(n) {
    var i = n && n.nodeName && n.nodeName.toLowerCase()
    return (
      i &&
      ((i === 'input' &&
        (n.type === 'text' ||
          n.type === 'search' ||
          n.type === 'tel' ||
          n.type === 'url' ||
          n.type === 'password')) ||
        i === 'textarea' ||
        n.contentEditable === 'true')
    )
  }
  function J4() {
    var n = XT()
    return { focusedElem: n, selectionRange: B0(n) ? t5(n) : null }
  }
  function e5(n) {
    var i = XT(),
      s = n.focusedElem,
      c = n.selectionRange
    if (i !== s && X4(s)) {
      c !== null && B0(s) && n5(s, c)
      for (var f = [], m = s; (m = m.parentNode); )
        m.nodeType === ni && f.push({ element: m, left: m.scrollLeft, top: m.scrollTop })
      typeof s.focus == 'function' && s.focus()
      for (var y = 0; y < f.length; y++) {
        var b = f[y]
        ;(b.element.scrollLeft = b.left), (b.element.scrollTop = b.top)
      }
    }
  }
  function t5(n) {
    var i
    return (
      'selectionStart' in n ? (i = { start: n.selectionStart, end: n.selectionEnd }) : (i = G4(n)),
      i || { start: 0, end: 0 }
    )
  }
  function n5(n, i) {
    var s = i.start,
      c = i.end
    c === void 0 && (c = s),
      'selectionStart' in n
        ? ((n.selectionStart = s), (n.selectionEnd = Math.min(c, n.value.length)))
        : Z4(n, i)
  }
  var r5 = Re && 'documentMode' in document && document.documentMode <= 11
  function i5() {
    en('onSelect', [
      'focusout',
      'contextmenu',
      'dragend',
      'focusin',
      'keydown',
      'keyup',
      'mousedown',
      'mouseup',
      'selectionchange'
    ])
  }
  var pu = null,
    z0 = null,
    Mf = null,
    H0 = !1
  function a5(n) {
    if ('selectionStart' in n && B0(n)) return { start: n.selectionStart, end: n.selectionEnd }
    var i = (n.ownerDocument && n.ownerDocument.defaultView) || window,
      s = i.getSelection()
    return {
      anchorNode: s.anchorNode,
      anchorOffset: s.anchorOffset,
      focusNode: s.focusNode,
      focusOffset: s.focusOffset
    }
  }
  function o5(n) {
    return n.window === n ? n.document : n.nodeType === Qa ? n : n.ownerDocument
  }
  function QT(n, i, s) {
    var c = o5(s)
    if (!(H0 || pu == null || pu !== jo(c))) {
      var f = a5(pu)
      if (!Mf || !Nf(Mf, f)) {
        Mf = f
        var m = Pp(z0, 'onSelect')
        if (m.length > 0) {
          var y = new I0('onSelect', 'select', null, i, s)
          n.push({ event: y, listeners: m }), (y.target = pu)
        }
      }
    }
  }
  function s5(n, i, s, c, f, m, y) {
    var b = s ? bu(s) : window
    switch (i) {
      case 'focusin':
        ;(BT(b) || b.contentEditable === 'true') && ((pu = b), (z0 = s), (Mf = null))
        break
      case 'focusout':
        ;(pu = null), (z0 = null), (Mf = null)
        break
      case 'mousedown':
        H0 = !0
        break
      case 'contextmenu':
      case 'mouseup':
      case 'dragend':
        ;(H0 = !1), QT(n, c, f)
        break
      case 'selectionchange':
        if (r5) break
      case 'keydown':
      case 'keyup':
        QT(n, c, f)
    }
  }
  function Np(n, i) {
    var s = {}
    return (
      (s[n.toLowerCase()] = i.toLowerCase()),
      (s['Webkit' + n] = 'webkit' + i),
      (s['Moz' + n] = 'moz' + i),
      s
    )
  }
  var mu = {
      animationend: Np('Animation', 'AnimationEnd'),
      animationiteration: Np('Animation', 'AnimationIteration'),
      animationstart: Np('Animation', 'AnimationStart'),
      transitionend: Np('Transition', 'TransitionEnd')
    },
    W0 = {},
    JT = {}
  Re &&
    ((JT = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete mu.animationend.animation,
      delete mu.animationiteration.animation,
      delete mu.animationstart.animation),
    'TransitionEvent' in window || delete mu.transitionend.transition)
  function Mp(n) {
    if (W0[n]) return W0[n]
    if (!mu[n]) return n
    var i = mu[n]
    for (var s in i) if (i.hasOwnProperty(s) && s in JT) return (W0[n] = i[s])
    return n
  }
  var eC = Mp('animationend'),
    tC = Mp('animationiteration'),
    nC = Mp('animationstart'),
    rC = Mp('transitionend'),
    iC = new Map(),
    aC = [
      'abort',
      'auxClick',
      'cancel',
      'canPlay',
      'canPlayThrough',
      'click',
      'close',
      'contextMenu',
      'copy',
      'cut',
      'drag',
      'dragEnd',
      'dragEnter',
      'dragExit',
      'dragLeave',
      'dragOver',
      'dragStart',
      'drop',
      'durationChange',
      'emptied',
      'encrypted',
      'ended',
      'error',
      'gotPointerCapture',
      'input',
      'invalid',
      'keyDown',
      'keyPress',
      'keyUp',
      'load',
      'loadedData',
      'loadedMetadata',
      'loadStart',
      'lostPointerCapture',
      'mouseDown',
      'mouseMove',
      'mouseOut',
      'mouseOver',
      'mouseUp',
      'paste',
      'pause',
      'play',
      'playing',
      'pointerCancel',
      'pointerDown',
      'pointerMove',
      'pointerOut',
      'pointerOver',
      'pointerUp',
      'progress',
      'rateChange',
      'reset',
      'resize',
      'seeked',
      'seeking',
      'stalled',
      'submit',
      'suspend',
      'timeUpdate',
      'touchCancel',
      'touchEnd',
      'touchStart',
      'volumeChange',
      'scroll',
      'toggle',
      'touchMove',
      'waiting',
      'wheel'
    ]
  function Yo(n, i) {
    iC.set(n, i), en(i, [n])
  }
  function l5() {
    for (var n = 0; n < aC.length; n++) {
      var i = aC[n],
        s = i.toLowerCase(),
        c = i[0].toUpperCase() + i.slice(1)
      Yo(s, 'on' + c)
    }
    Yo(eC, 'onAnimationEnd'),
      Yo(tC, 'onAnimationIteration'),
      Yo(nC, 'onAnimationStart'),
      Yo('dblclick', 'onDoubleClick'),
      Yo('focusin', 'onFocus'),
      Yo('focusout', 'onBlur'),
      Yo(rC, 'onTransitionEnd')
  }
  function u5(n, i, s, c, f, m, y) {
    var b = iC.get(i)
    if (b !== void 0) {
      var S = I0,
        O = i
      switch (i) {
        case 'keypress':
          if (Op(c) === 0) return
        case 'keydown':
        case 'keyup':
          S = c4
          break
        case 'focusin':
          ;(O = 'focus'), (S = j0)
          break
        case 'focusout':
          ;(O = 'blur'), (S = j0)
          break
        case 'beforeblur':
        case 'afterblur':
          S = j0
          break
        case 'click':
          if (c.button === 2) return
        case 'auxclick':
        case 'dblclick':
        case 'mousedown':
        case 'mousemove':
        case 'mouseup':
        case 'mouseout':
        case 'mouseover':
        case 'contextmenu':
          S = DT
          break
        case 'drag':
        case 'dragend':
        case 'dragenter':
        case 'dragexit':
        case 'dragleave':
        case 'dragover':
        case 'dragstart':
        case 'drop':
          S = ZL
          break
        case 'touchcancel':
        case 'touchend':
        case 'touchmove':
        case 'touchstart':
          S = h4
          break
        case eC:
        case tC:
        case nC:
          S = JL
          break
        case rC:
          S = m4
          break
        case 'scroll':
          S = qL
          break
        case 'wheel':
          S = g4
          break
        case 'copy':
        case 'cut':
        case 'paste':
          S = t4
          break
        case 'gotpointercapture':
        case 'lostpointercapture':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'pointerup':
          S = MT
          break
      }
      var N = (m & rf) !== 0
      {
        var U = !N && i === 'scroll',
          j = h5(s, b, c.type, N, U)
        if (j.length > 0) {
          var q = new S(b, O, null, c, f)
          n.push({ event: q, listeners: j })
        }
      }
    }
  }
  l5(), H4(), D4(), i5(), E4()
  function c5(n, i, s, c, f, m, y) {
    u5(n, i, s, c, f, m)
    var b = (m & a3) === 0
    b && (W4(n, i, s, c, f), z4(n, i, s, c, f), s5(n, i, s, c, f), O4(n, i, s, c, f))
  }
  var Lf = [
      'abort',
      'canplay',
      'canplaythrough',
      'durationchange',
      'emptied',
      'encrypted',
      'ended',
      'error',
      'loadeddata',
      'loadedmetadata',
      'loadstart',
      'pause',
      'play',
      'playing',
      'progress',
      'ratechange',
      'resize',
      'seeked',
      'seeking',
      'stalled',
      'suspend',
      'timeupdate',
      'volumechange',
      'waiting'
    ],
    Y0 = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(Lf))
  function oC(n, i, s) {
    var c = n.type || 'unknown-event'
    ;(n.currentTarget = s), g3(c, i, void 0, n), (n.currentTarget = null)
  }
  function f5(n, i, s) {
    var c
    if (s)
      for (var f = i.length - 1; f >= 0; f--) {
        var m = i[f],
          y = m.instance,
          b = m.currentTarget,
          S = m.listener
        if (y !== c && n.isPropagationStopped()) return
        oC(n, S, b), (c = y)
      }
    else
      for (var O = 0; O < i.length; O++) {
        var N = i[O],
          U = N.instance,
          j = N.currentTarget,
          q = N.listener
        if (U !== c && n.isPropagationStopped()) return
        oC(n, q, j), (c = U)
      }
  }
  function sC(n, i) {
    for (var s = (i & rf) !== 0, c = 0; c < n.length; c++) {
      var f = n[c],
        m = f.event,
        y = f.listeners
      f5(m, y, s)
    }
    y3()
  }
  function d5(n, i, s, c, f) {
    var m = $g(s),
      y = []
    c5(y, n, c, s, m, i), sC(y, i)
  }
  function En(n, i) {
    Y0.has(n) ||
      l(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        n
      )
    var s = !1,
      c = BP(i),
      f = v5(n)
    c.has(f) || (lC(i, n, Ug, s), c.add(f))
  }
  function q0(n, i, s) {
    Y0.has(n) &&
      !i &&
      l(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        n
      )
    var c = 0
    i && (c |= rf), lC(s, n, c, i)
  }
  var Lp = '_reactListening' + Math.random().toString(36).slice(2)
  function Pf(n) {
    if (!n[Lp]) {
      ;(n[Lp] = !0),
        Et.forEach(function (s) {
          s !== 'selectionchange' && (Y0.has(s) || q0(s, !1, n), q0(s, !0, n))
        })
      var i = n.nodeType === Qa ? n : n.ownerDocument
      i !== null && (i[Lp] || ((i[Lp] = !0), q0('selectionchange', !1, i)))
    }
  }
  function lC(n, i, s, c, f) {
    var m = FL(n, i, s),
      y = void 0
    Hg && (i === 'touchstart' || i === 'touchmove' || i === 'wheel') && (y = !0),
      (n = n),
      c ? (y !== void 0 ? zL(n, i, m, y) : BL(n, i, m)) : y !== void 0 ? HL(n, i, m, y) : $L(n, i, m)
  }
  function uC(n, i) {
    return n === i || (n.nodeType === Bn && n.parentNode === i)
  }
  function G0(n, i, s, c, f) {
    var m = c
    if (!(i & V1) && !(i & Ug)) {
      var y = f
      if (c !== null) {
        var b = c
        e: for (;;) {
          if (b === null) return
          var S = b.tag
          if (S === g || S === E) {
            var O = b.stateNode.containerInfo
            if (uC(O, y)) break
            if (S === E)
              for (var N = b.return; N !== null; ) {
                var U = N.tag
                if (U === g || U === E) {
                  var j = N.stateNode.containerInfo
                  if (uC(j, y)) return
                }
                N = N.return
              }
            for (; O !== null; ) {
              var q = Zs(O)
              if (q === null) return
              var Z = q.tag
              if (Z === x || Z === C) {
                b = m = q
                continue e
              }
              O = O.parentNode
            }
          }
          b = b.return
        }
      }
    }
    H1(function () {
      return d5(n, i, s, m)
    })
  }
  function If(n, i, s) {
    return { instance: n, listener: i, currentTarget: s }
  }
  function h5(n, i, s, c, f, m) {
    for (
      var y = i !== null ? i + 'Capture' : null, b = c ? y : i, S = [], O = n, N = null;
      O !== null;

    ) {
      var U = O,
        j = U.stateNode,
        q = U.tag
      if (q === x && j !== null && ((N = j), b !== null)) {
        var Z = of(O, b)
        Z != null && S.push(If(O, Z, N))
      }
      if (f) break
      O = O.return
    }
    return S
  }
  function Pp(n, i) {
    for (var s = i + 'Capture', c = [], f = n; f !== null; ) {
      var m = f,
        y = m.stateNode,
        b = m.tag
      if (b === x && y !== null) {
        var S = y,
          O = of(f, s)
        O != null && c.unshift(If(f, O, S))
        var N = of(f, i)
        N != null && c.push(If(f, N, S))
      }
      f = f.return
    }
    return c
  }
  function vu(n) {
    if (n === null) return null
    do n = n.return
    while (n && n.tag !== x)
    return n || null
  }
  function p5(n, i) {
    for (var s = n, c = i, f = 0, m = s; m; m = vu(m)) f++
    for (var y = 0, b = c; b; b = vu(b)) y++
    for (; f - y > 0; ) (s = vu(s)), f--
    for (; y - f > 0; ) (c = vu(c)), y--
    for (var S = f; S--; ) {
      if (s === c || (c !== null && s === c.alternate)) return s
      ;(s = vu(s)), (c = vu(c))
    }
    return null
  }
  function cC(n, i, s, c, f) {
    for (var m = i._reactName, y = [], b = s; b !== null && b !== c; ) {
      var S = b,
        O = S.alternate,
        N = S.stateNode,
        U = S.tag
      if (O !== null && O === c) break
      if (U === x && N !== null) {
        var j = N
        if (f) {
          var q = of(b, m)
          q != null && y.unshift(If(b, q, j))
        } else if (!f) {
          var Z = of(b, m)
          Z != null && y.push(If(b, Z, j))
        }
      }
      b = b.return
    }
    y.length !== 0 && n.push({ event: i, listeners: y })
  }
  function m5(n, i, s, c, f) {
    var m = c && f ? p5(c, f) : null
    c !== null && cC(n, i, c, m, !1), f !== null && s !== null && cC(n, s, f, m, !0)
  }
  function v5(n, i) {
    return n + '__bubble'
  }
  var ri = !1,
    Ff = 'dangerouslySetInnerHTML',
    Ip = 'suppressContentEditableWarning',
    qo = 'suppressHydrationWarning',
    fC = 'autoFocus',
    Gs = 'children',
    Ks = 'style',
    Fp = '__html',
    K0,
    Vp,
    Vf,
    dC,
    jp,
    hC,
    pC
  ;(K0 = { dialog: !0, webview: !0 }),
    (Vp = function (n, i) {
      QM(n, i), JM(n, i), i3(n, i, { registrationNameDependencies: st, possibleRegistrationNames: At })
    }),
    (hC = Re && !document.documentMode),
    (Vf = function (n, i, s) {
      if (!ri) {
        var c = Up(s),
          f = Up(i)
        f !== c &&
          ((ri = !0),
          l('Prop `%s` did not match. Server: %s Client: %s', n, JSON.stringify(f), JSON.stringify(c)))
      }
    }),
    (dC = function (n) {
      if (!ri) {
        ri = !0
        var i = []
        n.forEach(function (s) {
          i.push(s)
        }),
          l('Extra attributes from the server: %s', i)
      }
    }),
    (jp = function (n, i) {
      i === !1
        ? l(
            'Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
            n,
            n,
            n
          )
        : l('Expected `%s` listener to be a function, instead got a value of `%s` type.', n, typeof i)
    }),
    (pC = function (n, i) {
      var s =
        n.namespaceURI === Za
          ? n.ownerDocument.createElement(n.tagName)
          : n.ownerDocument.createElementNS(n.namespaceURI, n.tagName)
      return (s.innerHTML = i), s.innerHTML
    })
  var g5 = /\r\n?/g,
    y5 = /\u0000|\uFFFD/g
  function Up(n) {
    Un(n)
    var i = typeof n == 'string' ? n : '' + n
    return i
      .replace(
        g5,
        `
`
      )
      .replace(y5, '')
  }
  function $p(n, i, s, c) {
    var f = Up(i),
      m = Up(n)
    if (
      m !== f &&
      (c && (ri || ((ri = !0), l('Text content did not match. Server: "%s" Client: "%s"', m, f))),
      s && de)
    )
      throw new Error('Text content does not match server-rendered HTML.')
  }
  function mC(n) {
    return n.nodeType === Qa ? n : n.ownerDocument
  }
  function b5() {}
  function Bp(n) {
    n.onclick = b5
  }
  function E5(n, i, s, c, f) {
    for (var m in c)
      if (c.hasOwnProperty(m)) {
        var y = c[m]
        if (m === Ks) y && Object.freeze(y), N1(i, y)
        else if (m === Ff) {
          var b = y ? y[Fp] : void 0
          b != null && _1(i, b)
        } else if (m === Gs)
          if (typeof y == 'string') {
            var S = n !== 'textarea' || y !== ''
            S && cp(i, y)
          } else typeof y == 'number' && cp(i, '' + y)
        else
          m === Ip ||
            m === qo ||
            m === fC ||
            (st.hasOwnProperty(m)
              ? y != null && (typeof y != 'function' && jp(m, y), m === 'onScroll' && En('scroll', i))
              : y != null && ei(i, m, y, f))
      }
  }
  function x5(n, i, s, c) {
    for (var f = 0; f < i.length; f += 2) {
      var m = i[f],
        y = i[f + 1]
      m === Ks ? N1(n, y) : m === Ff ? _1(n, y) : m === Gs ? cp(n, y) : ei(n, m, y, c)
    }
  }
  function S5(n, i, s, c) {
    var f,
      m = mC(s),
      y,
      b = c
    if ((b === Za && (b = Lg(n)), b === Za)) {
      if (
        ((f = Fs(n, i)),
        !f &&
          n !== n.toLowerCase() &&
          l(
            '<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
            n
          ),
        n === 'script')
      ) {
        var S = m.createElement('div')
        S.innerHTML = '<script></script>'
        var O = S.firstChild
        y = S.removeChild(O)
      } else if (typeof i.is == 'string') y = m.createElement(n, { is: i.is })
      else if (((y = m.createElement(n)), n === 'select')) {
        var N = y
        i.multiple ? (N.multiple = !0) : i.size && (N.size = i.size)
      }
    } else y = m.createElementNS(b, n)
    return (
      b === Za &&
        !f &&
        Object.prototype.toString.call(y) === '[object HTMLUnknownElement]' &&
        !Oe.call(K0, n) &&
        ((K0[n] = !0),
        l(
          'The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.',
          n
        )),
      y
    )
  }
  function T5(n, i) {
    return mC(i).createTextNode(n)
  }
  function C5(n, i, s, c) {
    var f = Fs(i, s)
    Vp(i, s)
    var m
    switch (i) {
      case 'dialog':
        En('cancel', n), En('close', n), (m = s)
        break
      case 'iframe':
      case 'object':
      case 'embed':
        En('load', n), (m = s)
        break
      case 'video':
      case 'audio':
        for (var y = 0; y < Lf.length; y++) En(Lf[y], n)
        m = s
        break
      case 'source':
        En('error', n), (m = s)
        break
      case 'img':
      case 'image':
      case 'link':
        En('error', n), En('load', n), (m = s)
        break
      case 'details':
        En('toggle', n), (m = s)
        break
      case 'input':
        I(n, s), (m = T(n, s)), En('invalid', n)
        break
      case 'option':
        hn(n, s), (m = s)
        break
      case 'select':
        tf(n, s), (m = ef(n, s)), En('invalid', n)
        break
      case 'textarea':
        C1(n, s), (m = Ng(n, s)), En('invalid', n)
        break
      default:
        m = s
    }
    switch ((jg(i, m), E5(i, n, c, m, f), i)) {
      case 'input':
        Ga(n), xe(n, s, !1)
        break
      case 'textarea':
        Ga(n), R1(n)
        break
      case 'option':
        bn(n, s)
        break
      case 'select':
        Dg(n, s)
        break
      default:
        typeof m.onClick == 'function' && Bp(n)
        break
    }
  }
  function w5(n, i, s, c, f) {
    Vp(i, c)
    var m = null,
      y,
      b
    switch (i) {
      case 'input':
        ;(y = T(n, s)), (b = T(n, c)), (m = [])
        break
      case 'select':
        ;(y = ef(n, s)), (b = ef(n, c)), (m = [])
        break
      case 'textarea':
        ;(y = Ng(n, s)), (b = Ng(n, c)), (m = [])
        break
      default:
        ;(y = s), (b = c), typeof y.onClick != 'function' && typeof b.onClick == 'function' && Bp(n)
        break
    }
    jg(i, b)
    var S,
      O,
      N = null
    for (S in y)
      if (!(b.hasOwnProperty(S) || !y.hasOwnProperty(S) || y[S] == null))
        if (S === Ks) {
          var U = y[S]
          for (O in U) U.hasOwnProperty(O) && (N || (N = {}), (N[O] = ''))
        } else
          S === Ff ||
            S === Gs ||
            S === Ip ||
            S === qo ||
            S === fC ||
            (st.hasOwnProperty(S) ? m || (m = []) : (m = m || []).push(S, null))
    for (S in b) {
      var j = b[S],
        q = y != null ? y[S] : void 0
      if (!(!b.hasOwnProperty(S) || j === q || (j == null && q == null)))
        if (S === Ks)
          if ((j && Object.freeze(j), q)) {
            for (O in q)
              q.hasOwnProperty(O) && (!j || !j.hasOwnProperty(O)) && (N || (N = {}), (N[O] = ''))
            for (O in j) j.hasOwnProperty(O) && q[O] !== j[O] && (N || (N = {}), (N[O] = j[O]))
          } else N || (m || (m = []), m.push(S, N)), (N = j)
        else if (S === Ff) {
          var Z = j ? j[Fp] : void 0,
            ee = q ? q[Fp] : void 0
          Z != null && ee !== Z && (m = m || []).push(S, Z)
        } else
          S === Gs
            ? (typeof j == 'string' || typeof j == 'number') && (m = m || []).push(S, '' + j)
            : S === Ip ||
              S === qo ||
              (st.hasOwnProperty(S)
                ? (j != null &&
                    (typeof j != 'function' && jp(S, j), S === 'onScroll' && En('scroll', n)),
                  !m && q !== j && (m = []))
                : (m = m || []).push(S, j))
    }
    return N && (HM(N, b[Ks]), (m = m || []).push(Ks, N)), m
  }
  function R5(n, i, s, c, f) {
    s === 'input' && f.type === 'radio' && f.name != null && K(n, f)
    var m = Fs(s, c),
      y = Fs(s, f)
    switch ((x5(n, i, m, y), s)) {
      case 'input':
        J(n, f)
        break
      case 'textarea':
        w1(n, f)
        break
      case 'select':
        xM(n, f)
        break
    }
  }
  function _5(n) {
    {
      var i = n.toLowerCase()
      return (fp.hasOwnProperty(i) && fp[i]) || null
    }
  }
  function O5(n, i, s, c, f, m, y) {
    var b, S
    switch (((b = Fs(i, s)), Vp(i, s), i)) {
      case 'dialog':
        En('cancel', n), En('close', n)
        break
      case 'iframe':
      case 'object':
      case 'embed':
        En('load', n)
        break
      case 'video':
      case 'audio':
        for (var O = 0; O < Lf.length; O++) En(Lf[O], n)
        break
      case 'source':
        En('error', n)
        break
      case 'img':
      case 'image':
      case 'link':
        En('error', n), En('load', n)
        break
      case 'details':
        En('toggle', n)
        break
      case 'input':
        I(n, s), En('invalid', n)
        break
      case 'option':
        hn(n, s)
        break
      case 'select':
        tf(n, s), En('invalid', n)
        break
      case 'textarea':
        C1(n, s), En('invalid', n)
        break
    }
    jg(i, s)
    {
      S = new Set()
      for (var N = n.attributes, U = 0; U < N.length; U++) {
        var j = N[U].name.toLowerCase()
        switch (j) {
          case 'value':
            break
          case 'checked':
            break
          case 'selected':
            break
          default:
            S.add(N[U].name)
        }
      }
    }
    var q = null
    for (var Z in s)
      if (s.hasOwnProperty(Z)) {
        var ee = s[Z]
        if (Z === Gs)
          typeof ee == 'string'
            ? n.textContent !== ee && (s[qo] !== !0 && $p(n.textContent, ee, m, y), (q = [Gs, ee]))
            : typeof ee == 'number' &&
              n.textContent !== '' + ee &&
              (s[qo] !== !0 && $p(n.textContent, ee, m, y), (q = [Gs, '' + ee]))
        else if (st.hasOwnProperty(Z))
          ee != null && (typeof ee != 'function' && jp(Z, ee), Z === 'onScroll' && En('scroll', n))
        else if (y && typeof b == 'boolean') {
          var Ae = void 0,
            Ze = b && pe ? null : rr(Z)
          if (s[qo] !== !0) {
            if (!(Z === Ip || Z === qo || Z === 'value' || Z === 'checked' || Z === 'selected')) {
              if (Z === Ff) {
                var We = n.innerHTML,
                  It = ee ? ee[Fp] : void 0
                if (It != null) {
                  var Ot = pC(n, It)
                  Ot !== We && Vf(Z, We, Ot)
                }
              } else if (Z === Ks) {
                if ((S.delete(Z), hC)) {
                  var W = BM(ee)
                  ;(Ae = n.getAttribute('style')), W !== Ae && Vf(Z, Ae, W)
                }
              } else if (b && !pe)
                S.delete(Z.toLowerCase()), (Ae = di(n, Z, ee)), ee !== Ae && Vf(Z, Ae, ee)
              else if (!fn(Z, Ze, b) && !Nt(Z, ee, Ze, b)) {
                var te = !1
                if (Ze !== null) S.delete(Ze.attributeName), (Ae = Jr(n, Z, ee, Ze))
                else {
                  var Y = c
                  if ((Y === Za && (Y = Lg(i)), Y === Za)) S.delete(Z.toLowerCase())
                  else {
                    var me = _5(Z)
                    me !== null && me !== Z && ((te = !0), S.delete(me)), S.delete(Z)
                  }
                  Ae = di(n, Z, ee)
                }
                var Fe = pe
                !Fe && ee !== Ae && !te && Vf(Z, Ae, ee)
              }
            }
          }
        }
      }
    switch ((y && S.size > 0 && s[qo] !== !0 && dC(S), i)) {
      case 'input':
        Ga(n), xe(n, s, !0)
        break
      case 'textarea':
        Ga(n), R1(n)
        break
      case 'select':
      case 'option':
        break
      default:
        typeof s.onClick == 'function' && Bp(n)
        break
    }
    return q
  }
  function k5(n, i, s) {
    var c = n.nodeValue !== i
    return c
  }
  function Z0(n, i) {
    {
      if (ri) return
      ;(ri = !0),
        l(
          'Did not expect server HTML to contain a <%s> in <%s>.',
          i.nodeName.toLowerCase(),
          n.nodeName.toLowerCase()
        )
    }
  }
  function X0(n, i) {
    {
      if (ri) return
      ;(ri = !0),
        l(
          'Did not expect server HTML to contain the text node "%s" in <%s>.',
          i.nodeValue,
          n.nodeName.toLowerCase()
        )
    }
  }
  function Q0(n, i, s) {
    {
      if (ri) return
      ;(ri = !0),
        l('Expected server HTML to contain a matching <%s> in <%s>.', i, n.nodeName.toLowerCase())
    }
  }
  function J0(n, i) {
    {
      if (i === '' || ri) return
      ;(ri = !0),
        l(
          'Expected server HTML to contain a matching text node for "%s" in <%s>.',
          i,
          n.nodeName.toLowerCase()
        )
    }
  }
  function A5(n, i, s) {
    switch (i) {
      case 'input':
        tt(n, s)
        return
      case 'textarea':
        TM(n, s)
        return
      case 'select':
        SM(n, s)
        return
    }
  }
  var jf = function () {},
    Uf = function () {}
  {
    var D5 = [
        'address',
        'applet',
        'area',
        'article',
        'aside',
        'base',
        'basefont',
        'bgsound',
        'blockquote',
        'body',
        'br',
        'button',
        'caption',
        'center',
        'col',
        'colgroup',
        'dd',
        'details',
        'dir',
        'div',
        'dl',
        'dt',
        'embed',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'frame',
        'frameset',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'iframe',
        'img',
        'input',
        'isindex',
        'li',
        'link',
        'listing',
        'main',
        'marquee',
        'menu',
        'menuitem',
        'meta',
        'nav',
        'noembed',
        'noframes',
        'noscript',
        'object',
        'ol',
        'p',
        'param',
        'plaintext',
        'pre',
        'script',
        'section',
        'select',
        'source',
        'style',
        'summary',
        'table',
        'tbody',
        'td',
        'template',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'title',
        'tr',
        'track',
        'ul',
        'wbr',
        'xmp'
      ],
      vC = [
        'applet',
        'caption',
        'html',
        'table',
        'td',
        'th',
        'marquee',
        'object',
        'template',
        'foreignObject',
        'desc',
        'title'
      ],
      N5 = vC.concat(['button']),
      M5 = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'],
      gC = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      }
    Uf = function (n, i) {
      var s = vt({}, n || gC),
        c = { tag: i }
      return (
        vC.indexOf(i) !== -1 &&
          ((s.aTagInScope = null), (s.buttonTagInScope = null), (s.nobrTagInScope = null)),
        N5.indexOf(i) !== -1 && (s.pTagInButtonScope = null),
        D5.indexOf(i) !== -1 &&
          i !== 'address' &&
          i !== 'div' &&
          i !== 'p' &&
          ((s.listItemTagAutoclosing = null), (s.dlItemTagAutoclosing = null)),
        (s.current = c),
        i === 'form' && (s.formTag = c),
        i === 'a' && (s.aTagInScope = c),
        i === 'button' && (s.buttonTagInScope = c),
        i === 'nobr' && (s.nobrTagInScope = c),
        i === 'p' && (s.pTagInButtonScope = c),
        i === 'li' && (s.listItemTagAutoclosing = c),
        (i === 'dd' || i === 'dt') && (s.dlItemTagAutoclosing = c),
        s
      )
    }
    var L5 = function (n, i) {
        switch (i) {
          case 'select':
            return n === 'option' || n === 'optgroup' || n === '#text'
          case 'optgroup':
            return n === 'option' || n === '#text'
          case 'option':
            return n === '#text'
          case 'tr':
            return n === 'th' || n === 'td' || n === 'style' || n === 'script' || n === 'template'
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return n === 'tr' || n === 'style' || n === 'script' || n === 'template'
          case 'colgroup':
            return n === 'col' || n === 'template'
          case 'table':
            return (
              n === 'caption' ||
              n === 'colgroup' ||
              n === 'tbody' ||
              n === 'tfoot' ||
              n === 'thead' ||
              n === 'style' ||
              n === 'script' ||
              n === 'template'
            )
          case 'head':
            return (
              n === 'base' ||
              n === 'basefont' ||
              n === 'bgsound' ||
              n === 'link' ||
              n === 'meta' ||
              n === 'title' ||
              n === 'noscript' ||
              n === 'noframes' ||
              n === 'style' ||
              n === 'script' ||
              n === 'template'
            )
          case 'html':
            return n === 'head' || n === 'body' || n === 'frameset'
          case 'frameset':
            return n === 'frame'
          case '#document':
            return n === 'html'
        }
        switch (n) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return i !== 'h1' && i !== 'h2' && i !== 'h3' && i !== 'h4' && i !== 'h5' && i !== 'h6'
          case 'rp':
          case 'rt':
            return M5.indexOf(i) === -1
          case 'body':
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frameset':
          case 'frame':
          case 'head':
          case 'html':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return i == null
        }
        return !0
      },
      P5 = function (n, i) {
        switch (n) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return i.pTagInButtonScope
          case 'form':
            return i.formTag || i.pTagInButtonScope
          case 'li':
            return i.listItemTagAutoclosing
          case 'dd':
          case 'dt':
            return i.dlItemTagAutoclosing
          case 'button':
            return i.buttonTagInScope
          case 'a':
            return i.aTagInScope
          case 'nobr':
            return i.nobrTagInScope
        }
        return null
      },
      yC = {}
    jf = function (n, i, s) {
      s = s || gC
      var c = s.current,
        f = c && c.tag
      i != null &&
        (n != null && l('validateDOMNesting: when childText is passed, childTag should be null'),
        (n = '#text'))
      var m = L5(n, f) ? null : c,
        y = m ? null : P5(n, s),
        b = m || y
      if (b) {
        var S = b.tag,
          O = !!m + '|' + n + '|' + S
        if (!yC[O]) {
          yC[O] = !0
          var N = n,
            U = ''
          if (
            (n === '#text'
              ? /\S/.test(i)
                ? (N = 'Text nodes')
                : ((N = 'Whitespace text nodes'),
                  (U =
                    " Make sure you don't have any extra whitespace between tags on each line of your source code."))
              : (N = '<' + n + '>'),
            m)
          ) {
            var j = ''
            S === 'table' &&
              n === 'tr' &&
              (j +=
                ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.'),
              l('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', N, S, U, j)
          } else l('validateDOMNesting(...): %s cannot appear as a descendant of <%s>.', N, S)
        }
      }
    }
  }
  var zp = 'suppressHydrationWarning',
    Hp = '$',
    Wp = '/$',
    $f = '$?',
    Bf = '$!',
    I5 = 'style',
    ey = null,
    ty = null
  function F5(n) {
    var i,
      s,
      c = n.nodeType
    switch (c) {
      case Qa:
      case Ig: {
        i = c === Qa ? '#document' : '#fragment'
        var f = n.documentElement
        s = f ? f.namespaceURI : Pg(null, '')
        break
      }
      default: {
        var m = c === Bn ? n.parentNode : n,
          y = m.namespaceURI || null
        ;(i = m.tagName), (s = Pg(y, i))
        break
      }
    }
    {
      var b = i.toLowerCase(),
        S = Uf(null, b)
      return { namespace: s, ancestorInfo: S }
    }
  }
  function V5(n, i, s) {
    {
      var c = n,
        f = Pg(c.namespace, i),
        m = Uf(c.ancestorInfo, i)
      return { namespace: f, ancestorInfo: m }
    }
  }
  function fZ(n) {
    return n
  }
  function j5(n) {
    ;(ey = IL()), (ty = J4())
    var i = null
    return RT(!1), i
  }
  function U5(n) {
    e5(ty), RT(ey), (ey = null), (ty = null)
  }
  function $5(n, i, s, c, f) {
    var m
    {
      var y = c
      if (
        (jf(n, null, y.ancestorInfo), typeof i.children == 'string' || typeof i.children == 'number')
      ) {
        var b = '' + i.children,
          S = Uf(y.ancestorInfo, n)
        jf(null, b, S)
      }
      m = y.namespace
    }
    var O = S5(n, i, s, m)
    return Wf(f, O), uy(O, i), O
  }
  function B5(n, i) {
    n.appendChild(i)
  }
  function z5(n, i, s, c, f) {
    switch ((C5(n, i, s, c), i)) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        return !!s.autoFocus
      case 'img':
        return !0
      default:
        return !1
    }
  }
  function H5(n, i, s, c, f, m) {
    {
      var y = m
      if (
        typeof c.children != typeof s.children &&
        (typeof c.children == 'string' || typeof c.children == 'number')
      ) {
        var b = '' + c.children,
          S = Uf(y.ancestorInfo, i)
        jf(null, b, S)
      }
    }
    return w5(n, i, s, c)
  }
  function ny(n, i) {
    return (
      n === 'textarea' ||
      n === 'noscript' ||
      typeof i.children == 'string' ||
      typeof i.children == 'number' ||
      (typeof i.dangerouslySetInnerHTML == 'object' &&
        i.dangerouslySetInnerHTML !== null &&
        i.dangerouslySetInnerHTML.__html != null)
    )
  }
  function W5(n, i, s, c) {
    {
      var f = s
      jf(null, n, f.ancestorInfo)
    }
    var m = T5(n, i)
    return Wf(c, m), m
  }
  function Y5() {
    var n = window.event
    return n === void 0 ? ao : _T(n.type)
  }
  var ry = typeof setTimeout == 'function' ? setTimeout : void 0,
    q5 = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    iy = -1,
    bC = typeof Promise == 'function' ? Promise : void 0,
    G5 =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof bC < 'u'
          ? function (n) {
              return bC.resolve(null).then(n).catch(K5)
            }
          : ry
  function K5(n) {
    setTimeout(function () {
      throw n
    })
  }
  function Z5(n, i, s, c) {
    switch (i) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        s.autoFocus && n.focus()
        return
      case 'img': {
        s.src && (n.src = s.src)
        return
      }
    }
  }
  function X5(n, i, s, c, f, m) {
    R5(n, i, s, c, f), uy(n, f)
  }
  function EC(n) {
    cp(n, '')
  }
  function Q5(n, i, s) {
    n.nodeValue = s
  }
  function J5(n, i) {
    n.appendChild(i)
  }
  function eP(n, i) {
    var s
    n.nodeType === Bn ? ((s = n.parentNode), s.insertBefore(i, n)) : ((s = n), s.appendChild(i))
    var c = n._reactRootContainer
    c == null && s.onclick === null && Bp(s)
  }
  function tP(n, i, s) {
    n.insertBefore(i, s)
  }
  function nP(n, i, s) {
    n.nodeType === Bn ? n.parentNode.insertBefore(i, s) : n.insertBefore(i, s)
  }
  function rP(n, i) {
    n.removeChild(i)
  }
  function iP(n, i) {
    n.nodeType === Bn ? n.parentNode.removeChild(i) : n.removeChild(i)
  }
  function ay(n, i) {
    var s = i,
      c = 0
    do {
      var f = s.nextSibling
      if ((n.removeChild(s), f && f.nodeType === Bn)) {
        var m = f.data
        if (m === Wp)
          if (c === 0) {
            n.removeChild(f), Cf(i)
            return
          } else c--
        else (m === Hp || m === $f || m === Bf) && c++
      }
      s = f
    } while (s)
    Cf(i)
  }
  function aP(n, i) {
    n.nodeType === Bn ? ay(n.parentNode, i) : n.nodeType === ni && ay(n, i), Cf(n)
  }
  function oP(n) {
    n = n
    var i = n.style
    typeof i.setProperty == 'function'
      ? i.setProperty('display', 'none', 'important')
      : (i.display = 'none')
  }
  function sP(n) {
    n.nodeValue = ''
  }
  function lP(n, i) {
    n = n
    var s = i[I5],
      c = s != null && s.hasOwnProperty('display') ? s.display : null
    n.style.display = Fg('display', c)
  }
  function uP(n, i) {
    n.nodeValue = i
  }
  function cP(n) {
    n.nodeType === ni
      ? (n.textContent = '')
      : n.nodeType === Qa && n.documentElement && n.removeChild(n.documentElement)
  }
  function fP(n, i, s) {
    return n.nodeType !== ni || i.toLowerCase() !== n.nodeName.toLowerCase() ? null : n
  }
  function dP(n, i) {
    return i === '' || n.nodeType !== Xa ? null : n
  }
  function hP(n) {
    return n.nodeType !== Bn ? null : n
  }
  function xC(n) {
    return n.data === $f
  }
  function oy(n) {
    return n.data === Bf
  }
  function pP(n) {
    var i = n.nextSibling && n.nextSibling.dataset,
      s,
      c,
      f
    return i && ((s = i.dgst), (c = i.msg), (f = i.stck)), { message: c, digest: s, stack: f }
  }
  function mP(n, i) {
    n._reactRetry = i
  }
  function Yp(n) {
    for (; n != null; n = n.nextSibling) {
      var i = n.nodeType
      if (i === ni || i === Xa) break
      if (i === Bn) {
        var s = n.data
        if (s === Hp || s === Bf || s === $f) break
        if (s === Wp) return null
      }
    }
    return n
  }
  function zf(n) {
    return Yp(n.nextSibling)
  }
  function vP(n) {
    return Yp(n.firstChild)
  }
  function gP(n) {
    return Yp(n.firstChild)
  }
  function yP(n) {
    return Yp(n.nextSibling)
  }
  function bP(n, i, s, c, f, m, y) {
    Wf(m, n), uy(n, s)
    var b
    {
      var S = f
      b = S.namespace
    }
    var O = (m.mode & Lt) !== Je
    return O5(n, i, s, b, c, O, y)
  }
  function EP(n, i, s, c) {
    return Wf(s, n), s.mode & Lt, k5(n, i)
  }
  function xP(n, i) {
    Wf(i, n)
  }
  function SP(n) {
    for (var i = n.nextSibling, s = 0; i; ) {
      if (i.nodeType === Bn) {
        var c = i.data
        if (c === Wp) {
          if (s === 0) return zf(i)
          s--
        } else (c === Hp || c === Bf || c === $f) && s++
      }
      i = i.nextSibling
    }
    return null
  }
  function SC(n) {
    for (var i = n.previousSibling, s = 0; i; ) {
      if (i.nodeType === Bn) {
        var c = i.data
        if (c === Hp || c === Bf || c === $f) {
          if (s === 0) return i
          s--
        } else c === Wp && s++
      }
      i = i.previousSibling
    }
    return null
  }
  function TP(n) {
    Cf(n)
  }
  function CP(n) {
    Cf(n)
  }
  function wP(n) {
    return n !== 'head' && n !== 'body'
  }
  function RP(n, i, s, c) {
    var f = !0
    $p(i.nodeValue, s, c, f)
  }
  function _P(n, i, s, c, f, m) {
    if (i[zp] !== !0) {
      var y = !0
      $p(c.nodeValue, f, m, y)
    }
  }
  function OP(n, i) {
    i.nodeType === ni ? Z0(n, i) : i.nodeType === Bn || X0(n, i)
  }
  function kP(n, i) {
    {
      var s = n.parentNode
      s !== null && (i.nodeType === ni ? Z0(s, i) : i.nodeType === Bn || X0(s, i))
    }
  }
  function AP(n, i, s, c, f) {
    ;(f || i[zp] !== !0) && (c.nodeType === ni ? Z0(s, c) : c.nodeType === Bn || X0(s, c))
  }
  function DP(n, i, s) {
    Q0(n, i)
  }
  function NP(n, i) {
    J0(n, i)
  }
  function MP(n, i, s) {
    {
      var c = n.parentNode
      c !== null && Q0(c, i)
    }
  }
  function LP(n, i) {
    {
      var s = n.parentNode
      s !== null && J0(s, i)
    }
  }
  function PP(n, i, s, c, f, m) {
    ;(m || i[zp] !== !0) && Q0(s, c)
  }
  function IP(n, i, s, c, f) {
    ;(f || i[zp] !== !0) && J0(s, c)
  }
  function FP(n) {
    l(
      'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',
      n.nodeName.toLowerCase()
    )
  }
  function VP(n) {
    Pf(n)
  }
  var gu = Math.random().toString(36).slice(2),
    yu = '__reactFiber$' + gu,
    sy = '__reactProps$' + gu,
    Hf = '__reactContainer$' + gu,
    ly = '__reactEvents$' + gu,
    jP = '__reactListeners$' + gu,
    UP = '__reactHandles$' + gu
  function $P(n) {
    delete n[yu], delete n[sy], delete n[ly], delete n[jP], delete n[UP]
  }
  function Wf(n, i) {
    i[yu] = n
  }
  function qp(n, i) {
    i[Hf] = n
  }
  function TC(n) {
    n[Hf] = null
  }
  function Yf(n) {
    return !!n[Hf]
  }
  function Zs(n) {
    var i = n[yu]
    if (i) return i
    for (var s = n.parentNode; s; ) {
      if (((i = s[Hf] || s[yu]), i)) {
        var c = i.alternate
        if (i.child !== null || (c !== null && c.child !== null))
          for (var f = SC(n); f !== null; ) {
            var m = f[yu]
            if (m) return m
            f = SC(f)
          }
        return i
      }
      ;(n = s), (s = n.parentNode)
    }
    return null
  }
  function Go(n) {
    var i = n[yu] || n[Hf]
    return i && (i.tag === x || i.tag === C || i.tag === F || i.tag === g) ? i : null
  }
  function bu(n) {
    if (n.tag === x || n.tag === C) return n.stateNode
    throw new Error('getNodeFromInstance: Invalid argument.')
  }
  function Gp(n) {
    return n[sy] || null
  }
  function uy(n, i) {
    n[sy] = i
  }
  function BP(n) {
    var i = n[ly]
    return i === void 0 && (i = n[ly] = new Set()), i
  }
  var CC = {},
    wC = r.ReactDebugCurrentFrame
  function Kp(n) {
    if (n) {
      var i = n._owner,
        s = Io(n.type, n._source, i ? i.type : null)
      wC.setExtraStackFrame(s)
    } else wC.setExtraStackFrame(null)
  }
  function Qi(n, i, s, c, f) {
    {
      var m = Function.call.bind(Oe)
      for (var y in n)
        if (m(n, y)) {
          var b = void 0
          try {
            if (typeof n[y] != 'function') {
              var S = Error(
                (c || 'React class') +
                  ': ' +
                  s +
                  ' type `' +
                  y +
                  '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                  typeof n[y] +
                  '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
              )
              throw ((S.name = 'Invariant Violation'), S)
            }
            b = n[y](i, y, c, s, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
          } catch (O) {
            b = O
          }
          b &&
            !(b instanceof Error) &&
            (Kp(f),
            l(
              '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
              c || 'React class',
              s,
              y,
              typeof b
            ),
            Kp(null)),
            b instanceof Error &&
              !(b.message in CC) &&
              ((CC[b.message] = !0), Kp(f), l('Failed %s type: %s', s, b.message), Kp(null))
        }
    }
  }
  var cy = [],
    Zp
  Zp = []
  var oo = -1
  function Ko(n) {
    return { current: n }
  }
  function Or(n, i) {
    if (oo < 0) {
      l('Unexpected pop.')
      return
    }
    i !== Zp[oo] && l('Unexpected Fiber popped.'),
      (n.current = cy[oo]),
      (cy[oo] = null),
      (Zp[oo] = null),
      oo--
  }
  function kr(n, i, s) {
    oo++, (cy[oo] = n.current), (Zp[oo] = s), (n.current = i)
  }
  var fy
  fy = {}
  var bi = {}
  Object.freeze(bi)
  var so = Ko(bi),
    Ra = Ko(!1),
    dy = bi
  function Eu(n, i, s) {
    return s && _a(i) ? dy : so.current
  }
  function RC(n, i, s) {
    {
      var c = n.stateNode
      ;(c.__reactInternalMemoizedUnmaskedChildContext = i),
        (c.__reactInternalMemoizedMaskedChildContext = s)
    }
  }
  function xu(n, i) {
    {
      var s = n.type,
        c = s.contextTypes
      if (!c) return bi
      var f = n.stateNode
      if (f && f.__reactInternalMemoizedUnmaskedChildContext === i)
        return f.__reactInternalMemoizedMaskedChildContext
      var m = {}
      for (var y in c) m[y] = i[y]
      {
        var b = bt(n) || 'Unknown'
        Qi(c, m, 'context', b)
      }
      return f && RC(n, i, m), m
    }
  }
  function Xp() {
    return Ra.current
  }
  function _a(n) {
    {
      var i = n.childContextTypes
      return i != null
    }
  }
  function Qp(n) {
    Or(Ra, n), Or(so, n)
  }
  function hy(n) {
    Or(Ra, n), Or(so, n)
  }
  function _C(n, i, s) {
    {
      if (so.current !== bi)
        throw new Error(
          'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'
        )
      kr(so, i, n), kr(Ra, s, n)
    }
  }
  function OC(n, i, s) {
    {
      var c = n.stateNode,
        f = i.childContextTypes
      if (typeof c.getChildContext != 'function') {
        {
          var m = bt(n) || 'Unknown'
          fy[m] ||
            ((fy[m] = !0),
            l(
              '%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
              m,
              m
            ))
        }
        return s
      }
      var y = c.getChildContext()
      for (var b in y)
        if (!(b in f))
          throw new Error(
            (bt(n) || 'Unknown') +
              '.getChildContext(): key "' +
              b +
              '" is not defined in childContextTypes.'
          )
      {
        var S = bt(n) || 'Unknown'
        Qi(f, y, 'child context', S)
      }
      return vt({}, s, y)
    }
  }
  function Jp(n) {
    {
      var i = n.stateNode,
        s = (i && i.__reactInternalMemoizedMergedChildContext) || bi
      return (dy = so.current), kr(so, s, n), kr(Ra, Ra.current, n), !0
    }
  }
  function kC(n, i, s) {
    {
      var c = n.stateNode
      if (!c)
        throw new Error(
          'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'
        )
      if (s) {
        var f = OC(n, i, dy)
        ;(c.__reactInternalMemoizedMergedChildContext = f),
          Or(Ra, n),
          Or(so, n),
          kr(so, f, n),
          kr(Ra, s, n)
      } else Or(Ra, n), kr(Ra, s, n)
    }
  }
  function zP(n) {
    {
      if (!w3(n) || n.tag !== p)
        throw new Error(
          'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'
        )
      var i = n
      do {
        switch (i.tag) {
          case g:
            return i.stateNode.context
          case p: {
            var s = i.type
            if (_a(s)) return i.stateNode.__reactInternalMemoizedMergedChildContext
            break
          }
        }
        i = i.return
      } while (i !== null)
      throw new Error(
        'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'
      )
    }
  }
  var Zo = 0,
    em = 1,
    lo = null,
    py = !1,
    my = !1
  function AC(n) {
    lo === null ? (lo = [n]) : lo.push(n)
  }
  function HP(n) {
    ;(py = !0), AC(n)
  }
  function DC() {
    py && Xo()
  }
  function Xo() {
    if (!my && lo !== null) {
      my = !0
      var n = 0,
        i = Xi()
      try {
        var s = !0,
          c = lo
        for (ur(vi); n < c.length; n++) {
          var f = c[n]
          do f = f(s)
          while (f !== null)
        }
        ;(lo = null), (py = !1)
      } catch (m) {
        throw (lo !== null && (lo = lo.slice(n + 1)), tT(vp, Xo), m)
      } finally {
        ur(i), (my = !1)
      }
    }
    return null
  }
  var Su = [],
    Tu = 0,
    tm = null,
    nm = 0,
    Pi = [],
    Ii = 0,
    Xs = null,
    uo = 1,
    co = ''
  function WP(n) {
    return Js(), (n.flags & q1) !== et
  }
  function YP(n) {
    return Js(), nm
  }
  function qP() {
    var n = co,
      i = uo,
      s = i & ~GP(i)
    return s.toString(32) + n
  }
  function Qs(n, i) {
    Js(), (Su[Tu++] = nm), (Su[Tu++] = tm), (tm = n), (nm = i)
  }
  function NC(n, i, s) {
    Js(), (Pi[Ii++] = uo), (Pi[Ii++] = co), (Pi[Ii++] = Xs), (Xs = n)
    var c = uo,
      f = co,
      m = rm(c) - 1,
      y = c & ~(1 << m),
      b = s + 1,
      S = rm(i) + m
    if (S > 30) {
      var O = m - (m % 5),
        N = (1 << O) - 1,
        U = (y & N).toString(32),
        j = y >> O,
        q = m - O,
        Z = rm(i) + q,
        ee = b << q,
        Ae = ee | j,
        Ze = U + f
      ;(uo = (1 << Z) | Ae), (co = Ze)
    } else {
      var We = b << m,
        It = We | y,
        Ot = f
      ;(uo = (1 << S) | It), (co = Ot)
    }
  }
  function vy(n) {
    Js()
    var i = n.return
    if (i !== null) {
      var s = 1,
        c = 0
      Qs(n, s), NC(n, s, c)
    }
  }
  function rm(n) {
    return 32 - sT(n)
  }
  function GP(n) {
    return 1 << (rm(n) - 1)
  }
  function gy(n) {
    for (; n === tm; ) (tm = Su[--Tu]), (Su[Tu] = null), (nm = Su[--Tu]), (Su[Tu] = null)
    for (; n === Xs; )
      (Xs = Pi[--Ii]),
        (Pi[Ii] = null),
        (co = Pi[--Ii]),
        (Pi[Ii] = null),
        (uo = Pi[--Ii]),
        (Pi[Ii] = null)
  }
  function KP() {
    return Js(), Xs !== null ? { id: uo, overflow: co } : null
  }
  function ZP(n, i) {
    Js(), (Pi[Ii++] = uo), (Pi[Ii++] = co), (Pi[Ii++] = Xs), (uo = i.id), (co = i.overflow), (Xs = n)
  }
  function Js() {
    hr() || l('Expected to be hydrating. This is a bug in React. Please file an issue.')
  }
  var dr = null,
    Fi = null,
    Ji = !1,
    el = !1,
    Qo = null
  function XP() {
    Ji && l('We should not be hydrating here. This is a bug in React. Please file a bug.')
  }
  function MC() {
    el = !0
  }
  function QP() {
    return el
  }
  function JP(n) {
    var i = n.stateNode.containerInfo
    return (Fi = gP(i)), (dr = n), (Ji = !0), (Qo = null), (el = !1), !0
  }
  function e7(n, i, s) {
    return (Fi = yP(i)), (dr = n), (Ji = !0), (Qo = null), (el = !1), s !== null && ZP(n, s), !0
  }
  function LC(n, i) {
    switch (n.tag) {
      case g: {
        OP(n.stateNode.containerInfo, i)
        break
      }
      case x: {
        var s = (n.mode & Lt) !== Je
        AP(n.type, n.memoizedProps, n.stateNode, i, s)
        break
      }
      case F: {
        var c = n.memoizedState
        c.dehydrated !== null && kP(c.dehydrated, i)
        break
      }
    }
  }
  function PC(n, i) {
    LC(n, i)
    var s = i6()
    ;(s.stateNode = i), (s.return = n)
    var c = n.deletions
    c === null ? ((n.deletions = [s]), (n.flags |= Vs)) : c.push(s)
  }
  function yy(n, i) {
    {
      if (el) return
      switch (n.tag) {
        case g: {
          var s = n.stateNode.containerInfo
          switch (i.tag) {
            case x:
              var c = i.type
              i.pendingProps, DP(s, c)
              break
            case C:
              var f = i.pendingProps
              NP(s, f)
              break
          }
          break
        }
        case x: {
          var m = n.type,
            y = n.memoizedProps,
            b = n.stateNode
          switch (i.tag) {
            case x: {
              var S = i.type,
                O = i.pendingProps,
                N = (n.mode & Lt) !== Je
              PP(m, y, b, S, O, N)
              break
            }
            case C: {
              var U = i.pendingProps,
                j = (n.mode & Lt) !== Je
              IP(m, y, b, U, j)
              break
            }
          }
          break
        }
        case F: {
          var q = n.memoizedState,
            Z = q.dehydrated
          if (Z !== null)
            switch (i.tag) {
              case x:
                var ee = i.type
                i.pendingProps, MP(Z, ee)
                break
              case C:
                var Ae = i.pendingProps
                LP(Z, Ae)
                break
            }
          break
        }
        default:
          return
      }
    }
  }
  function IC(n, i) {
    ;(i.flags = (i.flags & ~eo) | zn), yy(n, i)
  }
  function FC(n, i) {
    switch (n.tag) {
      case x: {
        var s = n.type
        n.pendingProps
        var c = fP(i, s)
        return c !== null ? ((n.stateNode = c), (dr = n), (Fi = vP(c)), !0) : !1
      }
      case C: {
        var f = n.pendingProps,
          m = dP(i, f)
        return m !== null ? ((n.stateNode = m), (dr = n), (Fi = null), !0) : !1
      }
      case F: {
        var y = hP(i)
        if (y !== null) {
          var b = { dehydrated: y, treeContext: KP(), retryLane: pi }
          n.memoizedState = b
          var S = a6(y)
          return (S.return = n), (n.child = S), (dr = n), (Fi = null), !0
        }
        return !1
      }
      default:
        return !1
    }
  }
  function by(n) {
    return (n.mode & Lt) !== Je && (n.flags & Xt) === et
  }
  function Ey(n) {
    throw new Error(
      'Hydration failed because the initial UI does not match what was rendered on the server.'
    )
  }
  function xy(n) {
    if (Ji) {
      var i = Fi
      if (!i) {
        by(n) && (yy(dr, n), Ey()), IC(dr, n), (Ji = !1), (dr = n)
        return
      }
      var s = i
      if (!FC(n, i)) {
        by(n) && (yy(dr, n), Ey()), (i = zf(s))
        var c = dr
        if (!i || !FC(n, i)) {
          IC(dr, n), (Ji = !1), (dr = n)
          return
        }
        PC(c, s)
      }
    }
  }
  function t7(n, i, s) {
    var c = n.stateNode,
      f = !el,
      m = bP(c, n.type, n.memoizedProps, i, s, n, f)
    return (n.updateQueue = m), m !== null
  }
  function n7(n) {
    var i = n.stateNode,
      s = n.memoizedProps,
      c = EP(i, s, n)
    if (c) {
      var f = dr
      if (f !== null)
        switch (f.tag) {
          case g: {
            var m = f.stateNode.containerInfo,
              y = (f.mode & Lt) !== Je
            RP(m, i, s, y)
            break
          }
          case x: {
            var b = f.type,
              S = f.memoizedProps,
              O = f.stateNode,
              N = (f.mode & Lt) !== Je
            _P(b, S, O, i, s, N)
            break
          }
        }
    }
    return c
  }
  function r7(n) {
    var i = n.memoizedState,
      s = i !== null ? i.dehydrated : null
    if (!s)
      throw new Error(
        'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
      )
    xP(s, n)
  }
  function i7(n) {
    var i = n.memoizedState,
      s = i !== null ? i.dehydrated : null
    if (!s)
      throw new Error(
        'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
      )
    return SP(s)
  }
  function VC(n) {
    for (var i = n.return; i !== null && i.tag !== x && i.tag !== g && i.tag !== F; ) i = i.return
    dr = i
  }
  function im(n) {
    if (n !== dr) return !1
    if (!Ji) return VC(n), (Ji = !0), !1
    if (n.tag !== g && (n.tag !== x || (wP(n.type) && !ny(n.type, n.memoizedProps)))) {
      var i = Fi
      if (i)
        if (by(n)) jC(n), Ey()
        else for (; i; ) PC(n, i), (i = zf(i))
    }
    return VC(n), n.tag === F ? (Fi = i7(n)) : (Fi = dr ? zf(n.stateNode) : null), !0
  }
  function a7() {
    return Ji && Fi !== null
  }
  function jC(n) {
    for (var i = Fi; i; ) LC(n, i), (i = zf(i))
  }
  function Cu() {
    ;(dr = null), (Fi = null), (Ji = !1), (el = !1)
  }
  function UC() {
    Qo !== null && (M2(Qo), (Qo = null))
  }
  function hr() {
    return Ji
  }
  function Sy(n) {
    Qo === null ? (Qo = [n]) : Qo.push(n)
  }
  var o7 = r.ReactCurrentBatchConfig,
    s7 = null
  function l7() {
    return o7.transition
  }
  var ea = {
    recordUnsafeLifecycleWarnings: function (n, i) {},
    flushPendingUnsafeLifecycleWarnings: function () {},
    recordLegacyContextWarning: function (n, i) {},
    flushLegacyContextWarning: function () {},
    discardPendingWarnings: function () {}
  }
  {
    var u7 = function (n) {
        for (var i = null, s = n; s !== null; ) s.mode & Nn && (i = s), (s = s.return)
        return i
      },
      tl = function (n) {
        var i = []
        return (
          n.forEach(function (s) {
            i.push(s)
          }),
          i.sort().join(', ')
        )
      },
      qf = [],
      Gf = [],
      Kf = [],
      Zf = [],
      Xf = [],
      Qf = [],
      nl = new Set()
    ;(ea.recordUnsafeLifecycleWarnings = function (n, i) {
      nl.has(n.type) ||
        (typeof i.componentWillMount == 'function' &&
          i.componentWillMount.__suppressDeprecationWarning !== !0 &&
          qf.push(n),
        n.mode & Nn && typeof i.UNSAFE_componentWillMount == 'function' && Gf.push(n),
        typeof i.componentWillReceiveProps == 'function' &&
          i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 &&
          Kf.push(n),
        n.mode & Nn && typeof i.UNSAFE_componentWillReceiveProps == 'function' && Zf.push(n),
        typeof i.componentWillUpdate == 'function' &&
          i.componentWillUpdate.__suppressDeprecationWarning !== !0 &&
          Xf.push(n),
        n.mode & Nn && typeof i.UNSAFE_componentWillUpdate == 'function' && Qf.push(n))
    }),
      (ea.flushPendingUnsafeLifecycleWarnings = function () {
        var n = new Set()
        qf.length > 0 &&
          (qf.forEach(function (j) {
            n.add(bt(j) || 'Component'), nl.add(j.type)
          }),
          (qf = []))
        var i = new Set()
        Gf.length > 0 &&
          (Gf.forEach(function (j) {
            i.add(bt(j) || 'Component'), nl.add(j.type)
          }),
          (Gf = []))
        var s = new Set()
        Kf.length > 0 &&
          (Kf.forEach(function (j) {
            s.add(bt(j) || 'Component'), nl.add(j.type)
          }),
          (Kf = []))
        var c = new Set()
        Zf.length > 0 &&
          (Zf.forEach(function (j) {
            c.add(bt(j) || 'Component'), nl.add(j.type)
          }),
          (Zf = []))
        var f = new Set()
        Xf.length > 0 &&
          (Xf.forEach(function (j) {
            f.add(bt(j) || 'Component'), nl.add(j.type)
          }),
          (Xf = []))
        var m = new Set()
        if (
          (Qf.length > 0 &&
            (Qf.forEach(function (j) {
              m.add(bt(j) || 'Component'), nl.add(j.type)
            }),
            (Qf = [])),
          i.size > 0)
        ) {
          var y = tl(i)
          l(
            `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
            y
          )
        }
        if (c.size > 0) {
          var b = tl(c)
          l(
            `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`,
            b
          )
        }
        if (m.size > 0) {
          var S = tl(m)
          l(
            `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
            S
          )
        }
        if (n.size > 0) {
          var O = tl(n)
          u(
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            O
          )
        }
        if (s.size > 0) {
          var N = tl(s)
          u(
            `componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            N
          )
        }
        if (f.size > 0) {
          var U = tl(f)
          u(
            `componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            U
          )
        }
      })
    var am = new Map(),
      $C = new Set()
    ;(ea.recordLegacyContextWarning = function (n, i) {
      var s = u7(n)
      if (s === null) {
        l(
          'Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.'
        )
        return
      }
      if (!$C.has(n.type)) {
        var c = am.get(s)
        ;(n.type.contextTypes != null ||
          n.type.childContextTypes != null ||
          (i !== null && typeof i.getChildContext == 'function')) &&
          (c === void 0 && ((c = []), am.set(s, c)), c.push(n))
      }
    }),
      (ea.flushLegacyContextWarning = function () {
        am.forEach(function (n, i) {
          if (n.length !== 0) {
            var s = n[0],
              c = new Set()
            n.forEach(function (m) {
              c.add(bt(m) || 'Component'), $C.add(m.type)
            })
            var f = tl(c)
            try {
              Rn(s),
                l(
                  `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`,
                  f
                )
            } finally {
              ar()
            }
          }
        })
      }),
      (ea.discardPendingWarnings = function () {
        ;(qf = []), (Gf = []), (Kf = []), (Zf = []), (Xf = []), (Qf = []), (am = new Map())
      })
  }
  var Ty,
    Cy,
    wy,
    Ry,
    _y,
    BC = function (n, i) {}
  ;(Ty = !1),
    (Cy = !1),
    (wy = {}),
    (Ry = {}),
    (_y = {}),
    (BC = function (n, i) {
      if (!(n === null || typeof n != 'object') && !(!n._store || n._store.validated || n.key != null)) {
        if (typeof n._store != 'object')
          throw new Error(
            'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'
          )
        n._store.validated = !0
        var s = bt(i) || 'Component'
        Ry[s] ||
          ((Ry[s] = !0),
          l(
            'Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'
          ))
      }
    })
  function c7(n) {
    return n.prototype && n.prototype.isReactComponent
  }
  function Jf(n, i, s) {
    var c = s.ref
    if (c !== null && typeof c != 'function' && typeof c != 'object') {
      if (
        (n.mode & Nn || xt) &&
        !(s._owner && s._self && s._owner.stateNode !== s._self) &&
        !(s._owner && s._owner.tag !== p) &&
        !(typeof s.type == 'function' && !c7(s.type)) &&
        s._owner
      ) {
        var f = bt(n) || 'Component'
        wy[f] ||
          (l(
            'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
            f,
            c
          ),
          (wy[f] = !0))
      }
      if (s._owner) {
        var m = s._owner,
          y
        if (m) {
          var b = m
          if (b.tag !== p)
            throw new Error(
              'Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref'
            )
          y = b.stateNode
        }
        if (!y)
          throw new Error(
            'Missing owner for string ref ' +
              c +
              '. This error is likely caused by a bug in React. Please file an issue.'
          )
        var S = y
        Pn(c, 'ref')
        var O = '' + c
        if (i !== null && i.ref !== null && typeof i.ref == 'function' && i.ref._stringRef === O)
          return i.ref
        var N = function (U) {
          var j = S.refs
          U === null ? delete j[O] : (j[O] = U)
        }
        return (N._stringRef = O), N
      } else {
        if (typeof c != 'string')
          throw new Error(
            'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'
          )
        if (!s._owner)
          throw new Error(
            'Element ref was specified as a string (' +
              c +
              `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`
          )
      }
    }
    return c
  }
  function om(n, i) {
    var s = Object.prototype.toString.call(i)
    throw new Error(
      'Objects are not valid as a React child (found: ' +
        (s === '[object Object]' ? 'object with keys {' + Object.keys(i).join(', ') + '}' : s) +
        '). If you meant to render a collection of children, use an array instead.'
    )
  }
  function sm(n) {
    {
      var i = bt(n) || 'Component'
      if (_y[i]) return
      ;(_y[i] = !0),
        l(
          'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.'
        )
    }
  }
  function zC(n) {
    var i = n._payload,
      s = n._init
    return s(i)
  }
  function HC(n) {
    function i(W, te) {
      if (n) {
        var Y = W.deletions
        Y === null ? ((W.deletions = [te]), (W.flags |= Vs)) : Y.push(te)
      }
    }
    function s(W, te) {
      if (!n) return null
      for (var Y = te; Y !== null; ) i(W, Y), (Y = Y.sibling)
      return null
    }
    function c(W, te) {
      for (var Y = new Map(), me = te; me !== null; )
        me.key !== null ? Y.set(me.key, me) : Y.set(me.index, me), (me = me.sibling)
      return Y
    }
    function f(W, te) {
      var Y = fl(W, te)
      return (Y.index = 0), (Y.sibling = null), Y
    }
    function m(W, te, Y) {
      if (((W.index = Y), !n)) return (W.flags |= q1), te
      var me = W.alternate
      if (me !== null) {
        var Fe = me.index
        return Fe < te ? ((W.flags |= zn), te) : Fe
      } else return (W.flags |= zn), te
    }
    function y(W) {
      return n && W.alternate === null && (W.flags |= zn), W
    }
    function b(W, te, Y, me) {
      if (te === null || te.tag !== C) {
        var Fe = SE(Y, W.mode, me)
        return (Fe.return = W), Fe
      } else {
        var Ne = f(te, Y)
        return (Ne.return = W), Ne
      }
    }
    function S(W, te, Y, me) {
      var Fe = Y.type
      if (Fe === P) return N(W, te, Y.props.children, me, Y.key)
      if (
        te !== null &&
        (te.elementType === Fe ||
          K2(te, Y) ||
          (typeof Fe == 'object' && Fe !== null && Fe.$$typeof === ke && zC(Fe) === te.type))
      ) {
        var Ne = f(te, Y.props)
        return (
          (Ne.ref = Jf(W, te, Y)),
          (Ne.return = W),
          (Ne._debugSource = Y._source),
          (Ne._debugOwner = Y._owner),
          Ne
        )
      }
      var nt = xE(Y, W.mode, me)
      return (nt.ref = Jf(W, te, Y)), (nt.return = W), nt
    }
    function O(W, te, Y, me) {
      if (
        te === null ||
        te.tag !== E ||
        te.stateNode.containerInfo !== Y.containerInfo ||
        te.stateNode.implementation !== Y.implementation
      ) {
        var Fe = TE(Y, W.mode, me)
        return (Fe.return = W), Fe
      } else {
        var Ne = f(te, Y.children || [])
        return (Ne.return = W), Ne
      }
    }
    function N(W, te, Y, me, Fe) {
      if (te === null || te.tag !== _) {
        var Ne = us(Y, W.mode, me, Fe)
        return (Ne.return = W), Ne
      } else {
        var nt = f(te, Y)
        return (nt.return = W), nt
      }
    }
    function U(W, te, Y) {
      if ((typeof te == 'string' && te !== '') || typeof te == 'number') {
        var me = SE('' + te, W.mode, Y)
        return (me.return = W), me
      }
      if (typeof te == 'object' && te !== null) {
        switch (te.$$typeof) {
          case Sn: {
            var Fe = xE(te, W.mode, Y)
            return (Fe.ref = Jf(W, null, te)), (Fe.return = W), Fe
          }
          case ir: {
            var Ne = TE(te, W.mode, Y)
            return (Ne.return = W), Ne
          }
          case ke: {
            var nt = te._payload,
              mt = te._init
            return U(W, mt(nt), Y)
          }
        }
        if (Zt(te) || Tn(te)) {
          var ln = us(te, W.mode, Y, null)
          return (ln.return = W), ln
        }
        om(W, te)
      }
      return typeof te == 'function' && sm(W), null
    }
    function j(W, te, Y, me) {
      var Fe = te !== null ? te.key : null
      if ((typeof Y == 'string' && Y !== '') || typeof Y == 'number')
        return Fe !== null ? null : b(W, te, '' + Y, me)
      if (typeof Y == 'object' && Y !== null) {
        switch (Y.$$typeof) {
          case Sn:
            return Y.key === Fe ? S(W, te, Y, me) : null
          case ir:
            return Y.key === Fe ? O(W, te, Y, me) : null
          case ke: {
            var Ne = Y._payload,
              nt = Y._init
            return j(W, te, nt(Ne), me)
          }
        }
        if (Zt(Y) || Tn(Y)) return Fe !== null ? null : N(W, te, Y, me, null)
        om(W, Y)
      }
      return typeof Y == 'function' && sm(W), null
    }
    function q(W, te, Y, me, Fe) {
      if ((typeof me == 'string' && me !== '') || typeof me == 'number') {
        var Ne = W.get(Y) || null
        return b(te, Ne, '' + me, Fe)
      }
      if (typeof me == 'object' && me !== null) {
        switch (me.$$typeof) {
          case Sn: {
            var nt = W.get(me.key === null ? Y : me.key) || null
            return S(te, nt, me, Fe)
          }
          case ir: {
            var mt = W.get(me.key === null ? Y : me.key) || null
            return O(te, mt, me, Fe)
          }
          case ke:
            var ln = me._payload,
              Yt = me._init
            return q(W, te, Y, Yt(ln), Fe)
        }
        if (Zt(me) || Tn(me)) {
          var Vn = W.get(Y) || null
          return N(te, Vn, me, Fe, null)
        }
        om(te, me)
      }
      return typeof me == 'function' && sm(te), null
    }
    function Z(W, te, Y) {
      {
        if (typeof W != 'object' || W === null) return te
        switch (W.$$typeof) {
          case Sn:
          case ir:
            BC(W, Y)
            var me = W.key
            if (typeof me != 'string') break
            if (te === null) {
              ;(te = new Set()), te.add(me)
              break
            }
            if (!te.has(me)) {
              te.add(me)
              break
            }
            l(
              'Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.',
              me
            )
            break
          case ke:
            var Fe = W._payload,
              Ne = W._init
            Z(Ne(Fe), te, Y)
            break
        }
      }
      return te
    }
    function ee(W, te, Y, me) {
      for (var Fe = null, Ne = 0; Ne < Y.length; Ne++) {
        var nt = Y[Ne]
        Fe = Z(nt, Fe, W)
      }
      for (
        var mt = null, ln = null, Yt = te, Vn = 0, qt = 0, Mn = null;
        Yt !== null && qt < Y.length;
        qt++
      ) {
        Yt.index > qt ? ((Mn = Yt), (Yt = null)) : (Mn = Yt.sibling)
        var Dr = j(W, Yt, Y[qt], me)
        if (Dr === null) {
          Yt === null && (Yt = Mn)
          break
        }
        n && Yt && Dr.alternate === null && i(W, Yt),
          (Vn = m(Dr, Vn, qt)),
          ln === null ? (mt = Dr) : (ln.sibling = Dr),
          (ln = Dr),
          (Yt = Mn)
      }
      if (qt === Y.length) {
        if ((s(W, Yt), hr())) {
          var Er = qt
          Qs(W, Er)
        }
        return mt
      }
      if (Yt === null) {
        for (; qt < Y.length; qt++) {
          var xi = U(W, Y[qt], me)
          xi !== null && ((Vn = m(xi, Vn, qt)), ln === null ? (mt = xi) : (ln.sibling = xi), (ln = xi))
        }
        if (hr()) {
          var Wr = qt
          Qs(W, Wr)
        }
        return mt
      }
      for (var Yr = c(W, Yt); qt < Y.length; qt++) {
        var Nr = q(Yr, W, qt, Y[qt], me)
        Nr !== null &&
          (n && Nr.alternate !== null && Yr.delete(Nr.key === null ? qt : Nr.key),
          (Vn = m(Nr, Vn, qt)),
          ln === null ? (mt = Nr) : (ln.sibling = Nr),
          (ln = Nr))
      }
      if (
        (n &&
          Yr.forEach(function (zu) {
            return i(W, zu)
          }),
        hr())
      ) {
        var yo = qt
        Qs(W, yo)
      }
      return mt
    }
    function Ae(W, te, Y, me) {
      var Fe = Tn(Y)
      if (typeof Fe != 'function')
        throw new Error(
          'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'
        )
      {
        typeof Symbol == 'function' &&
          Y[Symbol.toStringTag] === 'Generator' &&
          (Cy ||
            l(
              'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.'
            ),
          (Cy = !0)),
          Y.entries === Fe &&
            (Ty ||
              l('Using Maps as children is not supported. Use an array of keyed ReactElements instead.'),
            (Ty = !0))
        var Ne = Fe.call(Y)
        if (Ne)
          for (var nt = null, mt = Ne.next(); !mt.done; mt = Ne.next()) {
            var ln = mt.value
            nt = Z(ln, nt, W)
          }
      }
      var Yt = Fe.call(Y)
      if (Yt == null) throw new Error('An iterable object provided no iterator.')
      for (
        var Vn = null, qt = null, Mn = te, Dr = 0, Er = 0, xi = null, Wr = Yt.next();
        Mn !== null && !Wr.done;
        Er++, Wr = Yt.next()
      ) {
        Mn.index > Er ? ((xi = Mn), (Mn = null)) : (xi = Mn.sibling)
        var Yr = j(W, Mn, Wr.value, me)
        if (Yr === null) {
          Mn === null && (Mn = xi)
          break
        }
        n && Mn && Yr.alternate === null && i(W, Mn),
          (Dr = m(Yr, Dr, Er)),
          qt === null ? (Vn = Yr) : (qt.sibling = Yr),
          (qt = Yr),
          (Mn = xi)
      }
      if (Wr.done) {
        if ((s(W, Mn), hr())) {
          var Nr = Er
          Qs(W, Nr)
        }
        return Vn
      }
      if (Mn === null) {
        for (; !Wr.done; Er++, Wr = Yt.next()) {
          var yo = U(W, Wr.value, me)
          yo !== null && ((Dr = m(yo, Dr, Er)), qt === null ? (Vn = yo) : (qt.sibling = yo), (qt = yo))
        }
        if (hr()) {
          var zu = Er
          Qs(W, zu)
        }
        return Vn
      }
      for (var Dd = c(W, Mn); !Wr.done; Er++, Wr = Yt.next()) {
        var Pa = q(Dd, W, Er, Wr.value, me)
        Pa !== null &&
          (n && Pa.alternate !== null && Dd.delete(Pa.key === null ? Er : Pa.key),
          (Dr = m(Pa, Dr, Er)),
          qt === null ? (Vn = Pa) : (qt.sibling = Pa),
          (qt = Pa))
      }
      if (
        (n &&
          Dd.forEach(function (I6) {
            return i(W, I6)
          }),
        hr())
      ) {
        var P6 = Er
        Qs(W, P6)
      }
      return Vn
    }
    function Ze(W, te, Y, me) {
      if (te !== null && te.tag === C) {
        s(W, te.sibling)
        var Fe = f(te, Y)
        return (Fe.return = W), Fe
      }
      s(W, te)
      var Ne = SE(Y, W.mode, me)
      return (Ne.return = W), Ne
    }
    function We(W, te, Y, me) {
      for (var Fe = Y.key, Ne = te; Ne !== null; ) {
        if (Ne.key === Fe) {
          var nt = Y.type
          if (nt === P) {
            if (Ne.tag === _) {
              s(W, Ne.sibling)
              var mt = f(Ne, Y.props.children)
              return (mt.return = W), (mt._debugSource = Y._source), (mt._debugOwner = Y._owner), mt
            }
          } else if (
            Ne.elementType === nt ||
            K2(Ne, Y) ||
            (typeof nt == 'object' && nt !== null && nt.$$typeof === ke && zC(nt) === Ne.type)
          ) {
            s(W, Ne.sibling)
            var ln = f(Ne, Y.props)
            return (
              (ln.ref = Jf(W, Ne, Y)),
              (ln.return = W),
              (ln._debugSource = Y._source),
              (ln._debugOwner = Y._owner),
              ln
            )
          }
          s(W, Ne)
          break
        } else i(W, Ne)
        Ne = Ne.sibling
      }
      if (Y.type === P) {
        var Yt = us(Y.props.children, W.mode, me, Y.key)
        return (Yt.return = W), Yt
      } else {
        var Vn = xE(Y, W.mode, me)
        return (Vn.ref = Jf(W, te, Y)), (Vn.return = W), Vn
      }
    }
    function It(W, te, Y, me) {
      for (var Fe = Y.key, Ne = te; Ne !== null; ) {
        if (Ne.key === Fe)
          if (
            Ne.tag === E &&
            Ne.stateNode.containerInfo === Y.containerInfo &&
            Ne.stateNode.implementation === Y.implementation
          ) {
            s(W, Ne.sibling)
            var nt = f(Ne, Y.children || [])
            return (nt.return = W), nt
          } else {
            s(W, Ne)
            break
          }
        else i(W, Ne)
        Ne = Ne.sibling
      }
      var mt = TE(Y, W.mode, me)
      return (mt.return = W), mt
    }
    function Ot(W, te, Y, me) {
      var Fe = typeof Y == 'object' && Y !== null && Y.type === P && Y.key === null
      if ((Fe && (Y = Y.props.children), typeof Y == 'object' && Y !== null)) {
        switch (Y.$$typeof) {
          case Sn:
            return y(We(W, te, Y, me))
          case ir:
            return y(It(W, te, Y, me))
          case ke:
            var Ne = Y._payload,
              nt = Y._init
            return Ot(W, te, nt(Ne), me)
        }
        if (Zt(Y)) return ee(W, te, Y, me)
        if (Tn(Y)) return Ae(W, te, Y, me)
        om(W, Y)
      }
      return (typeof Y == 'string' && Y !== '') || typeof Y == 'number'
        ? y(Ze(W, te, '' + Y, me))
        : (typeof Y == 'function' && sm(W), s(W, te))
    }
    return Ot
  }
  var wu = HC(!0),
    WC = HC(!1)
  function f7(n, i) {
    if (n !== null && i.child !== n.child) throw new Error('Resuming work not yet implemented.')
    if (i.child !== null) {
      var s = i.child,
        c = fl(s, s.pendingProps)
      for (i.child = c, c.return = i; s.sibling !== null; )
        (s = s.sibling), (c = c.sibling = fl(s, s.pendingProps)), (c.return = i)
      c.sibling = null
    }
  }
  function d7(n, i) {
    for (var s = n.child; s !== null; ) JF(s, i), (s = s.sibling)
  }
  var Oy = Ko(null),
    ky
  ky = {}
  var lm = null,
    Ru = null,
    Ay = null,
    um = !1
  function cm() {
    ;(lm = null), (Ru = null), (Ay = null), (um = !1)
  }
  function YC() {
    um = !0
  }
  function qC() {
    um = !1
  }
  function GC(n, i, s) {
    kr(Oy, i._currentValue, n),
      (i._currentValue = s),
      i._currentRenderer !== void 0 &&
        i._currentRenderer !== null &&
        i._currentRenderer !== ky &&
        l(
          'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.'
        ),
      (i._currentRenderer = ky)
  }
  function Dy(n, i) {
    var s = Oy.current
    Or(Oy, i), (n._currentValue = s)
  }
  function Ny(n, i, s) {
    for (var c = n; c !== null; ) {
      var f = c.alternate
      if (
        (cu(c.childLanes, i)
          ? f !== null && !cu(f.childLanes, i) && (f.childLanes = Tt(f.childLanes, i))
          : ((c.childLanes = Tt(c.childLanes, i)), f !== null && (f.childLanes = Tt(f.childLanes, i))),
        c === s)
      )
        break
      c = c.return
    }
    c !== s &&
      l(
        'Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.'
      )
  }
  function h7(n, i, s) {
    p7(n, i, s)
  }
  function p7(n, i, s) {
    var c = n.child
    for (c !== null && (c.return = n); c !== null; ) {
      var f = void 0,
        m = c.dependencies
      if (m !== null) {
        f = c.child
        for (var y = m.firstContext; y !== null; ) {
          if (y.context === i) {
            if (c.tag === p) {
              var b = gf(s),
                S = fo(vn, b)
              S.tag = dm
              var O = c.updateQueue
              if (O !== null) {
                var N = O.shared,
                  U = N.pending
                U === null ? (S.next = S) : ((S.next = U.next), (U.next = S)), (N.pending = S)
              }
            }
            c.lanes = Tt(c.lanes, s)
            var j = c.alternate
            j !== null && (j.lanes = Tt(j.lanes, s)), Ny(c.return, s, n), (m.lanes = Tt(m.lanes, s))
            break
          }
          y = y.next
        }
      } else if (c.tag === D) f = c.type === n.type ? null : c.child
      else if (c.tag === ue) {
        var q = c.return
        if (q === null)
          throw new Error(
            'We just came from a parent so we must have had a parent. This is a bug in React.'
          )
        q.lanes = Tt(q.lanes, s)
        var Z = q.alternate
        Z !== null && (Z.lanes = Tt(Z.lanes, s)), Ny(q, s, n), (f = c.sibling)
      } else f = c.child
      if (f !== null) f.return = c
      else
        for (f = c; f !== null; ) {
          if (f === n) {
            f = null
            break
          }
          var ee = f.sibling
          if (ee !== null) {
            ;(ee.return = f.return), (f = ee)
            break
          }
          f = f.return
        }
      c = f
    }
  }
  function _u(n, i) {
    ;(lm = n), (Ru = null), (Ay = null)
    var s = n.dependencies
    if (s !== null) {
      var c = s.firstContext
      c !== null && (mi(s.lanes, i) && pd(), (s.firstContext = null))
    }
  }
  function Hn(n) {
    um &&
      l(
        'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
      )
    var i = n._currentValue
    if (Ay !== n) {
      var s = { context: n, memoizedValue: i, next: null }
      if (Ru === null) {
        if (lm === null)
          throw new Error(
            'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
          )
        ;(Ru = s), (lm.dependencies = { lanes: fe, firstContext: s })
      } else Ru = Ru.next = s
    }
    return i
  }
  var rl = null
  function My(n) {
    rl === null ? (rl = [n]) : rl.push(n)
  }
  function m7() {
    if (rl !== null) {
      for (var n = 0; n < rl.length; n++) {
        var i = rl[n],
          s = i.interleaved
        if (s !== null) {
          i.interleaved = null
          var c = s.next,
            f = i.pending
          if (f !== null) {
            var m = f.next
            ;(f.next = c), (s.next = m)
          }
          i.pending = s
        }
      }
      rl = null
    }
  }
  function KC(n, i, s, c) {
    var f = i.interleaved
    return (
      f === null ? ((s.next = s), My(i)) : ((s.next = f.next), (f.next = s)),
      (i.interleaved = s),
      fm(n, c)
    )
  }
  function v7(n, i, s, c) {
    var f = i.interleaved
    f === null ? ((s.next = s), My(i)) : ((s.next = f.next), (f.next = s)), (i.interleaved = s)
  }
  function g7(n, i, s, c) {
    var f = i.interleaved
    return (
      f === null ? ((s.next = s), My(i)) : ((s.next = f.next), (f.next = s)),
      (i.interleaved = s),
      fm(n, c)
    )
  }
  function ii(n, i) {
    return fm(n, i)
  }
  var y7 = fm
  function fm(n, i) {
    n.lanes = Tt(n.lanes, i)
    var s = n.alternate
    s !== null && (s.lanes = Tt(s.lanes, i)), s === null && (n.flags & (zn | eo)) !== et && W2(n)
    for (var c = n, f = n.return; f !== null; )
      (f.childLanes = Tt(f.childLanes, i)),
        (s = f.alternate),
        s !== null ? (s.childLanes = Tt(s.childLanes, i)) : (f.flags & (zn | eo)) !== et && W2(n),
        (c = f),
        (f = f.return)
    if (c.tag === g) {
      var m = c.stateNode
      return m
    } else return null
  }
  var ZC = 0,
    XC = 1,
    dm = 2,
    Ly = 3,
    hm = !1,
    Py,
    pm
  ;(Py = !1), (pm = null)
  function Iy(n) {
    var i = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: fe },
      effects: null
    }
    n.updateQueue = i
  }
  function QC(n, i) {
    var s = i.updateQueue,
      c = n.updateQueue
    if (s === c) {
      var f = {
        baseState: c.baseState,
        firstBaseUpdate: c.firstBaseUpdate,
        lastBaseUpdate: c.lastBaseUpdate,
        shared: c.shared,
        effects: c.effects
      }
      i.updateQueue = f
    }
  }
  function fo(n, i) {
    var s = { eventTime: n, lane: i, tag: ZC, payload: null, callback: null, next: null }
    return s
  }
  function Jo(n, i, s) {
    var c = n.updateQueue
    if (c === null) return null
    var f = c.shared
    if (
      (pm === f &&
        !Py &&
        (l(
          'An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.'
        ),
        (Py = !0)),
      vF())
    ) {
      var m = f.pending
      return m === null ? (i.next = i) : ((i.next = m.next), (m.next = i)), (f.pending = i), y7(n, s)
    } else return g7(n, f, i, s)
  }
  function mm(n, i, s) {
    var c = i.updateQueue
    if (c !== null) {
      var f = c.shared
      if (fT(s)) {
        var m = f.lanes
        m = hT(m, n.pendingLanes)
        var y = Tt(m, s)
        ;(f.lanes = y), O0(n, y)
      }
    }
  }
  function Fy(n, i) {
    var s = n.updateQueue,
      c = n.alternate
    if (c !== null) {
      var f = c.updateQueue
      if (s === f) {
        var m = null,
          y = null,
          b = s.firstBaseUpdate
        if (b !== null) {
          var S = b
          do {
            var O = {
              eventTime: S.eventTime,
              lane: S.lane,
              tag: S.tag,
              payload: S.payload,
              callback: S.callback,
              next: null
            }
            y === null ? (m = y = O) : ((y.next = O), (y = O)), (S = S.next)
          } while (S !== null)
          y === null ? (m = y = i) : ((y.next = i), (y = i))
        } else m = y = i
        ;(s = {
          baseState: f.baseState,
          firstBaseUpdate: m,
          lastBaseUpdate: y,
          shared: f.shared,
          effects: f.effects
        }),
          (n.updateQueue = s)
        return
      }
    }
    var N = s.lastBaseUpdate
    N === null ? (s.firstBaseUpdate = i) : (N.next = i), (s.lastBaseUpdate = i)
  }
  function b7(n, i, s, c, f, m) {
    switch (s.tag) {
      case XC: {
        var y = s.payload
        if (typeof y == 'function') {
          YC()
          var b = y.call(m, c, f)
          {
            if (n.mode & Nn) {
              sr(!0)
              try {
                y.call(m, c, f)
              } finally {
                sr(!1)
              }
            }
            qC()
          }
          return b
        }
        return y
      }
      case Ly:
        n.flags = (n.flags & ~$r) | Xt
      case ZC: {
        var S = s.payload,
          O
        if (typeof S == 'function') {
          YC(), (O = S.call(m, c, f))
          {
            if (n.mode & Nn) {
              sr(!0)
              try {
                S.call(m, c, f)
              } finally {
                sr(!1)
              }
            }
            qC()
          }
        } else O = S
        return O == null ? c : vt({}, c, O)
      }
      case dm:
        return (hm = !0), c
    }
    return c
  }
  function vm(n, i, s, c) {
    var f = n.updateQueue
    ;(hm = !1), (pm = f.shared)
    var m = f.firstBaseUpdate,
      y = f.lastBaseUpdate,
      b = f.shared.pending
    if (b !== null) {
      f.shared.pending = null
      var S = b,
        O = S.next
      ;(S.next = null), y === null ? (m = O) : (y.next = O), (y = S)
      var N = n.alternate
      if (N !== null) {
        var U = N.updateQueue,
          j = U.lastBaseUpdate
        j !== y && (j === null ? (U.firstBaseUpdate = O) : (j.next = O), (U.lastBaseUpdate = S))
      }
    }
    if (m !== null) {
      var q = f.baseState,
        Z = fe,
        ee = null,
        Ae = null,
        Ze = null,
        We = m
      do {
        var It = We.lane,
          Ot = We.eventTime
        if (cu(c, It)) {
          if (Ze !== null) {
            var te = {
              eventTime: Ot,
              lane: lr,
              tag: We.tag,
              payload: We.payload,
              callback: We.callback,
              next: null
            }
            Ze = Ze.next = te
          }
          q = b7(n, f, We, q, i, s)
          var Y = We.callback
          if (Y !== null && We.lane !== lr) {
            n.flags |= Kg
            var me = f.effects
            me === null ? (f.effects = [We]) : me.push(We)
          }
        } else {
          var W = {
            eventTime: Ot,
            lane: It,
            tag: We.tag,
            payload: We.payload,
            callback: We.callback,
            next: null
          }
          Ze === null ? ((Ae = Ze = W), (ee = q)) : (Ze = Ze.next = W), (Z = Tt(Z, It))
        }
        if (((We = We.next), We === null)) {
          if (((b = f.shared.pending), b === null)) break
          var Fe = b,
            Ne = Fe.next
          ;(Fe.next = null), (We = Ne), (f.lastBaseUpdate = Fe), (f.shared.pending = null)
        }
      } while (!0)
      Ze === null && (ee = q), (f.baseState = ee), (f.firstBaseUpdate = Ae), (f.lastBaseUpdate = Ze)
      var nt = f.shared.interleaved
      if (nt !== null) {
        var mt = nt
        do (Z = Tt(Z, mt.lane)), (mt = mt.next)
        while (mt !== nt)
      } else m === null && (f.shared.lanes = fe)
      Rd(Z), (n.lanes = Z), (n.memoizedState = q)
    }
    pm = null
  }
  function E7(n, i) {
    if (typeof n != 'function')
      throw new Error(
        'Invalid argument passed as callback. Expected a function. Instead ' + ('received: ' + n)
      )
    n.call(i)
  }
  function JC() {
    hm = !1
  }
  function gm() {
    return hm
  }
  function ew(n, i, s) {
    var c = i.effects
    if (((i.effects = null), c !== null))
      for (var f = 0; f < c.length; f++) {
        var m = c[f],
          y = m.callback
        y !== null && ((m.callback = null), E7(y, s))
      }
  }
  var ed = {},
    es = Ko(ed),
    td = Ko(ed),
    ym = Ko(ed)
  function bm(n) {
    if (n === ed)
      throw new Error(
        'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'
      )
    return n
  }
  function tw() {
    var n = bm(ym.current)
    return n
  }
  function Vy(n, i) {
    kr(ym, i, n), kr(td, n, n), kr(es, ed, n)
    var s = F5(i)
    Or(es, n), kr(es, s, n)
  }
  function Ou(n) {
    Or(es, n), Or(td, n), Or(ym, n)
  }
  function jy() {
    var n = bm(es.current)
    return n
  }
  function nw(n) {
    bm(ym.current)
    var i = bm(es.current),
      s = V5(i, n.type)
    i !== s && (kr(td, n, n), kr(es, s, n))
  }
  function Uy(n) {
    td.current === n && (Or(es, n), Or(td, n))
  }
  var x7 = 0,
    rw = 1,
    iw = 1,
    nd = 2,
    ta = Ko(x7)
  function $y(n, i) {
    return (n & i) !== 0
  }
  function ku(n) {
    return n & rw
  }
  function By(n, i) {
    return (n & rw) | i
  }
  function S7(n, i) {
    return n | i
  }
  function ts(n, i) {
    kr(ta, i, n)
  }
  function Au(n) {
    Or(ta, n)
  }
  function T7(n, i) {
    var s = n.memoizedState
    return s !== null ? s.dehydrated !== null : (n.memoizedProps, !0)
  }
  function Em(n) {
    for (var i = n; i !== null; ) {
      if (i.tag === F) {
        var s = i.memoizedState
        if (s !== null) {
          var c = s.dehydrated
          if (c === null || xC(c) || oy(c)) return i
        }
      } else if (i.tag === se && i.memoizedProps.revealOrder !== void 0) {
        var f = (i.flags & Xt) !== et
        if (f) return i
      } else if (i.child !== null) {
        ;(i.child.return = i), (i = i.child)
        continue
      }
      if (i === n) return null
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === n) return null
        i = i.return
      }
      ;(i.sibling.return = i.return), (i = i.sibling)
    }
    return null
  }
  var ai = 0,
    qn = 1,
    Oa = 2,
    Gn = 4,
    pr = 8,
    zy = []
  function Hy() {
    for (var n = 0; n < zy.length; n++) {
      var i = zy[n]
      i._workInProgressVersionPrimary = null
    }
    zy.length = 0
  }
  function C7(n, i) {
    var s = i._getVersion,
      c = s(i._source)
    n.mutableSourceEagerHydrationData == null
      ? (n.mutableSourceEagerHydrationData = [i, c])
      : n.mutableSourceEagerHydrationData.push(i, c)
  }
  var Pe = r.ReactCurrentDispatcher,
    rd = r.ReactCurrentBatchConfig,
    Wy,
    Du
  Wy = new Set()
  var il = fe,
    sn = null,
    Kn = null,
    Zn = null,
    xm = !1,
    id = !1,
    ad = 0,
    w7 = 0,
    R7 = 25,
    ie = null,
    Vi = null,
    ns = -1,
    Yy = !1
  function Jt() {
    {
      var n = ie
      Vi === null ? (Vi = [n]) : Vi.push(n)
    }
  }
  function Ce() {
    {
      var n = ie
      Vi !== null && (ns++, Vi[ns] !== n && _7(n))
    }
  }
  function Nu(n) {
    n != null &&
      !Zt(n) &&
      l(
        '%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.',
        ie,
        typeof n
      )
  }
  function _7(n) {
    {
      var i = bt(sn)
      if (!Wy.has(i) && (Wy.add(i), Vi !== null)) {
        for (var s = '', c = 30, f = 0; f <= ns; f++) {
          for (var m = Vi[f], y = f === ns ? n : m, b = f + 1 + '. ' + m; b.length < c; ) b += ' '
          ;(b +=
            y +
            `
`),
            (s += b)
        }
        l(
          `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
          i,
          s
        )
      }
    }
  }
  function Ar() {
    throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`)
  }
  function qy(n, i) {
    if (Yy) return !1
    if (i === null)
      return (
        l(
          '%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
          ie
        ),
        !1
      )
    n.length !== i.length &&
      l(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        ie,
        '[' + i.join(', ') + ']',
        '[' + n.join(', ') + ']'
      )
    for (var s = 0; s < i.length && s < n.length; s++) if (!yi(n[s], i[s])) return !1
    return !0
  }
  function Mu(n, i, s, c, f, m) {
    ;(il = m),
      (sn = i),
      (Vi = n !== null ? n._debugHookTypes : null),
      (ns = -1),
      (Yy = n !== null && n.type !== i.type),
      (i.memoizedState = null),
      (i.updateQueue = null),
      (i.lanes = fe),
      n !== null && n.memoizedState !== null
        ? (Pe.current = Rw)
        : Vi !== null
          ? (Pe.current = ww)
          : (Pe.current = Cw)
    var y = s(c, f)
    if (id) {
      var b = 0
      do {
        if (((id = !1), (ad = 0), b >= R7))
          throw new Error(
            'Too many re-renders. React limits the number of renders to prevent an infinite loop.'
          )
        ;(b += 1),
          (Yy = !1),
          (Kn = null),
          (Zn = null),
          (i.updateQueue = null),
          (ns = -1),
          (Pe.current = _w),
          (y = s(c, f))
      } while (id)
    }
    ;(Pe.current = Lm), (i._debugHookTypes = Vi)
    var S = Kn !== null && Kn.next !== null
    if (
      ((il = fe),
      (sn = null),
      (Kn = null),
      (Zn = null),
      (ie = null),
      (Vi = null),
      (ns = -1),
      n !== null &&
        (n.flags & no) !== (i.flags & no) &&
        (n.mode & Lt) !== Je &&
        l('Internal React error: Expected static flag was missing. Please notify the React team.'),
      (xm = !1),
      S)
    )
      throw new Error(
        'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
      )
    return y
  }
  function Lu() {
    var n = ad !== 0
    return (ad = 0), n
  }
  function aw(n, i, s) {
    ;(i.updateQueue = n.updateQueue),
      (i.mode & Ca) !== Je ? (i.flags &= ~(mp | to | Ki | jt)) : (i.flags &= ~(Ki | jt)),
      (n.lanes = Sp(n.lanes, s))
  }
  function ow() {
    if (((Pe.current = Lm), xm)) {
      for (var n = sn.memoizedState; n !== null; ) {
        var i = n.queue
        i !== null && (i.pending = null), (n = n.next)
      }
      xm = !1
    }
    ;(il = fe),
      (sn = null),
      (Kn = null),
      (Zn = null),
      (Vi = null),
      (ns = -1),
      (ie = null),
      (bw = !1),
      (id = !1),
      (ad = 0)
  }
  function ka() {
    var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
    return Zn === null ? (sn.memoizedState = Zn = n) : (Zn = Zn.next = n), Zn
  }
  function ji() {
    var n
    if (Kn === null) {
      var i = sn.alternate
      i !== null ? (n = i.memoizedState) : (n = null)
    } else n = Kn.next
    var s
    if ((Zn === null ? (s = sn.memoizedState) : (s = Zn.next), s !== null))
      (Zn = s), (s = Zn.next), (Kn = n)
    else {
      if (n === null) throw new Error('Rendered more hooks than during the previous render.')
      Kn = n
      var c = {
        memoizedState: Kn.memoizedState,
        baseState: Kn.baseState,
        baseQueue: Kn.baseQueue,
        queue: Kn.queue,
        next: null
      }
      Zn === null ? (sn.memoizedState = Zn = c) : (Zn = Zn.next = c)
    }
    return Zn
  }
  function sw() {
    return { lastEffect: null, stores: null }
  }
  function Gy(n, i) {
    return typeof i == 'function' ? i(n) : i
  }
  function Ky(n, i, s) {
    var c = ka(),
      f
    s !== void 0 ? (f = s(i)) : (f = i), (c.memoizedState = c.baseState = f)
    var m = {
      pending: null,
      interleaved: null,
      lanes: fe,
      dispatch: null,
      lastRenderedReducer: n,
      lastRenderedState: f
    }
    c.queue = m
    var y = (m.dispatch = D7.bind(null, sn, m))
    return [c.memoizedState, y]
  }
  function Zy(n, i, s) {
    var c = ji(),
      f = c.queue
    if (f === null)
      throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.')
    f.lastRenderedReducer = n
    var m = Kn,
      y = m.baseQueue,
      b = f.pending
    if (b !== null) {
      if (y !== null) {
        var S = y.next,
          O = b.next
        ;(y.next = O), (b.next = S)
      }
      m.baseQueue !== y &&
        l('Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.'),
        (m.baseQueue = y = b),
        (f.pending = null)
    }
    if (y !== null) {
      var N = y.next,
        U = m.baseState,
        j = null,
        q = null,
        Z = null,
        ee = N
      do {
        var Ae = ee.lane
        if (cu(il, Ae)) {
          if (Z !== null) {
            var We = {
              lane: lr,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }
            Z = Z.next = We
          }
          if (ee.hasEagerState) U = ee.eagerState
          else {
            var It = ee.action
            U = n(U, It)
          }
        } else {
          var Ze = {
            lane: Ae,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          }
          Z === null ? ((q = Z = Ze), (j = U)) : (Z = Z.next = Ze), (sn.lanes = Tt(sn.lanes, Ae)), Rd(Ae)
        }
        ee = ee.next
      } while (ee !== null && ee !== N)
      Z === null ? (j = U) : (Z.next = q),
        yi(U, c.memoizedState) || pd(),
        (c.memoizedState = U),
        (c.baseState = j),
        (c.baseQueue = Z),
        (f.lastRenderedState = U)
    }
    var Ot = f.interleaved
    if (Ot !== null) {
      var W = Ot
      do {
        var te = W.lane
        ;(sn.lanes = Tt(sn.lanes, te)), Rd(te), (W = W.next)
      } while (W !== Ot)
    } else y === null && (f.lanes = fe)
    var Y = f.dispatch
    return [c.memoizedState, Y]
  }
  function Xy(n, i, s) {
    var c = ji(),
      f = c.queue
    if (f === null)
      throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.')
    f.lastRenderedReducer = n
    var m = f.dispatch,
      y = f.pending,
      b = c.memoizedState
    if (y !== null) {
      f.pending = null
      var S = y.next,
        O = S
      do {
        var N = O.action
        ;(b = n(b, N)), (O = O.next)
      } while (O !== S)
      yi(b, c.memoizedState) || pd(),
        (c.memoizedState = b),
        c.baseQueue === null && (c.baseState = b),
        (f.lastRenderedState = b)
    }
    return [b, m]
  }
  function dZ(n, i, s) {}
  function hZ(n, i, s) {}
  function Qy(n, i, s) {
    var c = sn,
      f = ka(),
      m,
      y = hr()
    if (y) {
      if (s === void 0)
        throw new Error(
          'Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.'
        )
      ;(m = s()),
        Du ||
          (m !== s() &&
            (l('The result of getServerSnapshot should be cached to avoid an infinite loop'), (Du = !0)))
    } else {
      if (((m = i()), !Du)) {
        var b = i()
        yi(m, b) ||
          (l('The result of getSnapshot should be cached to avoid an infinite loop'), (Du = !0))
      }
      var S = Jm()
      if (S === null)
        throw new Error(
          'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
        )
      xp(S, il) || lw(c, i, m)
    }
    f.memoizedState = m
    var O = { value: m, getSnapshot: i }
    return (
      (f.queue = O),
      Rm(cw.bind(null, c, O, n), [n]),
      (c.flags |= Ki),
      od(qn | pr, uw.bind(null, c, O, m, i), void 0, null),
      m
    )
  }
  function Sm(n, i, s) {
    var c = sn,
      f = ji(),
      m = i()
    if (!Du) {
      var y = i()
      yi(m, y) || (l('The result of getSnapshot should be cached to avoid an infinite loop'), (Du = !0))
    }
    var b = f.memoizedState,
      S = !yi(b, m)
    S && ((f.memoizedState = m), pd())
    var O = f.queue
    if (
      (ld(cw.bind(null, c, O, n), [n]),
      O.getSnapshot !== i || S || (Zn !== null && Zn.memoizedState.tag & qn))
    ) {
      ;(c.flags |= Ki), od(qn | pr, uw.bind(null, c, O, m, i), void 0, null)
      var N = Jm()
      if (N === null)
        throw new Error(
          'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
        )
      xp(N, il) || lw(c, i, m)
    }
    return m
  }
  function lw(n, i, s) {
    n.flags |= pp
    var c = { getSnapshot: i, value: s },
      f = sn.updateQueue
    if (f === null) (f = sw()), (sn.updateQueue = f), (f.stores = [c])
    else {
      var m = f.stores
      m === null ? (f.stores = [c]) : m.push(c)
    }
  }
  function uw(n, i, s, c) {
    ;(i.value = s), (i.getSnapshot = c), fw(i) && dw(n)
  }
  function cw(n, i, s) {
    var c = function () {
      fw(i) && dw(n)
    }
    return s(c)
  }
  function fw(n) {
    var i = n.getSnapshot,
      s = n.value
    try {
      var c = i()
      return !yi(s, c)
    } catch {
      return !0
    }
  }
  function dw(n) {
    var i = ii(n, ct)
    i !== null && er(i, n, ct, vn)
  }
  function Tm(n) {
    var i = ka()
    typeof n == 'function' && (n = n()), (i.memoizedState = i.baseState = n)
    var s = {
      pending: null,
      interleaved: null,
      lanes: fe,
      dispatch: null,
      lastRenderedReducer: Gy,
      lastRenderedState: n
    }
    i.queue = s
    var c = (s.dispatch = N7.bind(null, sn, s))
    return [i.memoizedState, c]
  }
  function Jy(n) {
    return Zy(Gy)
  }
  function eb(n) {
    return Xy(Gy)
  }
  function od(n, i, s, c) {
    var f = { tag: n, create: i, destroy: s, deps: c, next: null },
      m = sn.updateQueue
    if (m === null) (m = sw()), (sn.updateQueue = m), (m.lastEffect = f.next = f)
    else {
      var y = m.lastEffect
      if (y === null) m.lastEffect = f.next = f
      else {
        var b = y.next
        ;(y.next = f), (f.next = b), (m.lastEffect = f)
      }
    }
    return f
  }
  function tb(n) {
    var i = ka()
    {
      var s = { current: n }
      return (i.memoizedState = s), s
    }
  }
  function Cm(n) {
    var i = ji()
    return i.memoizedState
  }
  function sd(n, i, s, c) {
    var f = ka(),
      m = c === void 0 ? null : c
    ;(sn.flags |= n), (f.memoizedState = od(qn | i, s, void 0, m))
  }
  function wm(n, i, s, c) {
    var f = ji(),
      m = c === void 0 ? null : c,
      y = void 0
    if (Kn !== null) {
      var b = Kn.memoizedState
      if (((y = b.destroy), m !== null)) {
        var S = b.deps
        if (qy(m, S)) {
          f.memoizedState = od(i, s, y, m)
          return
        }
      }
    }
    ;(sn.flags |= n), (f.memoizedState = od(qn | i, s, y, m))
  }
  function Rm(n, i) {
    return (sn.mode & Ca) !== Je ? sd(mp | Ki | Qg, pr, n, i) : sd(Ki | Qg, pr, n, i)
  }
  function ld(n, i) {
    return wm(Ki, pr, n, i)
  }
  function nb(n, i) {
    return sd(jt, Oa, n, i)
  }
  function _m(n, i) {
    return wm(jt, Oa, n, i)
  }
  function rb(n, i) {
    var s = jt
    return (s |= $s), (sn.mode & Ca) !== Je && (s |= to), sd(s, Gn, n, i)
  }
  function Om(n, i) {
    return wm(jt, Gn, n, i)
  }
  function hw(n, i) {
    if (typeof i == 'function') {
      var s = i,
        c = n()
      return (
        s(c),
        function () {
          s(null)
        }
      )
    } else if (i != null) {
      var f = i
      f.hasOwnProperty('current') ||
        l(
          'Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.',
          'an object with keys {' + Object.keys(f).join(', ') + '}'
        )
      var m = n()
      return (
        (f.current = m),
        function () {
          f.current = null
        }
      )
    }
  }
  function ib(n, i, s) {
    typeof i != 'function' &&
      l(
        'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
        i !== null ? typeof i : 'null'
      )
    var c = s != null ? s.concat([n]) : null,
      f = jt
    return (f |= $s), (sn.mode & Ca) !== Je && (f |= to), sd(f, Gn, hw.bind(null, i, n), c)
  }
  function km(n, i, s) {
    typeof i != 'function' &&
      l(
        'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
        i !== null ? typeof i : 'null'
      )
    var c = s != null ? s.concat([n]) : null
    return wm(jt, Gn, hw.bind(null, i, n), c)
  }
  function O7(n, i) {}
  var Am = O7
  function ab(n, i) {
    var s = ka(),
      c = i === void 0 ? null : i
    return (s.memoizedState = [n, c]), n
  }
  function Dm(n, i) {
    var s = ji(),
      c = i === void 0 ? null : i,
      f = s.memoizedState
    if (f !== null && c !== null) {
      var m = f[1]
      if (qy(c, m)) return f[0]
    }
    return (s.memoizedState = [n, c]), n
  }
  function ob(n, i) {
    var s = ka(),
      c = i === void 0 ? null : i,
      f = n()
    return (s.memoizedState = [f, c]), f
  }
  function Nm(n, i) {
    var s = ji(),
      c = i === void 0 ? null : i,
      f = s.memoizedState
    if (f !== null && c !== null) {
      var m = f[1]
      if (qy(c, m)) return f[0]
    }
    var y = n()
    return (s.memoizedState = [y, c]), y
  }
  function sb(n) {
    var i = ka()
    return (i.memoizedState = n), n
  }
  function pw(n) {
    var i = ji(),
      s = Kn,
      c = s.memoizedState
    return vw(i, c, n)
  }
  function mw(n) {
    var i = ji()
    if (Kn === null) return (i.memoizedState = n), n
    var s = Kn.memoizedState
    return vw(i, s, n)
  }
  function vw(n, i, s) {
    var c = !hL(il)
    if (c) {
      if (!yi(s, i)) {
        var f = dT()
        ;(sn.lanes = Tt(sn.lanes, f)), Rd(f), (n.baseState = !0)
      }
      return i
    } else return n.baseState && ((n.baseState = !1), pd()), (n.memoizedState = s), s
  }
  function k7(n, i, s) {
    var c = Xi()
    ur(SL(c, io)), n(!0)
    var f = rd.transition
    rd.transition = {}
    var m = rd.transition
    rd.transition._updatedFibers = new Set()
    try {
      n(!1), i()
    } finally {
      if ((ur(c), (rd.transition = f), f === null && m._updatedFibers)) {
        var y = m._updatedFibers.size
        y > 10 &&
          u(
            'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
          ),
          m._updatedFibers.clear()
      }
    }
  }
  function lb() {
    var n = Tm(!1),
      i = n[0],
      s = n[1],
      c = k7.bind(null, s),
      f = ka()
    return (f.memoizedState = c), [i, c]
  }
  function gw() {
    var n = Jy(),
      i = n[0],
      s = ji(),
      c = s.memoizedState
    return [i, c]
  }
  function yw() {
    var n = eb(),
      i = n[0],
      s = ji(),
      c = s.memoizedState
    return [i, c]
  }
  var bw = !1
  function A7() {
    return bw
  }
  function ub() {
    var n = ka(),
      i = Jm(),
      s = i.identifierPrefix,
      c
    if (hr()) {
      var f = qP()
      c = ':' + s + 'R' + f
      var m = ad++
      m > 0 && (c += 'H' + m.toString(32)), (c += ':')
    } else {
      var y = w7++
      c = ':' + s + 'r' + y.toString(32) + ':'
    }
    return (n.memoizedState = c), c
  }
  function Mm() {
    var n = ji(),
      i = n.memoizedState
    return i
  }
  function D7(n, i, s) {
    typeof arguments[3] == 'function' &&
      l(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      )
    var c = ss(n),
      f = { lane: c, action: s, hasEagerState: !1, eagerState: null, next: null }
    if (Ew(n)) xw(i, f)
    else {
      var m = KC(n, i, f, c)
      if (m !== null) {
        var y = Hr()
        er(m, n, c, y), Sw(m, i, c)
      }
    }
    Tw(n, c)
  }
  function N7(n, i, s) {
    typeof arguments[3] == 'function' &&
      l(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      )
    var c = ss(n),
      f = { lane: c, action: s, hasEagerState: !1, eagerState: null, next: null }
    if (Ew(n)) xw(i, f)
    else {
      var m = n.alternate
      if (n.lanes === fe && (m === null || m.lanes === fe)) {
        var y = i.lastRenderedReducer
        if (y !== null) {
          var b
          ;(b = Pe.current), (Pe.current = na)
          try {
            var S = i.lastRenderedState,
              O = y(S, s)
            if (((f.hasEagerState = !0), (f.eagerState = O), yi(O, S))) {
              v7(n, i, f, c)
              return
            }
          } catch {
          } finally {
            Pe.current = b
          }
        }
      }
      var N = KC(n, i, f, c)
      if (N !== null) {
        var U = Hr()
        er(N, n, c, U), Sw(N, i, c)
      }
    }
    Tw(n, c)
  }
  function Ew(n) {
    var i = n.alternate
    return n === sn || (i !== null && i === sn)
  }
  function xw(n, i) {
    id = xm = !0
    var s = n.pending
    s === null ? (i.next = i) : ((i.next = s.next), (s.next = i)), (n.pending = i)
  }
  function Sw(n, i, s) {
    if (fT(s)) {
      var c = i.lanes
      c = hT(c, n.pendingLanes)
      var f = Tt(c, s)
      ;(i.lanes = f), O0(n, f)
    }
  }
  function Tw(n, i, s) {
    r0(n, i)
  }
  var Lm = {
      readContext: Hn,
      useCallback: Ar,
      useContext: Ar,
      useEffect: Ar,
      useImperativeHandle: Ar,
      useInsertionEffect: Ar,
      useLayoutEffect: Ar,
      useMemo: Ar,
      useReducer: Ar,
      useRef: Ar,
      useState: Ar,
      useDebugValue: Ar,
      useDeferredValue: Ar,
      useTransition: Ar,
      useMutableSource: Ar,
      useSyncExternalStore: Ar,
      useId: Ar,
      unstable_isNewReconciler: ve
    },
    Cw = null,
    ww = null,
    Rw = null,
    _w = null,
    Aa = null,
    na = null,
    Pm = null
  {
    var cb = function () {
        l(
          'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
        )
      },
      ft = function () {
        l(
          'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks'
        )
      }
    ;(Cw = {
      readContext: function (n) {
        return Hn(n)
      },
      useCallback: function (n, i) {
        return (ie = 'useCallback'), Jt(), Nu(i), ab(n, i)
      },
      useContext: function (n) {
        return (ie = 'useContext'), Jt(), Hn(n)
      },
      useEffect: function (n, i) {
        return (ie = 'useEffect'), Jt(), Nu(i), Rm(n, i)
      },
      useImperativeHandle: function (n, i, s) {
        return (ie = 'useImperativeHandle'), Jt(), Nu(s), ib(n, i, s)
      },
      useInsertionEffect: function (n, i) {
        return (ie = 'useInsertionEffect'), Jt(), Nu(i), nb(n, i)
      },
      useLayoutEffect: function (n, i) {
        return (ie = 'useLayoutEffect'), Jt(), Nu(i), rb(n, i)
      },
      useMemo: function (n, i) {
        ;(ie = 'useMemo'), Jt(), Nu(i)
        var s = Pe.current
        Pe.current = Aa
        try {
          return ob(n, i)
        } finally {
          Pe.current = s
        }
      },
      useReducer: function (n, i, s) {
        ;(ie = 'useReducer'), Jt()
        var c = Pe.current
        Pe.current = Aa
        try {
          return Ky(n, i, s)
        } finally {
          Pe.current = c
        }
      },
      useRef: function (n) {
        return (ie = 'useRef'), Jt(), tb(n)
      },
      useState: function (n) {
        ;(ie = 'useState'), Jt()
        var i = Pe.current
        Pe.current = Aa
        try {
          return Tm(n)
        } finally {
          Pe.current = i
        }
      },
      useDebugValue: function (n, i) {
        return (ie = 'useDebugValue'), Jt(), void 0
      },
      useDeferredValue: function (n) {
        return (ie = 'useDeferredValue'), Jt(), sb(n)
      },
      useTransition: function () {
        return (ie = 'useTransition'), Jt(), lb()
      },
      useMutableSource: function (n, i, s) {
        return (ie = 'useMutableSource'), Jt(), void 0
      },
      useSyncExternalStore: function (n, i, s) {
        return (ie = 'useSyncExternalStore'), Jt(), Qy(n, i, s)
      },
      useId: function () {
        return (ie = 'useId'), Jt(), ub()
      },
      unstable_isNewReconciler: ve
    }),
      (ww = {
        readContext: function (n) {
          return Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), Ce(), ab(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), Ce(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), Ce(), Rm(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), Ce(), ib(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), Ce(), nb(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), Ce(), rb(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), Ce()
          var s = Pe.current
          Pe.current = Aa
          try {
            return ob(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), Ce()
          var c = Pe.current
          Pe.current = Aa
          try {
            return Ky(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), Ce(), tb(n)
        },
        useState: function (n) {
          ;(ie = 'useState'), Ce()
          var i = Pe.current
          Pe.current = Aa
          try {
            return Tm(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), Ce(), void 0
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), Ce(), sb(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), Ce(), lb()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), Ce(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), Ce(), Qy(n, i, s)
        },
        useId: function () {
          return (ie = 'useId'), Ce(), ub()
        },
        unstable_isNewReconciler: ve
      }),
      (Rw = {
        readContext: function (n) {
          return Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), Ce(), Dm(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), Ce(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), Ce(), ld(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), Ce(), km(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), Ce(), _m(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), Ce(), Om(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), Ce()
          var s = Pe.current
          Pe.current = na
          try {
            return Nm(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), Ce()
          var c = Pe.current
          Pe.current = na
          try {
            return Zy(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), Ce(), Cm()
        },
        useState: function (n) {
          ;(ie = 'useState'), Ce()
          var i = Pe.current
          Pe.current = na
          try {
            return Jy(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), Ce(), Am()
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), Ce(), pw(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), Ce(), gw()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), Ce(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), Ce(), Sm(n, i)
        },
        useId: function () {
          return (ie = 'useId'), Ce(), Mm()
        },
        unstable_isNewReconciler: ve
      }),
      (_w = {
        readContext: function (n) {
          return Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), Ce(), Dm(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), Ce(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), Ce(), ld(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), Ce(), km(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), Ce(), _m(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), Ce(), Om(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), Ce()
          var s = Pe.current
          Pe.current = Pm
          try {
            return Nm(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), Ce()
          var c = Pe.current
          Pe.current = Pm
          try {
            return Xy(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), Ce(), Cm()
        },
        useState: function (n) {
          ;(ie = 'useState'), Ce()
          var i = Pe.current
          Pe.current = Pm
          try {
            return eb(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), Ce(), Am()
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), Ce(), mw(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), Ce(), yw()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), Ce(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), Ce(), Sm(n, i)
        },
        useId: function () {
          return (ie = 'useId'), Ce(), Mm()
        },
        unstable_isNewReconciler: ve
      }),
      (Aa = {
        readContext: function (n) {
          return cb(), Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), ft(), Jt(), ab(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), ft(), Jt(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), ft(), Jt(), Rm(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), ft(), Jt(), ib(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), ft(), Jt(), nb(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), ft(), Jt(), rb(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), ft(), Jt()
          var s = Pe.current
          Pe.current = Aa
          try {
            return ob(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), ft(), Jt()
          var c = Pe.current
          Pe.current = Aa
          try {
            return Ky(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), ft(), Jt(), tb(n)
        },
        useState: function (n) {
          ;(ie = 'useState'), ft(), Jt()
          var i = Pe.current
          Pe.current = Aa
          try {
            return Tm(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), ft(), Jt(), void 0
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), ft(), Jt(), sb(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), ft(), Jt(), lb()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), ft(), Jt(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), ft(), Jt(), Qy(n, i, s)
        },
        useId: function () {
          return (ie = 'useId'), ft(), Jt(), ub()
        },
        unstable_isNewReconciler: ve
      }),
      (na = {
        readContext: function (n) {
          return cb(), Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), ft(), Ce(), Dm(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), ft(), Ce(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), ft(), Ce(), ld(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), ft(), Ce(), km(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), ft(), Ce(), _m(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), ft(), Ce(), Om(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), ft(), Ce()
          var s = Pe.current
          Pe.current = na
          try {
            return Nm(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), ft(), Ce()
          var c = Pe.current
          Pe.current = na
          try {
            return Zy(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), ft(), Ce(), Cm()
        },
        useState: function (n) {
          ;(ie = 'useState'), ft(), Ce()
          var i = Pe.current
          Pe.current = na
          try {
            return Jy(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), ft(), Ce(), Am()
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), ft(), Ce(), pw(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), ft(), Ce(), gw()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), ft(), Ce(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), ft(), Ce(), Sm(n, i)
        },
        useId: function () {
          return (ie = 'useId'), ft(), Ce(), Mm()
        },
        unstable_isNewReconciler: ve
      }),
      (Pm = {
        readContext: function (n) {
          return cb(), Hn(n)
        },
        useCallback: function (n, i) {
          return (ie = 'useCallback'), ft(), Ce(), Dm(n, i)
        },
        useContext: function (n) {
          return (ie = 'useContext'), ft(), Ce(), Hn(n)
        },
        useEffect: function (n, i) {
          return (ie = 'useEffect'), ft(), Ce(), ld(n, i)
        },
        useImperativeHandle: function (n, i, s) {
          return (ie = 'useImperativeHandle'), ft(), Ce(), km(n, i, s)
        },
        useInsertionEffect: function (n, i) {
          return (ie = 'useInsertionEffect'), ft(), Ce(), _m(n, i)
        },
        useLayoutEffect: function (n, i) {
          return (ie = 'useLayoutEffect'), ft(), Ce(), Om(n, i)
        },
        useMemo: function (n, i) {
          ;(ie = 'useMemo'), ft(), Ce()
          var s = Pe.current
          Pe.current = na
          try {
            return Nm(n, i)
          } finally {
            Pe.current = s
          }
        },
        useReducer: function (n, i, s) {
          ;(ie = 'useReducer'), ft(), Ce()
          var c = Pe.current
          Pe.current = na
          try {
            return Xy(n, i, s)
          } finally {
            Pe.current = c
          }
        },
        useRef: function (n) {
          return (ie = 'useRef'), ft(), Ce(), Cm()
        },
        useState: function (n) {
          ;(ie = 'useState'), ft(), Ce()
          var i = Pe.current
          Pe.current = na
          try {
            return eb(n)
          } finally {
            Pe.current = i
          }
        },
        useDebugValue: function (n, i) {
          return (ie = 'useDebugValue'), ft(), Ce(), Am()
        },
        useDeferredValue: function (n) {
          return (ie = 'useDeferredValue'), ft(), Ce(), mw(n)
        },
        useTransition: function () {
          return (ie = 'useTransition'), ft(), Ce(), yw()
        },
        useMutableSource: function (n, i, s) {
          return (ie = 'useMutableSource'), ft(), Ce(), void 0
        },
        useSyncExternalStore: function (n, i, s) {
          return (ie = 'useSyncExternalStore'), ft(), Ce(), Sm(n, i)
        },
        useId: function () {
          return (ie = 'useId'), ft(), Ce(), Mm()
        },
        unstable_isNewReconciler: ve
      })
  }
  var rs = t.unstable_now,
    Ow = 0,
    Im = -1,
    ud = -1,
    Fm = -1,
    fb = !1,
    Vm = !1
  function kw() {
    return fb
  }
  function M7() {
    Vm = !0
  }
  function L7() {
    ;(fb = !1), (Vm = !1)
  }
  function P7() {
    ;(fb = Vm), (Vm = !1)
  }
  function Aw() {
    return Ow
  }
  function Dw() {
    Ow = rs()
  }
  function db(n) {
    ;(ud = rs()), n.actualStartTime < 0 && (n.actualStartTime = rs())
  }
  function Nw(n) {
    ud = -1
  }
  function jm(n, i) {
    if (ud >= 0) {
      var s = rs() - ud
      ;(n.actualDuration += s), i && (n.selfBaseDuration = s), (ud = -1)
    }
  }
  function Da(n) {
    if (Im >= 0) {
      var i = rs() - Im
      Im = -1
      for (var s = n.return; s !== null; ) {
        switch (s.tag) {
          case g:
            var c = s.stateNode
            c.effectDuration += i
            return
          case L:
            var f = s.stateNode
            f.effectDuration += i
            return
        }
        s = s.return
      }
    }
  }
  function hb(n) {
    if (Fm >= 0) {
      var i = rs() - Fm
      Fm = -1
      for (var s = n.return; s !== null; ) {
        switch (s.tag) {
          case g:
            var c = s.stateNode
            c !== null && (c.passiveEffectDuration += i)
            return
          case L:
            var f = s.stateNode
            f !== null && (f.passiveEffectDuration += i)
            return
        }
        s = s.return
      }
    }
  }
  function Na() {
    Im = rs()
  }
  function pb() {
    Fm = rs()
  }
  function mb(n) {
    for (var i = n.child; i; ) (n.actualDuration += i.actualDuration), (i = i.sibling)
  }
  function ra(n, i) {
    if (n && n.defaultProps) {
      var s = vt({}, i),
        c = n.defaultProps
      for (var f in c) s[f] === void 0 && (s[f] = c[f])
      return s
    }
    return i
  }
  var vb = {},
    gb,
    yb,
    bb,
    Eb,
    xb,
    Mw,
    Um,
    Sb,
    Tb,
    Cb,
    cd
  {
    ;(gb = new Set()),
      (yb = new Set()),
      (bb = new Set()),
      (Eb = new Set()),
      (Sb = new Set()),
      (xb = new Set()),
      (Tb = new Set()),
      (Cb = new Set()),
      (cd = new Set())
    var Lw = new Set()
    ;(Um = function (n, i) {
      if (!(n === null || typeof n == 'function')) {
        var s = i + '_' + n
        Lw.has(s) ||
          (Lw.add(s),
          l(
            '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
            i,
            n
          ))
      }
    }),
      (Mw = function (n, i) {
        if (i === void 0) {
          var s = Bt(n) || 'Component'
          xb.has(s) ||
            (xb.add(s),
            l(
              '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
              s
            ))
        }
      }),
      Object.defineProperty(vb, '_processChildContext', {
        enumerable: !1,
        value: function () {
          throw new Error(
            "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."
          )
        }
      }),
      Object.freeze(vb)
  }
  function wb(n, i, s, c) {
    var f = n.memoizedState,
      m = s(c, f)
    {
      if (n.mode & Nn) {
        sr(!0)
        try {
          m = s(c, f)
        } finally {
          sr(!1)
        }
      }
      Mw(i, m)
    }
    var y = m == null ? f : vt({}, f, m)
    if (((n.memoizedState = y), n.lanes === fe)) {
      var b = n.updateQueue
      b.baseState = y
    }
  }
  var Rb = {
    isMounted: R3,
    enqueueSetState: function (n, i, s) {
      var c = nu(n),
        f = Hr(),
        m = ss(c),
        y = fo(f, m)
      ;(y.payload = i), s != null && (Um(s, 'setState'), (y.callback = s))
      var b = Jo(c, y, m)
      b !== null && (er(b, c, m, f), mm(b, c, m)), r0(c, m)
    },
    enqueueReplaceState: function (n, i, s) {
      var c = nu(n),
        f = Hr(),
        m = ss(c),
        y = fo(f, m)
      ;(y.tag = XC), (y.payload = i), s != null && (Um(s, 'replaceState'), (y.callback = s))
      var b = Jo(c, y, m)
      b !== null && (er(b, c, m, f), mm(b, c, m)), r0(c, m)
    },
    enqueueForceUpdate: function (n, i) {
      var s = nu(n),
        c = Hr(),
        f = ss(s),
        m = fo(c, f)
      ;(m.tag = dm), i != null && (Um(i, 'forceUpdate'), (m.callback = i))
      var y = Jo(s, m, f)
      y !== null && (er(y, s, f, c), mm(y, s, f)), rL(s, f)
    }
  }
  function Pw(n, i, s, c, f, m, y) {
    var b = n.stateNode
    if (typeof b.shouldComponentUpdate == 'function') {
      var S = b.shouldComponentUpdate(c, m, y)
      {
        if (n.mode & Nn) {
          sr(!0)
          try {
            S = b.shouldComponentUpdate(c, m, y)
          } finally {
            sr(!1)
          }
        }
        S === void 0 &&
          l(
            '%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.',
            Bt(i) || 'Component'
          )
      }
      return S
    }
    return i.prototype && i.prototype.isPureReactComponent ? !Nf(s, c) || !Nf(f, m) : !0
  }
  function I7(n, i, s) {
    var c = n.stateNode
    {
      var f = Bt(i) || 'Component',
        m = c.render
      m ||
        (i.prototype && typeof i.prototype.render == 'function'
          ? l(
              '%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
              f
            )
          : l(
              '%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
              f
            )),
        c.getInitialState &&
          !c.getInitialState.isReactClassApproved &&
          !c.state &&
          l(
            'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
            f
          ),
        c.getDefaultProps &&
          !c.getDefaultProps.isReactClassApproved &&
          l(
            'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
            f
          ),
        c.propTypes &&
          l(
            'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
            f
          ),
        c.contextType &&
          l(
            'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
            f
          ),
        i.childContextTypes &&
          !cd.has(i) &&
          (n.mode & Nn) === Je &&
          (cd.add(i),
          l(
            `%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`,
            f
          )),
        i.contextTypes &&
          !cd.has(i) &&
          (n.mode & Nn) === Je &&
          (cd.add(i),
          l(
            `%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`,
            f
          )),
        c.contextTypes &&
          l(
            'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
            f
          ),
        i.contextType &&
          i.contextTypes &&
          !Tb.has(i) &&
          (Tb.add(i),
          l(
            '%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
            f
          )),
        typeof c.componentShouldUpdate == 'function' &&
          l(
            '%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
            f
          ),
        i.prototype &&
          i.prototype.isPureReactComponent &&
          typeof c.shouldComponentUpdate < 'u' &&
          l(
            '%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
            Bt(i) || 'A pure component'
          ),
        typeof c.componentDidUnmount == 'function' &&
          l(
            '%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
            f
          ),
        typeof c.componentDidReceiveProps == 'function' &&
          l(
            '%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
            f
          ),
        typeof c.componentWillRecieveProps == 'function' &&
          l(
            '%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
            f
          ),
        typeof c.UNSAFE_componentWillRecieveProps == 'function' &&
          l(
            '%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
            f
          )
      var y = c.props !== s
      c.props !== void 0 &&
        y &&
        l(
          "%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          f,
          f
        ),
        c.defaultProps &&
          l(
            'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
            f,
            f
          ),
        typeof c.getSnapshotBeforeUpdate == 'function' &&
          typeof c.componentDidUpdate != 'function' &&
          !bb.has(i) &&
          (bb.add(i),
          l(
            '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
            Bt(i)
          )),
        typeof c.getDerivedStateFromProps == 'function' &&
          l(
            '%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
            f
          ),
        typeof c.getDerivedStateFromError == 'function' &&
          l(
            '%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
            f
          ),
        typeof i.getSnapshotBeforeUpdate == 'function' &&
          l(
            '%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
            f
          )
      var b = c.state
      b && (typeof b != 'object' || Zt(b)) && l('%s.state: must be set to an object or null', f),
        typeof c.getChildContext == 'function' &&
          typeof i.childContextTypes != 'object' &&
          l(
            '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
            f
          )
    }
  }
  function Iw(n, i) {
    ;(i.updater = Rb), (n.stateNode = i), x3(i, n), (i._reactInternalInstance = vb)
  }
  function Fw(n, i, s) {
    var c = !1,
      f = bi,
      m = bi,
      y = i.contextType
    if ('contextType' in i) {
      var b = y === null || (y !== void 0 && y.$$typeof === X && y._context === void 0)
      if (!b && !Cb.has(i)) {
        Cb.add(i)
        var S = ''
        y === void 0
          ? (S =
              ' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.')
          : typeof y != 'object'
            ? (S = ' However, it is set to a ' + typeof y + '.')
            : y.$$typeof === M
              ? (S = ' Did you accidentally pass the Context.Provider instead?')
              : y._context !== void 0
                ? (S = ' Did you accidentally pass the Context.Consumer instead?')
                : (S =
                    ' However, it is set to an object with keys {' + Object.keys(y).join(', ') + '}.'),
          l(
            '%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
            Bt(i) || 'Component',
            S
          )
      }
    }
    if (typeof y == 'object' && y !== null) m = Hn(y)
    else {
      f = Eu(n, i, !0)
      var O = i.contextTypes
      ;(c = O != null), (m = c ? xu(n, f) : bi)
    }
    var N = new i(s, m)
    if (n.mode & Nn) {
      sr(!0)
      try {
        N = new i(s, m)
      } finally {
        sr(!1)
      }
    }
    var U = (n.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null)
    Iw(n, N)
    {
      if (typeof i.getDerivedStateFromProps == 'function' && U === null) {
        var j = Bt(i) || 'Component'
        yb.has(j) ||
          (yb.add(j),
          l(
            '`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
            j,
            N.state === null ? 'null' : 'undefined',
            j
          ))
      }
      if (
        typeof i.getDerivedStateFromProps == 'function' ||
        typeof N.getSnapshotBeforeUpdate == 'function'
      ) {
        var q = null,
          Z = null,
          ee = null
        if (
          (typeof N.componentWillMount == 'function' &&
          N.componentWillMount.__suppressDeprecationWarning !== !0
            ? (q = 'componentWillMount')
            : typeof N.UNSAFE_componentWillMount == 'function' && (q = 'UNSAFE_componentWillMount'),
          typeof N.componentWillReceiveProps == 'function' &&
          N.componentWillReceiveProps.__suppressDeprecationWarning !== !0
            ? (Z = 'componentWillReceiveProps')
            : typeof N.UNSAFE_componentWillReceiveProps == 'function' &&
              (Z = 'UNSAFE_componentWillReceiveProps'),
          typeof N.componentWillUpdate == 'function' &&
          N.componentWillUpdate.__suppressDeprecationWarning !== !0
            ? (ee = 'componentWillUpdate')
            : typeof N.UNSAFE_componentWillUpdate == 'function' && (ee = 'UNSAFE_componentWillUpdate'),
          q !== null || Z !== null || ee !== null)
        ) {
          var Ae = Bt(i) || 'Component',
            Ze =
              typeof i.getDerivedStateFromProps == 'function'
                ? 'getDerivedStateFromProps()'
                : 'getSnapshotBeforeUpdate()'
          Eb.has(Ae) ||
            (Eb.add(Ae),
            l(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`,
              Ae,
              Ze,
              q !== null
                ? `
  ` + q
                : '',
              Z !== null
                ? `
  ` + Z
                : '',
              ee !== null
                ? `
  ` + ee
                : ''
            ))
        }
      }
    }
    return c && RC(n, f, m), N
  }
  function F7(n, i) {
    var s = i.state
    typeof i.componentWillMount == 'function' && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == 'function' && i.UNSAFE_componentWillMount(),
      s !== i.state &&
        (l(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          bt(n) || 'Component'
        ),
        Rb.enqueueReplaceState(i, i.state, null))
  }
  function Vw(n, i, s, c) {
    var f = i.state
    if (
      (typeof i.componentWillReceiveProps == 'function' && i.componentWillReceiveProps(s, c),
      typeof i.UNSAFE_componentWillReceiveProps == 'function' &&
        i.UNSAFE_componentWillReceiveProps(s, c),
      i.state !== f)
    ) {
      {
        var m = bt(n) || 'Component'
        gb.has(m) ||
          (gb.add(m),
          l(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            m
          ))
      }
      Rb.enqueueReplaceState(i, i.state, null)
    }
  }
  function _b(n, i, s, c) {
    I7(n, i, s)
    var f = n.stateNode
    ;(f.props = s), (f.state = n.memoizedState), (f.refs = {}), Iy(n)
    var m = i.contextType
    if (typeof m == 'object' && m !== null) f.context = Hn(m)
    else {
      var y = Eu(n, i, !0)
      f.context = xu(n, y)
    }
    {
      if (f.state === s) {
        var b = Bt(i) || 'Component'
        Sb.has(b) ||
          (Sb.add(b),
          l(
            "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
            b
          ))
      }
      n.mode & Nn && ea.recordLegacyContextWarning(n, f), ea.recordUnsafeLifecycleWarnings(n, f)
    }
    f.state = n.memoizedState
    var S = i.getDerivedStateFromProps
    if (
      (typeof S == 'function' && (wb(n, i, S, s), (f.state = n.memoizedState)),
      typeof i.getDerivedStateFromProps != 'function' &&
        typeof f.getSnapshotBeforeUpdate != 'function' &&
        (typeof f.UNSAFE_componentWillMount == 'function' ||
          typeof f.componentWillMount == 'function') &&
        (F7(n, f), vm(n, s, f, c), (f.state = n.memoizedState)),
      typeof f.componentDidMount == 'function')
    ) {
      var O = jt
      ;(O |= $s), (n.mode & Ca) !== Je && (O |= to), (n.flags |= O)
    }
  }
  function V7(n, i, s, c) {
    var f = n.stateNode,
      m = n.memoizedProps
    f.props = m
    var y = f.context,
      b = i.contextType,
      S = bi
    if (typeof b == 'object' && b !== null) S = Hn(b)
    else {
      var O = Eu(n, i, !0)
      S = xu(n, O)
    }
    var N = i.getDerivedStateFromProps,
      U = typeof N == 'function' || typeof f.getSnapshotBeforeUpdate == 'function'
    !U &&
      (typeof f.UNSAFE_componentWillReceiveProps == 'function' ||
        typeof f.componentWillReceiveProps == 'function') &&
      (m !== s || y !== S) &&
      Vw(n, f, s, S),
      JC()
    var j = n.memoizedState,
      q = (f.state = j)
    if ((vm(n, s, f, c), (q = n.memoizedState), m === s && j === q && !Xp() && !gm())) {
      if (typeof f.componentDidMount == 'function') {
        var Z = jt
        ;(Z |= $s), (n.mode & Ca) !== Je && (Z |= to), (n.flags |= Z)
      }
      return !1
    }
    typeof N == 'function' && (wb(n, i, N, s), (q = n.memoizedState))
    var ee = gm() || Pw(n, i, m, s, j, q, S)
    if (ee) {
      if (
        (!U &&
          (typeof f.UNSAFE_componentWillMount == 'function' ||
            typeof f.componentWillMount == 'function') &&
          (typeof f.componentWillMount == 'function' && f.componentWillMount(),
          typeof f.UNSAFE_componentWillMount == 'function' && f.UNSAFE_componentWillMount()),
        typeof f.componentDidMount == 'function')
      ) {
        var Ae = jt
        ;(Ae |= $s), (n.mode & Ca) !== Je && (Ae |= to), (n.flags |= Ae)
      }
    } else {
      if (typeof f.componentDidMount == 'function') {
        var Ze = jt
        ;(Ze |= $s), (n.mode & Ca) !== Je && (Ze |= to), (n.flags |= Ze)
      }
      ;(n.memoizedProps = s), (n.memoizedState = q)
    }
    return (f.props = s), (f.state = q), (f.context = S), ee
  }
  function j7(n, i, s, c, f) {
    var m = i.stateNode
    QC(n, i)
    var y = i.memoizedProps,
      b = i.type === i.elementType ? y : ra(i.type, y)
    m.props = b
    var S = i.pendingProps,
      O = m.context,
      N = s.contextType,
      U = bi
    if (typeof N == 'object' && N !== null) U = Hn(N)
    else {
      var j = Eu(i, s, !0)
      U = xu(i, j)
    }
    var q = s.getDerivedStateFromProps,
      Z = typeof q == 'function' || typeof m.getSnapshotBeforeUpdate == 'function'
    !Z &&
      (typeof m.UNSAFE_componentWillReceiveProps == 'function' ||
        typeof m.componentWillReceiveProps == 'function') &&
      (y !== S || O !== U) &&
      Vw(i, m, c, U),
      JC()
    var ee = i.memoizedState,
      Ae = (m.state = ee)
    if ((vm(i, c, m, f), (Ae = i.memoizedState), y === S && ee === Ae && !Xp() && !gm() && !Ke))
      return (
        typeof m.componentDidUpdate == 'function' &&
          (y !== n.memoizedProps || ee !== n.memoizedState) &&
          (i.flags |= jt),
        typeof m.getSnapshotBeforeUpdate == 'function' &&
          (y !== n.memoizedProps || ee !== n.memoizedState) &&
          (i.flags |= js),
        !1
      )
    typeof q == 'function' && (wb(i, s, q, c), (Ae = i.memoizedState))
    var Ze = gm() || Pw(i, s, b, c, ee, Ae, U) || Ke
    return (
      Ze
        ? (!Z &&
            (typeof m.UNSAFE_componentWillUpdate == 'function' ||
              typeof m.componentWillUpdate == 'function') &&
            (typeof m.componentWillUpdate == 'function' && m.componentWillUpdate(c, Ae, U),
            typeof m.UNSAFE_componentWillUpdate == 'function' && m.UNSAFE_componentWillUpdate(c, Ae, U)),
          typeof m.componentDidUpdate == 'function' && (i.flags |= jt),
          typeof m.getSnapshotBeforeUpdate == 'function' && (i.flags |= js))
        : (typeof m.componentDidUpdate == 'function' &&
            (y !== n.memoizedProps || ee !== n.memoizedState) &&
            (i.flags |= jt),
          typeof m.getSnapshotBeforeUpdate == 'function' &&
            (y !== n.memoizedProps || ee !== n.memoizedState) &&
            (i.flags |= js),
          (i.memoizedProps = c),
          (i.memoizedState = Ae)),
      (m.props = c),
      (m.state = Ae),
      (m.context = U),
      Ze
    )
  }
  function al(n, i) {
    return { value: n, source: i, stack: Zc(i), digest: null }
  }
  function Ob(n, i, s) {
    return { value: n, source: null, stack: s ?? null, digest: i ?? null }
  }
  function U7(n, i) {
    return !0
  }
  function kb(n, i) {
    try {
      var s = U7(n, i)
      if (s === !1) return
      var c = i.value,
        f = i.source,
        m = i.stack,
        y = m !== null ? m : ''
      if (c != null && c._suppressLogging) {
        if (n.tag === p) return
        console.error(c)
      }
      var b = f ? bt(f) : null,
        S = b
          ? 'The above error occurred in the <' + b + '> component:'
          : 'The above error occurred in one of your React components:',
        O
      if (n.tag === g)
        O = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`
      else {
        var N = bt(n) || 'Anonymous'
        O =
          'React will try to recreate this component tree from scratch ' +
          ('using the error boundary you provided, ' + N + '.')
      }
      var U =
        S +
        `
` +
        y +
        `

` +
        ('' + O)
      console.error(U)
    } catch (j) {
      setTimeout(function () {
        throw j
      })
    }
  }
  var $7 = typeof WeakMap == 'function' ? WeakMap : Map
  function jw(n, i, s) {
    var c = fo(vn, s)
    ;(c.tag = Ly), (c.payload = { element: null })
    var f = i.value
    return (
      (c.callback = function () {
        MF(f), kb(n, i)
      }),
      c
    )
  }
  function Ab(n, i, s) {
    var c = fo(vn, s)
    c.tag = Ly
    var f = n.type.getDerivedStateFromError
    if (typeof f == 'function') {
      var m = i.value
      ;(c.payload = function () {
        return f(m)
      }),
        (c.callback = function () {
          Z2(n), kb(n, i)
        })
    }
    var y = n.stateNode
    return (
      y !== null &&
        typeof y.componentDidCatch == 'function' &&
        (c.callback = function () {
          Z2(n), kb(n, i), typeof f != 'function' && DF(this)
          var S = i.value,
            O = i.stack
          this.componentDidCatch(S, { componentStack: O !== null ? O : '' }),
            typeof f != 'function' &&
              (mi(n.lanes, ct) ||
                l(
                  '%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.',
                  bt(n) || 'Unknown'
                ))
        }),
      c
    )
  }
  function Uw(n, i, s) {
    var c = n.pingCache,
      f
    if (
      (c === null
        ? ((c = n.pingCache = new $7()), (f = new Set()), c.set(i, f))
        : ((f = c.get(i)), f === void 0 && ((f = new Set()), c.set(i, f))),
      !f.has(s))
    ) {
      f.add(s)
      var m = LF.bind(null, n, i, s)
      Zi && _d(n, s), i.then(m, m)
    }
  }
  function B7(n, i, s, c) {
    var f = n.updateQueue
    if (f === null) {
      var m = new Set()
      m.add(s), (n.updateQueue = m)
    } else f.add(s)
  }
  function z7(n, i) {
    var s = n.tag
    if ((n.mode & Lt) === Je && (s === h || s === A || s === H)) {
      var c = n.alternate
      c
        ? ((n.updateQueue = c.updateQueue), (n.memoizedState = c.memoizedState), (n.lanes = c.lanes))
        : ((n.updateQueue = null), (n.memoizedState = null))
    }
  }
  function $w(n) {
    var i = n
    do {
      if (i.tag === F && T7(i)) return i
      i = i.return
    } while (i !== null)
    return null
  }
  function Bw(n, i, s, c, f) {
    if ((n.mode & Lt) === Je) {
      if (n === i) n.flags |= $r
      else {
        if (((n.flags |= Xt), (s.flags |= Zg), (s.flags &= ~(S3 | uf)), s.tag === p)) {
          var m = s.alternate
          if (m === null) s.tag = Q
          else {
            var y = fo(vn, ct)
            ;(y.tag = dm), Jo(s, y, ct)
          }
        }
        s.lanes = Tt(s.lanes, ct)
      }
      return n
    }
    return (n.flags |= $r), (n.lanes = f), n
  }
  function H7(n, i, s, c, f) {
    if (
      ((s.flags |= uf),
      Zi && _d(n, f),
      c !== null && typeof c == 'object' && typeof c.then == 'function')
    ) {
      var m = c
      z7(s), hr() && s.mode & Lt && MC()
      var y = $w(i)
      if (y !== null) {
        ;(y.flags &= ~Ja), Bw(y, i, s, n, f), y.mode & Lt && Uw(n, m, f), B7(y, n, m)
        return
      } else {
        if (!dL(f)) {
          Uw(n, m, f), uE()
          return
        }
        var b = new Error(
          'A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.'
        )
        c = b
      }
    } else if (hr() && s.mode & Lt) {
      MC()
      var S = $w(i)
      if (S !== null) {
        ;(S.flags & $r) === et && (S.flags |= Ja), Bw(S, i, s, n, f), Sy(al(c, s))
        return
      }
    }
    ;(c = al(c, s)), TF(c)
    var O = i
    do {
      switch (O.tag) {
        case g: {
          var N = c
          O.flags |= $r
          var U = gf(f)
          O.lanes = Tt(O.lanes, U)
          var j = jw(O, N, U)
          Fy(O, j)
          return
        }
        case p:
          var q = c,
            Z = O.type,
            ee = O.stateNode
          if (
            (O.flags & Xt) === et &&
            (typeof Z.getDerivedStateFromError == 'function' ||
              (ee !== null && typeof ee.componentDidCatch == 'function' && !$2(ee)))
          ) {
            O.flags |= $r
            var Ae = gf(f)
            O.lanes = Tt(O.lanes, Ae)
            var Ze = Ab(O, q, Ae)
            Fy(O, Ze)
            return
          }
          break
      }
      O = O.return
    } while (O !== null)
  }
  function W7() {
    return null
  }
  var fd = r.ReactCurrentOwner,
    ia = !1,
    Db,
    dd,
    Nb,
    Mb,
    Lb,
    ol,
    Pb,
    $m,
    hd
  ;(Db = {}), (dd = {}), (Nb = {}), (Mb = {}), (Lb = {}), (ol = !1), (Pb = {}), ($m = {}), (hd = {})
  function Br(n, i, s, c) {
    n === null ? (i.child = WC(i, null, s, c)) : (i.child = wu(i, n.child, s, c))
  }
  function Y7(n, i, s, c) {
    ;(i.child = wu(i, n.child, null, c)), (i.child = wu(i, null, s, c))
  }
  function zw(n, i, s, c, f) {
    if (i.type !== i.elementType) {
      var m = s.propTypes
      m && Qi(m, c, 'prop', Bt(s))
    }
    var y = s.render,
      b = i.ref,
      S,
      O
    _u(i, f), ff(i)
    {
      if (((fd.current = i), hi(!0), (S = Mu(n, i, y, c, b, f)), (O = Lu()), i.mode & Nn)) {
        sr(!0)
        try {
          ;(S = Mu(n, i, y, c, b, f)), (O = Lu())
        } finally {
          sr(!1)
        }
      }
      hi(!1)
    }
    return (
      ou(),
      n !== null && !ia
        ? (aw(n, i, f), ho(n, i, f))
        : (hr() && O && vy(i), (i.flags |= ru), Br(n, i, S, f), i.child)
    )
  }
  function Hw(n, i, s, c, f) {
    if (n === null) {
      var m = s.type
      if (XF(m) && s.compare === null && s.defaultProps === void 0) {
        var y = m
        return (y = Bu(m)), (i.tag = H), (i.type = y), Vb(i, m), Ww(n, i, y, c, f)
      }
      {
        var b = m.propTypes
        if ((b && Qi(b, c, 'prop', Bt(m)), s.defaultProps !== void 0)) {
          var S = Bt(m) || 'Unknown'
          hd[S] ||
            (l(
              '%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.',
              S
            ),
            (hd[S] = !0))
        }
      }
      var O = EE(s.type, null, c, i, i.mode, f)
      return (O.ref = i.ref), (O.return = i), (i.child = O), O
    }
    {
      var N = s.type,
        U = N.propTypes
      U && Qi(U, c, 'prop', Bt(N))
    }
    var j = n.child,
      q = Hb(n, f)
    if (!q) {
      var Z = j.memoizedProps,
        ee = s.compare
      if (((ee = ee !== null ? ee : Nf), ee(Z, c) && n.ref === i.ref)) return ho(n, i, f)
    }
    i.flags |= ru
    var Ae = fl(j, c)
    return (Ae.ref = i.ref), (Ae.return = i), (i.child = Ae), Ae
  }
  function Ww(n, i, s, c, f) {
    if (i.type !== i.elementType) {
      var m = i.elementType
      if (m.$$typeof === ke) {
        var y = m,
          b = y._payload,
          S = y._init
        try {
          m = S(b)
        } catch {
          m = null
        }
        var O = m && m.propTypes
        O && Qi(O, c, 'prop', Bt(m))
      }
    }
    if (n !== null) {
      var N = n.memoizedProps
      if (Nf(N, c) && n.ref === i.ref && i.type === n.type)
        if (((ia = !1), (i.pendingProps = c = N), Hb(n, f))) (n.flags & Zg) !== et && (ia = !0)
        else return (i.lanes = n.lanes), ho(n, i, f)
    }
    return Ib(n, i, s, c, f)
  }
  function Yw(n, i, s) {
    var c = i.pendingProps,
      f = c.children,
      m = n !== null ? n.memoizedState : null
    if (c.mode === 'hidden' || ot)
      if ((i.mode & Lt) === Je) {
        var y = { baseLanes: fe, cachePool: null, transitions: null }
        ;(i.memoizedState = y), ev(i, s)
      } else if (mi(s, pi)) {
        var U = { baseLanes: fe, cachePool: null, transitions: null }
        i.memoizedState = U
        var j = m !== null ? m.baseLanes : s
        ev(i, j)
      } else {
        var b = null,
          S
        if (m !== null) {
          var O = m.baseLanes
          S = Tt(O, s)
        } else S = s
        i.lanes = i.childLanes = pi
        var N = { baseLanes: S, cachePool: b, transitions: null }
        return (i.memoizedState = N), (i.updateQueue = null), ev(i, S), null
      }
    else {
      var q
      m !== null ? ((q = Tt(m.baseLanes, s)), (i.memoizedState = null)) : (q = s), ev(i, q)
    }
    return Br(n, i, f, s), i.child
  }
  function q7(n, i, s) {
    var c = i.pendingProps
    return Br(n, i, c, s), i.child
  }
  function G7(n, i, s) {
    var c = i.pendingProps.children
    return Br(n, i, c, s), i.child
  }
  function K7(n, i, s) {
    {
      i.flags |= jt
      {
        var c = i.stateNode
        ;(c.effectDuration = 0), (c.passiveEffectDuration = 0)
      }
    }
    var f = i.pendingProps,
      m = f.children
    return Br(n, i, m, s), i.child
  }
  function qw(n, i) {
    var s = i.ref
    ;((n === null && s !== null) || (n !== null && n.ref !== s)) && ((i.flags |= $o), (i.flags |= Xg))
  }
  function Ib(n, i, s, c, f) {
    if (i.type !== i.elementType) {
      var m = s.propTypes
      m && Qi(m, c, 'prop', Bt(s))
    }
    var y
    {
      var b = Eu(i, s, !0)
      y = xu(i, b)
    }
    var S, O
    _u(i, f), ff(i)
    {
      if (((fd.current = i), hi(!0), (S = Mu(n, i, s, c, y, f)), (O = Lu()), i.mode & Nn)) {
        sr(!0)
        try {
          ;(S = Mu(n, i, s, c, y, f)), (O = Lu())
        } finally {
          sr(!1)
        }
      }
      hi(!1)
    }
    return (
      ou(),
      n !== null && !ia
        ? (aw(n, i, f), ho(n, i, f))
        : (hr() && O && vy(i), (i.flags |= ru), Br(n, i, S, f), i.child)
    )
  }
  function Gw(n, i, s, c, f) {
    {
      switch (d6(i)) {
        case !1: {
          var m = i.stateNode,
            y = i.type,
            b = new y(i.memoizedProps, m.context),
            S = b.state
          m.updater.enqueueSetState(m, S, null)
          break
        }
        case !0: {
          ;(i.flags |= Xt), (i.flags |= $r)
          var O = new Error('Simulated error coming from DevTools'),
            N = gf(f)
          i.lanes = Tt(i.lanes, N)
          var U = Ab(i, al(O, i), N)
          Fy(i, U)
          break
        }
      }
      if (i.type !== i.elementType) {
        var j = s.propTypes
        j && Qi(j, c, 'prop', Bt(s))
      }
    }
    var q
    _a(s) ? ((q = !0), Jp(i)) : (q = !1), _u(i, f)
    var Z = i.stateNode,
      ee
    Z === null
      ? (zm(n, i), Fw(i, s, c), _b(i, s, c, f), (ee = !0))
      : n === null
        ? (ee = V7(i, s, c, f))
        : (ee = j7(n, i, s, c, f))
    var Ae = Fb(n, i, s, ee, q, f)
    {
      var Ze = i.stateNode
      ee &&
        Ze.props !== c &&
        (ol ||
          l(
            'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
            bt(i) || 'a component'
          ),
        (ol = !0))
    }
    return Ae
  }
  function Fb(n, i, s, c, f, m) {
    qw(n, i)
    var y = (i.flags & Xt) !== et
    if (!c && !y) return f && kC(i, s, !1), ho(n, i, m)
    var b = i.stateNode
    fd.current = i
    var S
    if (y && typeof s.getDerivedStateFromError != 'function') (S = null), Nw()
    else {
      ff(i)
      {
        if ((hi(!0), (S = b.render()), i.mode & Nn)) {
          sr(!0)
          try {
            b.render()
          } finally {
            sr(!1)
          }
        }
        hi(!1)
      }
      ou()
    }
    return (
      (i.flags |= ru),
      n !== null && y ? Y7(n, i, S, m) : Br(n, i, S, m),
      (i.memoizedState = b.state),
      f && kC(i, s, !0),
      i.child
    )
  }
  function Kw(n) {
    var i = n.stateNode
    i.pendingContext
      ? _C(n, i.pendingContext, i.pendingContext !== i.context)
      : i.context && _C(n, i.context, !1),
      Vy(n, i.containerInfo)
  }
  function Z7(n, i, s) {
    if ((Kw(i), n === null)) throw new Error('Should have a current fiber. This is a bug in React.')
    var c = i.pendingProps,
      f = i.memoizedState,
      m = f.element
    QC(n, i), vm(i, c, null, s)
    var y = i.memoizedState
    i.stateNode
    var b = y.element
    if (f.isDehydrated) {
      var S = {
          element: b,
          isDehydrated: !1,
          cache: y.cache,
          pendingSuspenseBoundaries: y.pendingSuspenseBoundaries,
          transitions: y.transitions
        },
        O = i.updateQueue
      if (((O.baseState = S), (i.memoizedState = S), i.flags & Ja)) {
        var N = al(
          new Error(
            'There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.'
          ),
          i
        )
        return Zw(n, i, b, s, N)
      } else if (b !== m) {
        var U = al(
          new Error(
            'This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.'
          ),
          i
        )
        return Zw(n, i, b, s, U)
      } else {
        JP(i)
        var j = WC(i, null, b, s)
        i.child = j
        for (var q = j; q; ) (q.flags = (q.flags & ~zn) | eo), (q = q.sibling)
      }
    } else {
      if ((Cu(), b === m)) return ho(n, i, s)
      Br(n, i, b, s)
    }
    return i.child
  }
  function Zw(n, i, s, c, f) {
    return Cu(), Sy(f), (i.flags |= Ja), Br(n, i, s, c), i.child
  }
  function X7(n, i, s) {
    nw(i), n === null && xy(i)
    var c = i.type,
      f = i.pendingProps,
      m = n !== null ? n.memoizedProps : null,
      y = f.children,
      b = ny(c, f)
    return b ? (y = null) : m !== null && ny(c, m) && (i.flags |= lf), qw(n, i), Br(n, i, y, s), i.child
  }
  function Q7(n, i) {
    return n === null && xy(i), null
  }
  function J7(n, i, s, c) {
    zm(n, i)
    var f = i.pendingProps,
      m = s,
      y = m._payload,
      b = m._init,
      S = b(y)
    i.type = S
    var O = (i.tag = QF(S)),
      N = ra(S, f),
      U
    switch (O) {
      case h:
        return Vb(i, S), (i.type = S = Bu(S)), (U = Ib(null, i, S, N, c)), U
      case p:
        return (i.type = S = pE(S)), (U = Gw(null, i, S, N, c)), U
      case A:
        return (i.type = S = mE(S)), (U = zw(null, i, S, N, c)), U
      case z: {
        if (i.type !== i.elementType) {
          var j = S.propTypes
          j && Qi(j, N, 'prop', Bt(S))
        }
        return (U = Hw(null, i, S, ra(S.type, N), c)), U
      }
    }
    var q = ''
    throw (
      (S !== null &&
        typeof S == 'object' &&
        S.$$typeof === ke &&
        (q = ' Did you wrap a component in React.lazy() more than once?'),
      new Error(
        'Element type is invalid. Received a promise that resolves to: ' +
          S +
          '. ' +
          ('Lazy element type must resolve to a class or function.' + q)
      ))
    )
  }
  function eI(n, i, s, c, f) {
    zm(n, i), (i.tag = p)
    var m
    return (
      _a(s) ? ((m = !0), Jp(i)) : (m = !1),
      _u(i, f),
      Fw(i, s, c),
      _b(i, s, c, f),
      Fb(null, i, s, !0, m, f)
    )
  }
  function tI(n, i, s, c) {
    zm(n, i)
    var f = i.pendingProps,
      m
    {
      var y = Eu(i, s, !1)
      m = xu(i, y)
    }
    _u(i, c)
    var b, S
    ff(i)
    {
      if (s.prototype && typeof s.prototype.render == 'function') {
        var O = Bt(s) || 'Unknown'
        Db[O] ||
          (l(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            O,
            O
          ),
          (Db[O] = !0))
      }
      i.mode & Nn && ea.recordLegacyContextWarning(i, null),
        hi(!0),
        (fd.current = i),
        (b = Mu(null, i, s, f, m, c)),
        (S = Lu()),
        hi(!1)
    }
    if (
      (ou(),
      (i.flags |= ru),
      typeof b == 'object' && b !== null && typeof b.render == 'function' && b.$$typeof === void 0)
    ) {
      var N = Bt(s) || 'Unknown'
      dd[N] ||
        (l(
          "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
          N,
          N,
          N
        ),
        (dd[N] = !0))
    }
    if (typeof b == 'object' && b !== null && typeof b.render == 'function' && b.$$typeof === void 0) {
      {
        var U = Bt(s) || 'Unknown'
        dd[U] ||
          (l(
            "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
            U,
            U,
            U
          ),
          (dd[U] = !0))
      }
      ;(i.tag = p), (i.memoizedState = null), (i.updateQueue = null)
      var j = !1
      return (
        _a(s) ? ((j = !0), Jp(i)) : (j = !1),
        (i.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null),
        Iy(i),
        Iw(i, b),
        _b(i, s, f, c),
        Fb(null, i, s, !0, j, c)
      )
    } else {
      if (((i.tag = h), i.mode & Nn)) {
        sr(!0)
        try {
          ;(b = Mu(null, i, s, f, m, c)), (S = Lu())
        } finally {
          sr(!1)
        }
      }
      return hr() && S && vy(i), Br(null, i, b, c), Vb(i, s), i.child
    }
  }
  function Vb(n, i) {
    {
      if (
        (i &&
          i.childContextTypes &&
          l(
            '%s(...): childContextTypes cannot be defined on a function component.',
            i.displayName || i.name || 'Component'
          ),
        n.ref !== null)
      ) {
        var s = '',
          c = Fo()
        c &&
          (s +=
            `

Check the render method of \`` +
            c +
            '`.')
        var f = c || '',
          m = n._debugSource
        m && (f = m.fileName + ':' + m.lineNumber),
          Lb[f] ||
            ((Lb[f] = !0),
            l(
              'Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s',
              s
            ))
      }
      if (i.defaultProps !== void 0) {
        var y = Bt(i) || 'Unknown'
        hd[y] ||
          (l(
            '%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.',
            y
          ),
          (hd[y] = !0))
      }
      if (typeof i.getDerivedStateFromProps == 'function') {
        var b = Bt(i) || 'Unknown'
        Mb[b] || (l('%s: Function components do not support getDerivedStateFromProps.', b), (Mb[b] = !0))
      }
      if (typeof i.contextType == 'object' && i.contextType !== null) {
        var S = Bt(i) || 'Unknown'
        Nb[S] || (l('%s: Function components do not support contextType.', S), (Nb[S] = !0))
      }
    }
  }
  var jb = { dehydrated: null, treeContext: null, retryLane: lr }
  function Ub(n) {
    return { baseLanes: n, cachePool: W7(), transitions: null }
  }
  function nI(n, i) {
    var s = null
    return { baseLanes: Tt(n.baseLanes, i), cachePool: s, transitions: n.transitions }
  }
  function rI(n, i, s, c) {
    if (i !== null) {
      var f = i.memoizedState
      if (f === null) return !1
    }
    return $y(n, nd)
  }
  function iI(n, i) {
    return Sp(n.childLanes, i)
  }
  function Xw(n, i, s) {
    var c = i.pendingProps
    h6(i) && (i.flags |= Xt)
    var f = ta.current,
      m = !1,
      y = (i.flags & Xt) !== et
    if (
      (y || rI(f, n)
        ? ((m = !0), (i.flags &= ~Xt))
        : (n === null || n.memoizedState !== null) && (f = S7(f, iw)),
      (f = ku(f)),
      ts(i, f),
      n === null)
    ) {
      xy(i)
      var b = i.memoizedState
      if (b !== null) {
        var S = b.dehydrated
        if (S !== null) return uI(i, S)
      }
      var O = c.children,
        N = c.fallback
      if (m) {
        var U = aI(i, O, N, s),
          j = i.child
        return (j.memoizedState = Ub(s)), (i.memoizedState = jb), U
      } else return $b(i, O)
    } else {
      var q = n.memoizedState
      if (q !== null) {
        var Z = q.dehydrated
        if (Z !== null) return cI(n, i, y, c, Z, q, s)
      }
      if (m) {
        var ee = c.fallback,
          Ae = c.children,
          Ze = sI(n, i, Ae, ee, s),
          We = i.child,
          It = n.child.memoizedState
        return (
          (We.memoizedState = It === null ? Ub(s) : nI(It, s)),
          (We.childLanes = iI(n, s)),
          (i.memoizedState = jb),
          Ze
        )
      } else {
        var Ot = c.children,
          W = oI(n, i, Ot, s)
        return (i.memoizedState = null), W
      }
    }
  }
  function $b(n, i, s) {
    var c = n.mode,
      f = { mode: 'visible', children: i },
      m = Bb(f, c)
    return (m.return = n), (n.child = m), m
  }
  function aI(n, i, s, c) {
    var f = n.mode,
      m = n.child,
      y = { mode: 'hidden', children: i },
      b,
      S
    return (
      (f & Lt) === Je && m !== null
        ? ((b = m),
          (b.childLanes = fe),
          (b.pendingProps = y),
          n.mode & on &&
            ((b.actualDuration = 0),
            (b.actualStartTime = -1),
            (b.selfBaseDuration = 0),
            (b.treeBaseDuration = 0)),
          (S = us(s, f, c, null)))
        : ((b = Bb(y, f)), (S = us(s, f, c, null))),
      (b.return = n),
      (S.return = n),
      (b.sibling = S),
      (n.child = b),
      S
    )
  }
  function Bb(n, i, s) {
    return Q2(n, i, fe, null)
  }
  function Qw(n, i) {
    return fl(n, i)
  }
  function oI(n, i, s, c) {
    var f = n.child,
      m = f.sibling,
      y = Qw(f, { mode: 'visible', children: s })
    if (((i.mode & Lt) === Je && (y.lanes = c), (y.return = i), (y.sibling = null), m !== null)) {
      var b = i.deletions
      b === null ? ((i.deletions = [m]), (i.flags |= Vs)) : b.push(m)
    }
    return (i.child = y), y
  }
  function sI(n, i, s, c, f) {
    var m = i.mode,
      y = n.child,
      b = y.sibling,
      S = { mode: 'hidden', children: s },
      O
    if ((m & Lt) === Je && i.child !== y) {
      var N = i.child
      ;(O = N),
        (O.childLanes = fe),
        (O.pendingProps = S),
        i.mode & on &&
          ((O.actualDuration = 0),
          (O.actualStartTime = -1),
          (O.selfBaseDuration = y.selfBaseDuration),
          (O.treeBaseDuration = y.treeBaseDuration)),
        (i.deletions = null)
    } else (O = Qw(y, S)), (O.subtreeFlags = y.subtreeFlags & no)
    var U
    return (
      b !== null ? (U = fl(b, c)) : ((U = us(c, m, f, null)), (U.flags |= zn)),
      (U.return = i),
      (O.return = i),
      (O.sibling = U),
      (i.child = O),
      U
    )
  }
  function Bm(n, i, s, c) {
    c !== null && Sy(c), wu(i, n.child, null, s)
    var f = i.pendingProps,
      m = f.children,
      y = $b(i, m)
    return (y.flags |= zn), (i.memoizedState = null), y
  }
  function lI(n, i, s, c, f) {
    var m = i.mode,
      y = { mode: 'visible', children: s },
      b = Bb(y, m),
      S = us(c, m, f, null)
    return (
      (S.flags |= zn),
      (b.return = i),
      (S.return = i),
      (b.sibling = S),
      (i.child = b),
      (i.mode & Lt) !== Je && wu(i, n.child, null, f),
      S
    )
  }
  function uI(n, i, s) {
    return (
      (n.mode & Lt) === Je
        ? (l(
            'Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.'
          ),
          (n.lanes = ct))
        : oy(i)
          ? (n.lanes = Hs)
          : (n.lanes = pi),
      null
    )
  }
  function cI(n, i, s, c, f, m, y) {
    if (s)
      if (i.flags & Ja) {
        i.flags &= ~Ja
        var W = Ob(
          new Error(
            'There was an error while hydrating this Suspense boundary. Switched to client rendering.'
          )
        )
        return Bm(n, i, y, W)
      } else {
        if (i.memoizedState !== null) return (i.child = n.child), (i.flags |= Xt), null
        var te = c.children,
          Y = c.fallback,
          me = lI(n, i, te, Y, y),
          Fe = i.child
        return (Fe.memoizedState = Ub(y)), (i.memoizedState = jb), me
      }
    else {
      if ((XP(), (i.mode & Lt) === Je)) return Bm(n, i, y, null)
      if (oy(f)) {
        var b, S, O
        {
          var N = pP(f)
          ;(b = N.digest), (S = N.message), (O = N.stack)
        }
        var U
        S
          ? (U = new Error(S))
          : (U = new Error(
              'The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.'
            ))
        var j = Ob(U, b, O)
        return Bm(n, i, y, j)
      }
      var q = mi(y, n.childLanes)
      if (ia || q) {
        var Z = Jm()
        if (Z !== null) {
          var ee = EL(Z, y)
          if (ee !== lr && ee !== m.retryLane) {
            m.retryLane = ee
            var Ae = vn
            ii(n, ee), er(Z, n, ee, Ae)
          }
        }
        uE()
        var Ze = Ob(
          new Error(
            'This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.'
          )
        )
        return Bm(n, i, y, Ze)
      } else if (xC(f)) {
        ;(i.flags |= Xt), (i.child = n.child)
        var We = PF.bind(null, n)
        return mP(f, We), null
      } else {
        e7(i, f, m.treeContext)
        var It = c.children,
          Ot = $b(i, It)
        return (Ot.flags |= eo), Ot
      }
    }
  }
  function Jw(n, i, s) {
    n.lanes = Tt(n.lanes, i)
    var c = n.alternate
    c !== null && (c.lanes = Tt(c.lanes, i)), Ny(n.return, i, s)
  }
  function fI(n, i, s) {
    for (var c = i; c !== null; ) {
      if (c.tag === F) {
        var f = c.memoizedState
        f !== null && Jw(c, s, n)
      } else if (c.tag === se) Jw(c, s, n)
      else if (c.child !== null) {
        ;(c.child.return = c), (c = c.child)
        continue
      }
      if (c === n) return
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === n) return
        c = c.return
      }
      ;(c.sibling.return = c.return), (c = c.sibling)
    }
  }
  function dI(n) {
    for (var i = n, s = null; i !== null; ) {
      var c = i.alternate
      c !== null && Em(c) === null && (s = i), (i = i.sibling)
    }
    return s
  }
  function hI(n) {
    if (n !== void 0 && n !== 'forwards' && n !== 'backwards' && n !== 'together' && !Pb[n])
      if (((Pb[n] = !0), typeof n == 'string'))
        switch (n.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards': {
            l(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
              n,
              n.toLowerCase()
            )
            break
          }
          case 'forward':
          case 'backward': {
            l(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
              n,
              n.toLowerCase()
            )
            break
          }
          default:
            l(
              '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
              n
            )
            break
        }
      else
        l(
          '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
          n
        )
  }
  function pI(n, i) {
    n !== void 0 &&
      !$m[n] &&
      (n !== 'collapsed' && n !== 'hidden'
        ? (($m[n] = !0),
          l(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            n
          ))
        : i !== 'forwards' &&
          i !== 'backwards' &&
          (($m[n] = !0),
          l(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            n
          )))
  }
  function e2(n, i) {
    {
      var s = Zt(n),
        c = !s && typeof Tn(n) == 'function'
      if (s || c) {
        var f = s ? 'array' : 'iterable'
        return (
          l(
            'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>',
            f,
            i,
            f
          ),
          !1
        )
      }
    }
    return !0
  }
  function mI(n, i) {
    if ((i === 'forwards' || i === 'backwards') && n !== void 0 && n !== null && n !== !1)
      if (Zt(n)) {
        for (var s = 0; s < n.length; s++) if (!e2(n[s], s)) return
      } else {
        var c = Tn(n)
        if (typeof c == 'function') {
          var f = c.call(n)
          if (f)
            for (var m = f.next(), y = 0; !m.done; m = f.next()) {
              if (!e2(m.value, y)) return
              y++
            }
        } else
          l(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            i
          )
      }
  }
  function zb(n, i, s, c, f) {
    var m = n.memoizedState
    m === null
      ? (n.memoizedState = {
          isBackwards: i,
          rendering: null,
          renderingStartTime: 0,
          last: c,
          tail: s,
          tailMode: f
        })
      : ((m.isBackwards = i),
        (m.rendering = null),
        (m.renderingStartTime = 0),
        (m.last = c),
        (m.tail = s),
        (m.tailMode = f))
  }
  function t2(n, i, s) {
    var c = i.pendingProps,
      f = c.revealOrder,
      m = c.tail,
      y = c.children
    hI(f), pI(m, f), mI(y, f), Br(n, i, y, s)
    var b = ta.current,
      S = $y(b, nd)
    if (S) (b = By(b, nd)), (i.flags |= Xt)
    else {
      var O = n !== null && (n.flags & Xt) !== et
      O && fI(i, i.child, s), (b = ku(b))
    }
    if ((ts(i, b), (i.mode & Lt) === Je)) i.memoizedState = null
    else
      switch (f) {
        case 'forwards': {
          var N = dI(i.child),
            U
          N === null ? ((U = i.child), (i.child = null)) : ((U = N.sibling), (N.sibling = null)),
            zb(i, !1, U, N, m)
          break
        }
        case 'backwards': {
          var j = null,
            q = i.child
          for (i.child = null; q !== null; ) {
            var Z = q.alternate
            if (Z !== null && Em(Z) === null) {
              i.child = q
              break
            }
            var ee = q.sibling
            ;(q.sibling = j), (j = q), (q = ee)
          }
          zb(i, !0, j, null, m)
          break
        }
        case 'together': {
          zb(i, !1, null, null, void 0)
          break
        }
        default:
          i.memoizedState = null
      }
    return i.child
  }
  function vI(n, i, s) {
    Vy(i, i.stateNode.containerInfo)
    var c = i.pendingProps
    return n === null ? (i.child = wu(i, null, c, s)) : Br(n, i, c, s), i.child
  }
  var n2 = !1
  function gI(n, i, s) {
    var c = i.type,
      f = c._context,
      m = i.pendingProps,
      y = i.memoizedProps,
      b = m.value
    {
      'value' in m ||
        n2 ||
        ((n2 = !0),
        l(
          'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?'
        ))
      var S = i.type.propTypes
      S && Qi(S, m, 'prop', 'Context.Provider')
    }
    if ((GC(i, f, b), y !== null)) {
      var O = y.value
      if (yi(O, b)) {
        if (y.children === m.children && !Xp()) return ho(n, i, s)
      } else h7(i, f, s)
    }
    var N = m.children
    return Br(n, i, N, s), i.child
  }
  var r2 = !1
  function yI(n, i, s) {
    var c = i.type
    c._context === void 0
      ? c !== c.Consumer &&
        (r2 ||
          ((r2 = !0),
          l(
            'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
          )))
      : (c = c._context)
    var f = i.pendingProps,
      m = f.children
    typeof m != 'function' &&
      l(
        "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
      ),
      _u(i, s)
    var y = Hn(c)
    ff(i)
    var b
    return (fd.current = i), hi(!0), (b = m(y)), hi(!1), ou(), (i.flags |= ru), Br(n, i, b, s), i.child
  }
  function pd() {
    ia = !0
  }
  function zm(n, i) {
    ;(i.mode & Lt) === Je && n !== null && ((n.alternate = null), (i.alternate = null), (i.flags |= zn))
  }
  function ho(n, i, s) {
    return (
      n !== null && (i.dependencies = n.dependencies),
      Nw(),
      Rd(i.lanes),
      mi(s, i.childLanes) ? (f7(n, i), i.child) : null
    )
  }
  function bI(n, i, s) {
    {
      var c = i.return
      if (c === null) throw new Error('Cannot swap the root fiber.')
      if (
        ((n.alternate = null),
        (i.alternate = null),
        (s.index = i.index),
        (s.sibling = i.sibling),
        (s.return = i.return),
        (s.ref = i.ref),
        i === c.child)
      )
        c.child = s
      else {
        var f = c.child
        if (f === null) throw new Error('Expected parent to have a child.')
        for (; f.sibling !== i; )
          if (((f = f.sibling), f === null)) throw new Error('Expected to find the previous sibling.')
        f.sibling = s
      }
      var m = c.deletions
      return m === null ? ((c.deletions = [n]), (c.flags |= Vs)) : m.push(n), (s.flags |= zn), s
    }
  }
  function Hb(n, i) {
    var s = n.lanes
    return !!mi(s, i)
  }
  function EI(n, i, s) {
    switch (i.tag) {
      case g:
        Kw(i), i.stateNode, Cu()
        break
      case x:
        nw(i)
        break
      case p: {
        var c = i.type
        _a(c) && Jp(i)
        break
      }
      case E:
        Vy(i, i.stateNode.containerInfo)
        break
      case D: {
        var f = i.memoizedProps.value,
          m = i.type._context
        GC(i, m, f)
        break
      }
      case L:
        {
          var y = mi(s, i.childLanes)
          y && (i.flags |= jt)
          {
            var b = i.stateNode
            ;(b.effectDuration = 0), (b.passiveEffectDuration = 0)
          }
        }
        break
      case F: {
        var S = i.memoizedState
        if (S !== null) {
          if (S.dehydrated !== null) return ts(i, ku(ta.current)), (i.flags |= Xt), null
          var O = i.child,
            N = O.childLanes
          if (mi(s, N)) return Xw(n, i, s)
          ts(i, ku(ta.current))
          var U = ho(n, i, s)
          return U !== null ? U.sibling : null
        } else ts(i, ku(ta.current))
        break
      }
      case se: {
        var j = (n.flags & Xt) !== et,
          q = mi(s, i.childLanes)
        if (j) {
          if (q) return t2(n, i, s)
          i.flags |= Xt
        }
        var Z = i.memoizedState
        if (
          (Z !== null && ((Z.rendering = null), (Z.tail = null), (Z.lastEffect = null)),
          ts(i, ta.current),
          q)
        )
          break
        return null
      }
      case he:
      case G:
        return (i.lanes = fe), Yw(n, i, s)
    }
    return ho(n, i, s)
  }
  function i2(n, i, s) {
    if (i._debugNeedsRemount && n !== null)
      return bI(n, i, EE(i.type, i.key, i.pendingProps, i._debugOwner || null, i.mode, i.lanes))
    if (n !== null) {
      var c = n.memoizedProps,
        f = i.pendingProps
      if (c !== f || Xp() || i.type !== n.type) ia = !0
      else {
        var m = Hb(n, s)
        if (!m && (i.flags & Xt) === et) return (ia = !1), EI(n, i, s)
        ;(n.flags & Zg) !== et ? (ia = !0) : (ia = !1)
      }
    } else if (((ia = !1), hr() && WP(i))) {
      var y = i.index,
        b = YP()
      NC(i, b, y)
    }
    switch (((i.lanes = fe), i.tag)) {
      case v:
        return tI(n, i, i.type, s)
      case $: {
        var S = i.elementType
        return J7(n, i, S, s)
      }
      case h: {
        var O = i.type,
          N = i.pendingProps,
          U = i.elementType === O ? N : ra(O, N)
        return Ib(n, i, O, U, s)
      }
      case p: {
        var j = i.type,
          q = i.pendingProps,
          Z = i.elementType === j ? q : ra(j, q)
        return Gw(n, i, j, Z, s)
      }
      case g:
        return Z7(n, i, s)
      case x:
        return X7(n, i, s)
      case C:
        return Q7(n, i)
      case F:
        return Xw(n, i, s)
      case E:
        return vI(n, i, s)
      case A: {
        var ee = i.type,
          Ae = i.pendingProps,
          Ze = i.elementType === ee ? Ae : ra(ee, Ae)
        return zw(n, i, ee, Ze, s)
      }
      case _:
        return q7(n, i, s)
      case k:
        return G7(n, i, s)
      case L:
        return K7(n, i, s)
      case D:
        return gI(n, i, s)
      case R:
        return yI(n, i, s)
      case z: {
        var We = i.type,
          It = i.pendingProps,
          Ot = ra(We, It)
        if (i.type !== i.elementType) {
          var W = We.propTypes
          W && Qi(W, Ot, 'prop', Bt(We))
        }
        return (Ot = ra(We.type, Ot)), Hw(n, i, We, Ot, s)
      }
      case H:
        return Ww(n, i, i.type, i.pendingProps, s)
      case Q: {
        var te = i.type,
          Y = i.pendingProps,
          me = i.elementType === te ? Y : ra(te, Y)
        return eI(n, i, te, me, s)
      }
      case se:
        return t2(n, i, s)
      case we:
        break
      case he:
        return Yw(n, i, s)
    }
    throw new Error(
      'Unknown unit of work tag (' +
        i.tag +
        '). This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function Pu(n) {
    n.flags |= jt
  }
  function a2(n) {
    ;(n.flags |= $o), (n.flags |= Xg)
  }
  var o2, Wb, s2, l2
  ;(o2 = function (n, i, s, c) {
    for (var f = i.child; f !== null; ) {
      if (f.tag === x || f.tag === C) B5(n, f.stateNode)
      else if (f.tag !== E) {
        if (f.child !== null) {
          ;(f.child.return = f), (f = f.child)
          continue
        }
      }
      if (f === i) return
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === i) return
        f = f.return
      }
      ;(f.sibling.return = f.return), (f = f.sibling)
    }
  }),
    (Wb = function (n, i) {}),
    (s2 = function (n, i, s, c, f) {
      var m = n.memoizedProps
      if (m !== c) {
        var y = i.stateNode,
          b = jy(),
          S = H5(y, s, m, c, f, b)
        ;(i.updateQueue = S), S && Pu(i)
      }
    }),
    (l2 = function (n, i, s, c) {
      s !== c && Pu(i)
    })
  function md(n, i) {
    if (!hr())
      switch (n.tailMode) {
        case 'hidden': {
          for (var s = n.tail, c = null; s !== null; ) s.alternate !== null && (c = s), (s = s.sibling)
          c === null ? (n.tail = null) : (c.sibling = null)
          break
        }
        case 'collapsed': {
          for (var f = n.tail, m = null; f !== null; ) f.alternate !== null && (m = f), (f = f.sibling)
          m === null
            ? !i && n.tail !== null
              ? (n.tail.sibling = null)
              : (n.tail = null)
            : (m.sibling = null)
          break
        }
      }
  }
  function mr(n) {
    var i = n.alternate !== null && n.alternate.child === n.child,
      s = fe,
      c = et
    if (i) {
      if ((n.mode & on) !== Je) {
        for (var S = n.selfBaseDuration, O = n.child; O !== null; )
          (s = Tt(s, Tt(O.lanes, O.childLanes))),
            (c |= O.subtreeFlags & no),
            (c |= O.flags & no),
            (S += O.treeBaseDuration),
            (O = O.sibling)
        n.treeBaseDuration = S
      } else
        for (var N = n.child; N !== null; )
          (s = Tt(s, Tt(N.lanes, N.childLanes))),
            (c |= N.subtreeFlags & no),
            (c |= N.flags & no),
            (N.return = n),
            (N = N.sibling)
      n.subtreeFlags |= c
    } else {
      if ((n.mode & on) !== Je) {
        for (var f = n.actualDuration, m = n.selfBaseDuration, y = n.child; y !== null; )
          (s = Tt(s, Tt(y.lanes, y.childLanes))),
            (c |= y.subtreeFlags),
            (c |= y.flags),
            (f += y.actualDuration),
            (m += y.treeBaseDuration),
            (y = y.sibling)
        ;(n.actualDuration = f), (n.treeBaseDuration = m)
      } else
        for (var b = n.child; b !== null; )
          (s = Tt(s, Tt(b.lanes, b.childLanes))),
            (c |= b.subtreeFlags),
            (c |= b.flags),
            (b.return = n),
            (b = b.sibling)
      n.subtreeFlags |= c
    }
    return (n.childLanes = s), i
  }
  function xI(n, i, s) {
    if (a7() && (i.mode & Lt) !== Je && (i.flags & Xt) === et)
      return jC(i), Cu(), (i.flags |= Ja | uf | $r), !1
    var c = im(i)
    if (s !== null && s.dehydrated !== null)
      if (n === null) {
        if (!c)
          throw new Error(
            'A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.'
          )
        if ((r7(i), mr(i), (i.mode & on) !== Je)) {
          var f = s !== null
          if (f) {
            var m = i.child
            m !== null && (i.treeBaseDuration -= m.treeBaseDuration)
          }
        }
        return !1
      } else {
        if (
          (Cu(),
          (i.flags & Xt) === et && (i.memoizedState = null),
          (i.flags |= jt),
          mr(i),
          (i.mode & on) !== Je)
        ) {
          var y = s !== null
          if (y) {
            var b = i.child
            b !== null && (i.treeBaseDuration -= b.treeBaseDuration)
          }
        }
        return !1
      }
    else return UC(), !0
  }
  function u2(n, i, s) {
    var c = i.pendingProps
    switch ((gy(i), i.tag)) {
      case v:
      case $:
      case H:
      case h:
      case A:
      case _:
      case k:
      case L:
      case R:
      case z:
        return mr(i), null
      case p: {
        var f = i.type
        return _a(f) && Qp(i), mr(i), null
      }
      case g: {
        var m = i.stateNode
        if (
          (Ou(i),
          hy(i),
          Hy(),
          m.pendingContext && ((m.context = m.pendingContext), (m.pendingContext = null)),
          n === null || n.child === null)
        ) {
          var y = im(i)
          if (y) Pu(i)
          else if (n !== null) {
            var b = n.memoizedState
            ;(!b.isDehydrated || (i.flags & Ja) !== et) && ((i.flags |= js), UC())
          }
        }
        return Wb(n, i), mr(i), null
      }
      case x: {
        Uy(i)
        var S = tw(),
          O = i.type
        if (n !== null && i.stateNode != null) s2(n, i, O, c, S), n.ref !== i.ref && a2(i)
        else {
          if (!c) {
            if (i.stateNode === null)
              throw new Error(
                'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
              )
            return mr(i), null
          }
          var N = jy(),
            U = im(i)
          if (U) t7(i, S, N) && Pu(i)
          else {
            var j = $5(O, c, S, N, i)
            o2(j, i, !1, !1), (i.stateNode = j), z5(j, O, c, S) && Pu(i)
          }
          i.ref !== null && a2(i)
        }
        return mr(i), null
      }
      case C: {
        var q = c
        if (n && i.stateNode != null) {
          var Z = n.memoizedProps
          l2(n, i, Z, q)
        } else {
          if (typeof q != 'string' && i.stateNode === null)
            throw new Error(
              'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
            )
          var ee = tw(),
            Ae = jy(),
            Ze = im(i)
          Ze ? n7(i) && Pu(i) : (i.stateNode = W5(q, ee, Ae, i))
        }
        return mr(i), null
      }
      case F: {
        Au(i)
        var We = i.memoizedState
        if (n === null || (n.memoizedState !== null && n.memoizedState.dehydrated !== null)) {
          var It = xI(n, i, We)
          if (!It) return i.flags & $r ? i : null
        }
        if ((i.flags & Xt) !== et) return (i.lanes = s), (i.mode & on) !== Je && mb(i), i
        var Ot = We !== null,
          W = n !== null && n.memoizedState !== null
        if (Ot !== W && Ot) {
          var te = i.child
          if (((te.flags |= Us), (i.mode & Lt) !== Je)) {
            var Y = n === null && (i.memoizedProps.unstable_avoidThisFallback !== !0 || !Me)
            Y || $y(ta.current, iw) ? SF() : uE()
          }
        }
        var me = i.updateQueue
        if ((me !== null && (i.flags |= jt), mr(i), (i.mode & on) !== Je && Ot)) {
          var Fe = i.child
          Fe !== null && (i.treeBaseDuration -= Fe.treeBaseDuration)
        }
        return null
      }
      case E:
        return Ou(i), Wb(n, i), n === null && VP(i.stateNode.containerInfo), mr(i), null
      case D:
        var Ne = i.type._context
        return Dy(Ne, i), mr(i), null
      case Q: {
        var nt = i.type
        return _a(nt) && Qp(i), mr(i), null
      }
      case se: {
        Au(i)
        var mt = i.memoizedState
        if (mt === null) return mr(i), null
        var ln = (i.flags & Xt) !== et,
          Yt = mt.rendering
        if (Yt === null)
          if (ln) md(mt, !1)
          else {
            var Vn = CF() && (n === null || (n.flags & Xt) === et)
            if (!Vn)
              for (var qt = i.child; qt !== null; ) {
                var Mn = Em(qt)
                if (Mn !== null) {
                  ;(ln = !0), (i.flags |= Xt), md(mt, !1)
                  var Dr = Mn.updateQueue
                  return (
                    Dr !== null && ((i.updateQueue = Dr), (i.flags |= jt)),
                    (i.subtreeFlags = et),
                    d7(i, s),
                    ts(i, By(ta.current, nd)),
                    i.child
                  )
                }
                qt = qt.sibling
              }
            mt.tail !== null && or() > A2() && ((i.flags |= Xt), (ln = !0), md(mt, !1), (i.lanes = lT))
          }
        else {
          if (!ln) {
            var Er = Em(Yt)
            if (Er !== null) {
              ;(i.flags |= Xt), (ln = !0)
              var xi = Er.updateQueue
              if (
                (xi !== null && ((i.updateQueue = xi), (i.flags |= jt)),
                md(mt, !0),
                mt.tail === null && mt.tailMode === 'hidden' && !Yt.alternate && !hr())
              )
                return mr(i), null
            } else
              or() * 2 - mt.renderingStartTime > A2() &&
                s !== pi &&
                ((i.flags |= Xt), (ln = !0), md(mt, !1), (i.lanes = lT))
          }
          if (mt.isBackwards) (Yt.sibling = i.child), (i.child = Yt)
          else {
            var Wr = mt.last
            Wr !== null ? (Wr.sibling = Yt) : (i.child = Yt), (mt.last = Yt)
          }
        }
        if (mt.tail !== null) {
          var Yr = mt.tail
          ;(mt.rendering = Yr),
            (mt.tail = Yr.sibling),
            (mt.renderingStartTime = or()),
            (Yr.sibling = null)
          var Nr = ta.current
          return ln ? (Nr = By(Nr, nd)) : (Nr = ku(Nr)), ts(i, Nr), Yr
        }
        return mr(i), null
      }
      case we:
        break
      case he:
      case G: {
        lE(i)
        var yo = i.memoizedState,
          zu = yo !== null
        if (n !== null) {
          var Dd = n.memoizedState,
            Pa = Dd !== null
          Pa !== zu && !ot && (i.flags |= Us)
        }
        return (
          !zu || (i.mode & Lt) === Je
            ? mr(i)
            : mi(La, pi) && (mr(i), i.subtreeFlags & (zn | jt) && (i.flags |= Us)),
          null
        )
      }
      case ge:
        return null
      case De:
        return null
    }
    throw new Error(
      'Unknown unit of work tag (' +
        i.tag +
        '). This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function SI(n, i, s) {
    switch ((gy(i), i.tag)) {
      case p: {
        var c = i.type
        _a(c) && Qp(i)
        var f = i.flags
        return f & $r ? ((i.flags = (f & ~$r) | Xt), (i.mode & on) !== Je && mb(i), i) : null
      }
      case g: {
        i.stateNode, Ou(i), hy(i), Hy()
        var m = i.flags
        return (m & $r) !== et && (m & Xt) === et ? ((i.flags = (m & ~$r) | Xt), i) : null
      }
      case x:
        return Uy(i), null
      case F: {
        Au(i)
        var y = i.memoizedState
        if (y !== null && y.dehydrated !== null) {
          if (i.alternate === null)
            throw new Error(
              'Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.'
            )
          Cu()
        }
        var b = i.flags
        return b & $r ? ((i.flags = (b & ~$r) | Xt), (i.mode & on) !== Je && mb(i), i) : null
      }
      case se:
        return Au(i), null
      case E:
        return Ou(i), null
      case D:
        var S = i.type._context
        return Dy(S, i), null
      case he:
      case G:
        return lE(i), null
      case ge:
        return null
      default:
        return null
    }
  }
  function c2(n, i, s) {
    switch ((gy(i), i.tag)) {
      case p: {
        var c = i.type.childContextTypes
        c != null && Qp(i)
        break
      }
      case g: {
        i.stateNode, Ou(i), hy(i), Hy()
        break
      }
      case x: {
        Uy(i)
        break
      }
      case E:
        Ou(i)
        break
      case F:
        Au(i)
        break
      case se:
        Au(i)
        break
      case D:
        var f = i.type._context
        Dy(f, i)
        break
      case he:
      case G:
        lE(i)
        break
    }
  }
  var f2 = null
  f2 = new Set()
  var Hm = !1,
    vr = !1,
    TI = typeof WeakSet == 'function' ? WeakSet : Set,
    je = null,
    Iu = null,
    Fu = null
  function CI(n) {
    qg(null, function () {
      throw n
    }),
      Gg()
  }
  var wI = function (n, i) {
    if (((i.props = n.memoizedProps), (i.state = n.memoizedState), n.mode & on))
      try {
        Na(), i.componentWillUnmount()
      } finally {
        Da(n)
      }
    else i.componentWillUnmount()
  }
  function d2(n, i) {
    try {
      is(Gn, n)
    } catch (s) {
      pn(n, i, s)
    }
  }
  function Yb(n, i, s) {
    try {
      wI(n, s)
    } catch (c) {
      pn(n, i, c)
    }
  }
  function RI(n, i, s) {
    try {
      s.componentDidMount()
    } catch (c) {
      pn(n, i, c)
    }
  }
  function h2(n, i) {
    try {
      m2(n)
    } catch (s) {
      pn(n, i, s)
    }
  }
  function Vu(n, i) {
    var s = n.ref
    if (s !== null)
      if (typeof s == 'function') {
        var c
        try {
          if (kt && yt && n.mode & on)
            try {
              Na(), (c = s(null))
            } finally {
              Da(n)
            }
          else c = s(null)
        } catch (f) {
          pn(n, i, f)
        }
        typeof c == 'function' &&
          l(
            'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
            bt(n)
          )
      } else s.current = null
  }
  function Wm(n, i, s) {
    try {
      s()
    } catch (c) {
      pn(n, i, c)
    }
  }
  var p2 = !1
  function _I(n, i) {
    j5(n.containerInfo), (je = i), OI()
    var s = p2
    return (p2 = !1), s
  }
  function OI() {
    for (; je !== null; ) {
      var n = je,
        i = n.child
      ;(n.subtreeFlags & Jg) !== et && i !== null ? ((i.return = n), (je = i)) : kI()
    }
  }
  function kI() {
    for (; je !== null; ) {
      var n = je
      Rn(n)
      try {
        AI(n)
      } catch (s) {
        pn(n, n.return, s)
      }
      ar()
      var i = n.sibling
      if (i !== null) {
        ;(i.return = n.return), (je = i)
        return
      }
      je = n.return
    }
  }
  function AI(n) {
    var i = n.alternate,
      s = n.flags
    if ((s & js) !== et) {
      switch ((Rn(n), n.tag)) {
        case h:
        case A:
        case H:
          break
        case p: {
          if (i !== null) {
            var c = i.memoizedProps,
              f = i.memoizedState,
              m = n.stateNode
            n.type === n.elementType &&
              !ol &&
              (m.props !== n.memoizedProps &&
                l(
                  'Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                  bt(n) || 'instance'
                ),
              m.state !== n.memoizedState &&
                l(
                  'Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                  bt(n) || 'instance'
                ))
            var y = m.getSnapshotBeforeUpdate(n.elementType === n.type ? c : ra(n.type, c), f)
            {
              var b = f2
              y === void 0 &&
                !b.has(n.type) &&
                (b.add(n.type),
                l(
                  '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.',
                  bt(n)
                ))
            }
            m.__reactInternalSnapshotBeforeUpdate = y
          }
          break
        }
        case g: {
          {
            var S = n.stateNode
            cP(S.containerInfo)
          }
          break
        }
        case x:
        case C:
        case E:
        case Q:
          break
        default:
          throw new Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          )
      }
      ar()
    }
  }
  function aa(n, i, s) {
    var c = i.updateQueue,
      f = c !== null ? c.lastEffect : null
    if (f !== null) {
      var m = f.next,
        y = m
      do {
        if ((y.tag & n) === n) {
          var b = y.destroy
          ;(y.destroy = void 0),
            b !== void 0 &&
              ((n & pr) !== ai ? W3(i) : (n & Gn) !== ai && rT(i),
              (n & Oa) !== ai && Od(!0),
              Wm(i, s, b),
              (n & Oa) !== ai && Od(!1),
              (n & pr) !== ai ? Y3() : (n & Gn) !== ai && iT())
        }
        y = y.next
      } while (y !== m)
    }
  }
  function is(n, i) {
    var s = i.updateQueue,
      c = s !== null ? s.lastEffect : null
    if (c !== null) {
      var f = c.next,
        m = f
      do {
        if ((m.tag & n) === n) {
          ;(n & pr) !== ai ? z3(i) : (n & Gn) !== ai && q3(i)
          var y = m.create
          ;(n & Oa) !== ai && Od(!0),
            (m.destroy = y()),
            (n & Oa) !== ai && Od(!1),
            (n & pr) !== ai ? H3() : (n & Gn) !== ai && G3()
          {
            var b = m.destroy
            if (b !== void 0 && typeof b != 'function') {
              var S = void 0
              ;(m.tag & Gn) !== et
                ? (S = 'useLayoutEffect')
                : (m.tag & Oa) !== et
                  ? (S = 'useInsertionEffect')
                  : (S = 'useEffect')
              var O = void 0
              b === null
                ? (O =
                    ' You returned null. If your effect does not require clean up, return undefined (or nothing).')
                : typeof b.then == 'function'
                  ? (O =
                      `

It looks like you wrote ` +
                      S +
                      `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` +
                      S +
                      `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching`)
                  : (O = ' You returned: ' + b),
                l('%s must not return anything besides a function, which is used for clean-up.%s', S, O)
            }
          }
        }
        m = m.next
      } while (m !== f)
    }
  }
  function DI(n, i) {
    if ((i.flags & jt) !== et)
      switch (i.tag) {
        case L: {
          var s = i.stateNode.passiveEffectDuration,
            c = i.memoizedProps,
            f = c.id,
            m = c.onPostCommit,
            y = Aw(),
            b = i.alternate === null ? 'mount' : 'update'
          kw() && (b = 'nested-update'), typeof m == 'function' && m(f, b, s, y)
          var S = i.return
          e: for (; S !== null; ) {
            switch (S.tag) {
              case g:
                var O = S.stateNode
                O.passiveEffectDuration += s
                break e
              case L:
                var N = S.stateNode
                N.passiveEffectDuration += s
                break e
            }
            S = S.return
          }
          break
        }
      }
  }
  function NI(n, i, s, c) {
    if ((s.flags & cf) !== et)
      switch (s.tag) {
        case h:
        case A:
        case H: {
          if (!vr)
            if (s.mode & on)
              try {
                Na(), is(Gn | qn, s)
              } finally {
                Da(s)
              }
            else is(Gn | qn, s)
          break
        }
        case p: {
          var f = s.stateNode
          if (s.flags & jt && !vr)
            if (i === null)
              if (
                (s.type === s.elementType &&
                  !ol &&
                  (f.props !== s.memoizedProps &&
                    l(
                      'Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      bt(s) || 'instance'
                    ),
                  f.state !== s.memoizedState &&
                    l(
                      'Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                      bt(s) || 'instance'
                    )),
                s.mode & on)
              )
                try {
                  Na(), f.componentDidMount()
                } finally {
                  Da(s)
                }
              else f.componentDidMount()
            else {
              var m = s.elementType === s.type ? i.memoizedProps : ra(s.type, i.memoizedProps),
                y = i.memoizedState
              if (
                (s.type === s.elementType &&
                  !ol &&
                  (f.props !== s.memoizedProps &&
                    l(
                      'Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      bt(s) || 'instance'
                    ),
                  f.state !== s.memoizedState &&
                    l(
                      'Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                      bt(s) || 'instance'
                    )),
                s.mode & on)
              )
                try {
                  Na(), f.componentDidUpdate(m, y, f.__reactInternalSnapshotBeforeUpdate)
                } finally {
                  Da(s)
                }
              else f.componentDidUpdate(m, y, f.__reactInternalSnapshotBeforeUpdate)
            }
          var b = s.updateQueue
          b !== null &&
            (s.type === s.elementType &&
              !ol &&
              (f.props !== s.memoizedProps &&
                l(
                  'Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                  bt(s) || 'instance'
                ),
              f.state !== s.memoizedState &&
                l(
                  'Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                  bt(s) || 'instance'
                )),
            ew(s, b, f))
          break
        }
        case g: {
          var S = s.updateQueue
          if (S !== null) {
            var O = null
            if (s.child !== null)
              switch (s.child.tag) {
                case x:
                  O = s.child.stateNode
                  break
                case p:
                  O = s.child.stateNode
                  break
              }
            ew(s, S, O)
          }
          break
        }
        case x: {
          var N = s.stateNode
          if (i === null && s.flags & jt) {
            var U = s.type,
              j = s.memoizedProps
            Z5(N, U, j)
          }
          break
        }
        case C:
          break
        case E:
          break
        case L: {
          {
            var q = s.memoizedProps,
              Z = q.onCommit,
              ee = q.onRender,
              Ae = s.stateNode.effectDuration,
              Ze = Aw(),
              We = i === null ? 'mount' : 'update'
            kw() && (We = 'nested-update'),
              typeof ee == 'function' &&
                ee(s.memoizedProps.id, We, s.actualDuration, s.treeBaseDuration, s.actualStartTime, Ze)
            {
              typeof Z == 'function' && Z(s.memoizedProps.id, We, Ae, Ze), kF(s)
              var It = s.return
              e: for (; It !== null; ) {
                switch (It.tag) {
                  case g:
                    var Ot = It.stateNode
                    Ot.effectDuration += Ae
                    break e
                  case L:
                    var W = It.stateNode
                    W.effectDuration += Ae
                    break e
                }
                It = It.return
              }
            }
          }
          break
        }
        case F: {
          UI(n, s)
          break
        }
        case se:
        case Q:
        case we:
        case he:
        case G:
        case De:
          break
        default:
          throw new Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          )
      }
    vr || (s.flags & $o && m2(s))
  }
  function MI(n) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        if (n.mode & on)
          try {
            Na(), d2(n, n.return)
          } finally {
            Da(n)
          }
        else d2(n, n.return)
        break
      }
      case p: {
        var i = n.stateNode
        typeof i.componentDidMount == 'function' && RI(n, n.return, i), h2(n, n.return)
        break
      }
      case x: {
        h2(n, n.return)
        break
      }
    }
  }
  function LI(n, i) {
    for (var s = null, c = n; ; ) {
      if (c.tag === x) {
        if (s === null) {
          s = c
          try {
            var f = c.stateNode
            i ? oP(f) : lP(c.stateNode, c.memoizedProps)
          } catch (y) {
            pn(n, n.return, y)
          }
        }
      } else if (c.tag === C) {
        if (s === null)
          try {
            var m = c.stateNode
            i ? sP(m) : uP(m, c.memoizedProps)
          } catch (y) {
            pn(n, n.return, y)
          }
      } else if (!((c.tag === he || c.tag === G) && c.memoizedState !== null && c !== n)) {
        if (c.child !== null) {
          ;(c.child.return = c), (c = c.child)
          continue
        }
      }
      if (c === n) return
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === n) return
        s === c && (s = null), (c = c.return)
      }
      s === c && (s = null), (c.sibling.return = c.return), (c = c.sibling)
    }
  }
  function m2(n) {
    var i = n.ref
    if (i !== null) {
      var s = n.stateNode,
        c
      switch (n.tag) {
        case x:
          c = s
          break
        default:
          c = s
      }
      if (typeof i == 'function') {
        var f
        if (n.mode & on)
          try {
            Na(), (f = i(c))
          } finally {
            Da(n)
          }
        else f = i(c)
        typeof f == 'function' &&
          l(
            'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
            bt(n)
          )
      } else
        i.hasOwnProperty('current') ||
          l(
            'Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().',
            bt(n)
          ),
          (i.current = c)
    }
  }
  function PI(n) {
    var i = n.alternate
    i !== null && (i.return = null), (n.return = null)
  }
  function v2(n) {
    var i = n.alternate
    i !== null && ((n.alternate = null), v2(i))
    {
      if (((n.child = null), (n.deletions = null), (n.sibling = null), n.tag === x)) {
        var s = n.stateNode
        s !== null && $P(s)
      }
      ;(n.stateNode = null),
        (n._debugOwner = null),
        (n.return = null),
        (n.dependencies = null),
        (n.memoizedProps = null),
        (n.memoizedState = null),
        (n.pendingProps = null),
        (n.stateNode = null),
        (n.updateQueue = null)
    }
  }
  function II(n) {
    for (var i = n.return; i !== null; ) {
      if (g2(i)) return i
      i = i.return
    }
    throw new Error(
      'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function g2(n) {
    return n.tag === x || n.tag === g || n.tag === E
  }
  function y2(n) {
    var i = n
    e: for (;;) {
      for (; i.sibling === null; ) {
        if (i.return === null || g2(i.return)) return null
        i = i.return
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== x && i.tag !== C && i.tag !== ue; ) {
        if (i.flags & zn || i.child === null || i.tag === E) continue e
        ;(i.child.return = i), (i = i.child)
      }
      if (!(i.flags & zn)) return i.stateNode
    }
  }
  function FI(n) {
    var i = II(n)
    switch (i.tag) {
      case x: {
        var s = i.stateNode
        i.flags & lf && (EC(s), (i.flags &= ~lf))
        var c = y2(n)
        Gb(n, c, s)
        break
      }
      case g:
      case E: {
        var f = i.stateNode.containerInfo,
          m = y2(n)
        qb(n, m, f)
        break
      }
      default:
        throw new Error(
          'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.'
        )
    }
  }
  function qb(n, i, s) {
    var c = n.tag,
      f = c === x || c === C
    if (f) {
      var m = n.stateNode
      i ? nP(s, m, i) : eP(s, m)
    } else if (c !== E) {
      var y = n.child
      if (y !== null) {
        qb(y, i, s)
        for (var b = y.sibling; b !== null; ) qb(b, i, s), (b = b.sibling)
      }
    }
  }
  function Gb(n, i, s) {
    var c = n.tag,
      f = c === x || c === C
    if (f) {
      var m = n.stateNode
      i ? tP(s, m, i) : J5(s, m)
    } else if (c !== E) {
      var y = n.child
      if (y !== null) {
        Gb(y, i, s)
        for (var b = y.sibling; b !== null; ) Gb(b, i, s), (b = b.sibling)
      }
    }
  }
  var gr = null,
    oa = !1
  function VI(n, i, s) {
    {
      var c = i
      e: for (; c !== null; ) {
        switch (c.tag) {
          case x: {
            ;(gr = c.stateNode), (oa = !1)
            break e
          }
          case g: {
            ;(gr = c.stateNode.containerInfo), (oa = !0)
            break e
          }
          case E: {
            ;(gr = c.stateNode.containerInfo), (oa = !0)
            break e
          }
        }
        c = c.return
      }
      if (gr === null)
        throw new Error(
          'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
        )
      b2(n, i, s), (gr = null), (oa = !1)
    }
    PI(s)
  }
  function as(n, i, s) {
    for (var c = s.child; c !== null; ) b2(n, i, c), (c = c.sibling)
  }
  function b2(n, i, s) {
    switch ((j3(s), s.tag)) {
      case x:
        vr || Vu(s, i)
      case C: {
        {
          var c = gr,
            f = oa
          ;(gr = null),
            as(n, i, s),
            (gr = c),
            (oa = f),
            gr !== null && (oa ? iP(gr, s.stateNode) : rP(gr, s.stateNode))
        }
        return
      }
      case ue: {
        gr !== null && (oa ? aP(gr, s.stateNode) : ay(gr, s.stateNode))
        return
      }
      case E: {
        {
          var m = gr,
            y = oa
          ;(gr = s.stateNode.containerInfo), (oa = !0), as(n, i, s), (gr = m), (oa = y)
        }
        return
      }
      case h:
      case A:
      case z:
      case H: {
        if (!vr) {
          var b = s.updateQueue
          if (b !== null) {
            var S = b.lastEffect
            if (S !== null) {
              var O = S.next,
                N = O
              do {
                var U = N,
                  j = U.destroy,
                  q = U.tag
                j !== void 0 &&
                  ((q & Oa) !== ai
                    ? Wm(s, i, j)
                    : (q & Gn) !== ai &&
                      (rT(s), s.mode & on ? (Na(), Wm(s, i, j), Da(s)) : Wm(s, i, j), iT())),
                  (N = N.next)
              } while (N !== O)
            }
          }
        }
        as(n, i, s)
        return
      }
      case p: {
        if (!vr) {
          Vu(s, i)
          var Z = s.stateNode
          typeof Z.componentWillUnmount == 'function' && Yb(s, i, Z)
        }
        as(n, i, s)
        return
      }
      case we: {
        as(n, i, s)
        return
      }
      case he: {
        if (s.mode & Lt) {
          var ee = vr
          ;(vr = ee || s.memoizedState !== null), as(n, i, s), (vr = ee)
        } else as(n, i, s)
        break
      }
      default: {
        as(n, i, s)
        return
      }
    }
  }
  function jI(n) {
    n.memoizedState
  }
  function UI(n, i) {
    var s = i.memoizedState
    if (s === null) {
      var c = i.alternate
      if (c !== null) {
        var f = c.memoizedState
        if (f !== null) {
          var m = f.dehydrated
          m !== null && CP(m)
        }
      }
    }
  }
  function E2(n) {
    var i = n.updateQueue
    if (i !== null) {
      n.updateQueue = null
      var s = n.stateNode
      s === null && (s = n.stateNode = new TI()),
        i.forEach(function (c) {
          var f = IF.bind(null, n, c)
          if (!s.has(c)) {
            if ((s.add(c), Zi))
              if (Iu !== null && Fu !== null) _d(Fu, Iu)
              else throw Error('Expected finished root and lanes to be set. This is a bug in React.')
            c.then(f, f)
          }
        })
    }
  }
  function $I(n, i, s) {
    ;(Iu = s), (Fu = n), Rn(i), x2(i, n), Rn(i), (Iu = null), (Fu = null)
  }
  function sa(n, i, s) {
    var c = i.deletions
    if (c !== null)
      for (var f = 0; f < c.length; f++) {
        var m = c[f]
        try {
          VI(n, i, m)
        } catch (S) {
          pn(m, i, S)
        }
      }
    var y = tp()
    if (i.subtreeFlags & e0) for (var b = i.child; b !== null; ) Rn(b), x2(b, n), (b = b.sibling)
    Rn(y)
  }
  function x2(n, i, s) {
    var c = n.alternate,
      f = n.flags
    switch (n.tag) {
      case h:
      case A:
      case z:
      case H: {
        if ((sa(i, n), Ma(n), f & jt)) {
          try {
            aa(Oa | qn, n, n.return), is(Oa | qn, n)
          } catch (nt) {
            pn(n, n.return, nt)
          }
          if (n.mode & on) {
            try {
              Na(), aa(Gn | qn, n, n.return)
            } catch (nt) {
              pn(n, n.return, nt)
            }
            Da(n)
          } else
            try {
              aa(Gn | qn, n, n.return)
            } catch (nt) {
              pn(n, n.return, nt)
            }
        }
        return
      }
      case p: {
        sa(i, n), Ma(n), f & $o && c !== null && Vu(c, c.return)
        return
      }
      case x: {
        sa(i, n), Ma(n), f & $o && c !== null && Vu(c, c.return)
        {
          if (n.flags & lf) {
            var m = n.stateNode
            try {
              EC(m)
            } catch (nt) {
              pn(n, n.return, nt)
            }
          }
          if (f & jt) {
            var y = n.stateNode
            if (y != null) {
              var b = n.memoizedProps,
                S = c !== null ? c.memoizedProps : b,
                O = n.type,
                N = n.updateQueue
              if (((n.updateQueue = null), N !== null))
                try {
                  X5(y, N, O, S, b, n)
                } catch (nt) {
                  pn(n, n.return, nt)
                }
            }
          }
        }
        return
      }
      case C: {
        if ((sa(i, n), Ma(n), f & jt)) {
          if (n.stateNode === null)
            throw new Error(
              'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'
            )
          var U = n.stateNode,
            j = n.memoizedProps,
            q = c !== null ? c.memoizedProps : j
          try {
            Q5(U, q, j)
          } catch (nt) {
            pn(n, n.return, nt)
          }
        }
        return
      }
      case g: {
        if ((sa(i, n), Ma(n), f & jt && c !== null)) {
          var Z = c.memoizedState
          if (Z.isDehydrated)
            try {
              TP(i.containerInfo)
            } catch (nt) {
              pn(n, n.return, nt)
            }
        }
        return
      }
      case E: {
        sa(i, n), Ma(n)
        return
      }
      case F: {
        sa(i, n), Ma(n)
        var ee = n.child
        if (ee.flags & Us) {
          var Ae = ee.stateNode,
            Ze = ee.memoizedState,
            We = Ze !== null
          if (((Ae.isHidden = We), We)) {
            var It = ee.alternate !== null && ee.alternate.memoizedState !== null
            It || xF()
          }
        }
        if (f & jt) {
          try {
            jI(n)
          } catch (nt) {
            pn(n, n.return, nt)
          }
          E2(n)
        }
        return
      }
      case he: {
        var Ot = c !== null && c.memoizedState !== null
        if (n.mode & Lt) {
          var W = vr
          ;(vr = W || Ot), sa(i, n), (vr = W)
        } else sa(i, n)
        if ((Ma(n), f & Us)) {
          var te = n.stateNode,
            Y = n.memoizedState,
            me = Y !== null,
            Fe = n
          if (((te.isHidden = me), me && !Ot && (Fe.mode & Lt) !== Je)) {
            je = Fe
            for (var Ne = Fe.child; Ne !== null; ) (je = Ne), zI(Ne), (Ne = Ne.sibling)
          }
          LI(Fe, me)
        }
        return
      }
      case se: {
        sa(i, n), Ma(n), f & jt && E2(n)
        return
      }
      case we:
        return
      default: {
        sa(i, n), Ma(n)
        return
      }
    }
  }
  function Ma(n) {
    var i = n.flags
    if (i & zn) {
      try {
        FI(n)
      } catch (s) {
        pn(n, n.return, s)
      }
      n.flags &= ~zn
    }
    i & eo && (n.flags &= ~eo)
  }
  function BI(n, i, s) {
    ;(Iu = s), (Fu = i), (je = n), S2(n, i, s), (Iu = null), (Fu = null)
  }
  function S2(n, i, s) {
    for (var c = (n.mode & Lt) !== Je; je !== null; ) {
      var f = je,
        m = f.child
      if (f.tag === he && c) {
        var y = f.memoizedState !== null,
          b = y || Hm
        if (b) {
          Kb(n, i, s)
          continue
        } else {
          var S = f.alternate,
            O = S !== null && S.memoizedState !== null,
            N = O || vr,
            U = Hm,
            j = vr
          ;(Hm = b), (vr = N), vr && !j && ((je = f), HI(f))
          for (var q = m; q !== null; ) (je = q), S2(q, i, s), (q = q.sibling)
          ;(je = f), (Hm = U), (vr = j), Kb(n, i, s)
          continue
        }
      }
      ;(f.subtreeFlags & cf) !== et && m !== null ? ((m.return = f), (je = m)) : Kb(n, i, s)
    }
  }
  function Kb(n, i, s) {
    for (; je !== null; ) {
      var c = je
      if ((c.flags & cf) !== et) {
        var f = c.alternate
        Rn(c)
        try {
          NI(i, f, c, s)
        } catch (y) {
          pn(c, c.return, y)
        }
        ar()
      }
      if (c === n) {
        je = null
        return
      }
      var m = c.sibling
      if (m !== null) {
        ;(m.return = c.return), (je = m)
        return
      }
      je = c.return
    }
  }
  function zI(n) {
    for (; je !== null; ) {
      var i = je,
        s = i.child
      switch (i.tag) {
        case h:
        case A:
        case z:
        case H: {
          if (i.mode & on)
            try {
              Na(), aa(Gn, i, i.return)
            } finally {
              Da(i)
            }
          else aa(Gn, i, i.return)
          break
        }
        case p: {
          Vu(i, i.return)
          var c = i.stateNode
          typeof c.componentWillUnmount == 'function' && Yb(i, i.return, c)
          break
        }
        case x: {
          Vu(i, i.return)
          break
        }
        case he: {
          var f = i.memoizedState !== null
          if (f) {
            T2(n)
            continue
          }
          break
        }
      }
      s !== null ? ((s.return = i), (je = s)) : T2(n)
    }
  }
  function T2(n) {
    for (; je !== null; ) {
      var i = je
      if (i === n) {
        je = null
        return
      }
      var s = i.sibling
      if (s !== null) {
        ;(s.return = i.return), (je = s)
        return
      }
      je = i.return
    }
  }
  function HI(n) {
    for (; je !== null; ) {
      var i = je,
        s = i.child
      if (i.tag === he) {
        var c = i.memoizedState !== null
        if (c) {
          C2(n)
          continue
        }
      }
      s !== null ? ((s.return = i), (je = s)) : C2(n)
    }
  }
  function C2(n) {
    for (; je !== null; ) {
      var i = je
      Rn(i)
      try {
        MI(i)
      } catch (c) {
        pn(i, i.return, c)
      }
      if ((ar(), i === n)) {
        je = null
        return
      }
      var s = i.sibling
      if (s !== null) {
        ;(s.return = i.return), (je = s)
        return
      }
      je = i.return
    }
  }
  function WI(n, i, s, c) {
    ;(je = i), YI(i, n, s, c)
  }
  function YI(n, i, s, c) {
    for (; je !== null; ) {
      var f = je,
        m = f.child
      ;(f.subtreeFlags & iu) !== et && m !== null ? ((m.return = f), (je = m)) : qI(n, i, s, c)
    }
  }
  function qI(n, i, s, c) {
    for (; je !== null; ) {
      var f = je
      if ((f.flags & Ki) !== et) {
        Rn(f)
        try {
          GI(i, f, s, c)
        } catch (y) {
          pn(f, f.return, y)
        }
        ar()
      }
      if (f === n) {
        je = null
        return
      }
      var m = f.sibling
      if (m !== null) {
        ;(m.return = f.return), (je = m)
        return
      }
      je = f.return
    }
  }
  function GI(n, i, s, c) {
    switch (i.tag) {
      case h:
      case A:
      case H: {
        if (i.mode & on) {
          pb()
          try {
            is(pr | qn, i)
          } finally {
            hb(i)
          }
        } else is(pr | qn, i)
        break
      }
    }
  }
  function KI(n) {
    ;(je = n), ZI()
  }
  function ZI() {
    for (; je !== null; ) {
      var n = je,
        i = n.child
      if ((je.flags & Vs) !== et) {
        var s = n.deletions
        if (s !== null) {
          for (var c = 0; c < s.length; c++) {
            var f = s[c]
            ;(je = f), JI(f, n)
          }
          {
            var m = n.alternate
            if (m !== null) {
              var y = m.child
              if (y !== null) {
                m.child = null
                do {
                  var b = y.sibling
                  ;(y.sibling = null), (y = b)
                } while (y !== null)
              }
            }
          }
          je = n
        }
      }
      ;(n.subtreeFlags & iu) !== et && i !== null ? ((i.return = n), (je = i)) : XI()
    }
  }
  function XI() {
    for (; je !== null; ) {
      var n = je
      ;(n.flags & Ki) !== et && (Rn(n), QI(n), ar())
      var i = n.sibling
      if (i !== null) {
        ;(i.return = n.return), (je = i)
        return
      }
      je = n.return
    }
  }
  function QI(n) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        n.mode & on ? (pb(), aa(pr | qn, n, n.return), hb(n)) : aa(pr | qn, n, n.return)
        break
      }
    }
  }
  function JI(n, i) {
    for (; je !== null; ) {
      var s = je
      Rn(s), tF(s, i), ar()
      var c = s.child
      c !== null ? ((c.return = s), (je = c)) : eF(n)
    }
  }
  function eF(n) {
    for (; je !== null; ) {
      var i = je,
        s = i.sibling,
        c = i.return
      if ((v2(i), i === n)) {
        je = null
        return
      }
      if (s !== null) {
        ;(s.return = c), (je = s)
        return
      }
      je = c
    }
  }
  function tF(n, i) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        n.mode & on ? (pb(), aa(pr, n, i), hb(n)) : aa(pr, n, i)
        break
      }
    }
  }
  function nF(n) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        try {
          is(Gn | qn, n)
        } catch (s) {
          pn(n, n.return, s)
        }
        break
      }
      case p: {
        var i = n.stateNode
        try {
          i.componentDidMount()
        } catch (s) {
          pn(n, n.return, s)
        }
        break
      }
    }
  }
  function rF(n) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        try {
          is(pr | qn, n)
        } catch (i) {
          pn(n, n.return, i)
        }
        break
      }
    }
  }
  function iF(n) {
    switch (n.tag) {
      case h:
      case A:
      case H: {
        try {
          aa(Gn | qn, n, n.return)
        } catch (s) {
          pn(n, n.return, s)
        }
        break
      }
      case p: {
        var i = n.stateNode
        typeof i.componentWillUnmount == 'function' && Yb(n, n.return, i)
        break
      }
    }
  }
  function aF(n) {
    switch (n.tag) {
      case h:
      case A:
      case H:
        try {
          aa(pr | qn, n, n.return)
        } catch (i) {
          pn(n, n.return, i)
        }
    }
  }
  if (typeof Symbol == 'function' && Symbol.for) {
    var vd = Symbol.for
    vd('selector.component'),
      vd('selector.has_pseudo_class'),
      vd('selector.role'),
      vd('selector.test_id'),
      vd('selector.text')
  }
  var oF = []
  function sF() {
    oF.forEach(function (n) {
      return n()
    })
  }
  var lF = r.ReactCurrentActQueue
  function uF(n) {
    {
      var i = typeof IS_REACT_ACT_ENVIRONMENT < 'u' ? IS_REACT_ACT_ENVIRONMENT : void 0,
        s = typeof jest < 'u'
      return s && i !== !1
    }
  }
  function w2() {
    {
      var n = typeof IS_REACT_ACT_ENVIRONMENT < 'u' ? IS_REACT_ACT_ENVIRONMENT : void 0
      return (
        !n &&
          lF.current !== null &&
          l('The current testing environment is not configured to support act(...)'),
        n
      )
    }
  }
  var cF = Math.ceil,
    Zb = r.ReactCurrentDispatcher,
    Xb = r.ReactCurrentOwner,
    yr = r.ReactCurrentBatchConfig,
    la = r.ReactCurrentActQueue,
    Xn = 0,
    R2 = 1,
    br = 2,
    Ui = 4,
    po = 0,
    gd = 1,
    sl = 2,
    Ym = 3,
    yd = 4,
    _2 = 5,
    Qb = 6,
    Pt = Xn,
    zr = null,
    _n = null,
    Qn = fe,
    La = fe,
    Jb = Ko(fe),
    Jn = po,
    bd = null,
    qm = fe,
    Ed = fe,
    Gm = fe,
    xd = null,
    oi = null,
    eE = 0,
    O2 = 500,
    k2 = 1 / 0,
    fF = 500,
    mo = null
  function Sd() {
    k2 = or() + fF
  }
  function A2() {
    return k2
  }
  var Km = !1,
    tE = null,
    ju = null,
    ll = !1,
    os = null,
    Td = fe,
    nE = [],
    rE = null,
    dF = 50,
    Cd = 0,
    iE = null,
    aE = !1,
    Zm = !1,
    hF = 50,
    Uu = 0,
    Xm = null,
    wd = vn,
    Qm = fe,
    D2 = !1
  function Jm() {
    return zr
  }
  function Hr() {
    return (Pt & (br | Ui)) !== Xn ? or() : (wd !== vn || (wd = or()), wd)
  }
  function ss(n) {
    var i = n.mode
    if ((i & Lt) === Je) return ct
    if ((Pt & br) !== Xn && Qn !== fe) return gf(Qn)
    var s = l7() !== s7
    if (s) {
      if (yr.transition !== null) {
        var c = yr.transition
        c._updatedFibers || (c._updatedFibers = new Set()), c._updatedFibers.add(n)
      }
      return Qm === lr && (Qm = dT()), Qm
    }
    var f = Xi()
    if (f !== lr) return f
    var m = Y5()
    return m
  }
  function pF(n) {
    var i = n.mode
    return (i & Lt) === Je ? ct : vL()
  }
  function er(n, i, s, c) {
    VF(),
      D2 && l('useInsertionEffect must not schedule updates.'),
      aE && (Zm = !0),
      yf(n, s, c),
      (Pt & br) !== fe && n === zr
        ? $F(i)
        : (Zi && mT(n, i, s),
          BF(i),
          n === zr && ((Pt & br) === Xn && (Ed = Tt(Ed, s)), Jn === yd && ls(n, Qn)),
          si(n, c),
          s === ct && Pt === Xn && (i.mode & Lt) === Je && !la.isBatchingLegacy && (Sd(), DC()))
  }
  function mF(n, i, s) {
    var c = n.current
    ;(c.lanes = i), yf(n, i, s), si(n, s)
  }
  function vF(n) {
    return (Pt & br) !== Xn
  }
  function si(n, i) {
    var s = n.callbackNode
    cL(n, i)
    var c = Ep(n, n === zr ? Qn : fe)
    if (c === fe) {
      s !== null && q2(s), (n.callbackNode = null), (n.callbackPriority = lr)
      return
    }
    var f = Ys(c),
      m = n.callbackPriority
    if (m === f && !(la.current !== null && s !== dE)) {
      s == null &&
        m !== ct &&
        l(
          'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.'
        )
      return
    }
    s != null && q2(s)
    var y
    if (f === ct)
      n.tag === Zo
        ? (la.isBatchingLegacy !== null && (la.didScheduleLegacyUpdate = !0), HP(L2.bind(null, n)))
        : AC(L2.bind(null, n)),
        la.current !== null
          ? la.current.push(Xo)
          : G5(function () {
              ;(Pt & (br | Ui)) === Xn && Xo()
            }),
        (y = null)
    else {
      var b
      switch (yT(c)) {
        case vi:
          b = vp
          break
        case io:
          b = t0
          break
        case ao:
          b = zs
          break
        case Tp:
          b = n0
          break
        default:
          b = zs
          break
      }
      y = hE(b, N2.bind(null, n))
    }
    ;(n.callbackPriority = f), (n.callbackNode = y)
  }
  function N2(n, i) {
    if ((L7(), (wd = vn), (Qm = fe), (Pt & (br | Ui)) !== Xn))
      throw new Error('Should not already be working.')
    var s = n.callbackNode,
      c = go()
    if (c && n.callbackNode !== s) return null
    var f = Ep(n, n === zr ? Qn : fe)
    if (f === fe) return null
    var m = !xp(n, f) && !mL(n, f) && !i,
      y = m ? RF(n, f) : tv(n, f)
    if (y !== po) {
      if (y === sl) {
        var b = C0(n)
        b !== fe && ((f = b), (y = oE(n, b)))
      }
      if (y === gd) {
        var S = bd
        throw (ul(n, fe), ls(n, f), si(n, or()), S)
      }
      if (y === Qb) ls(n, f)
      else {
        var O = !xp(n, f),
          N = n.current.alternate
        if (O && !yF(N)) {
          if (((y = tv(n, f)), y === sl)) {
            var U = C0(n)
            U !== fe && ((f = U), (y = oE(n, U)))
          }
          if (y === gd) {
            var j = bd
            throw (ul(n, fe), ls(n, f), si(n, or()), j)
          }
        }
        ;(n.finishedWork = N), (n.finishedLanes = f), gF(n, y, f)
      }
    }
    return si(n, or()), n.callbackNode === s ? N2.bind(null, n) : null
  }
  function oE(n, i) {
    var s = xd
    if (Cp(n)) {
      var c = ul(n, i)
      ;(c.flags |= Ja), FP(n.containerInfo)
    }
    var f = tv(n, i)
    if (f !== sl) {
      var m = oi
      ;(oi = s), m !== null && M2(m)
    }
    return f
  }
  function M2(n) {
    oi === null ? (oi = n) : oi.push.apply(oi, n)
  }
  function gF(n, i, s) {
    switch (i) {
      case po:
      case gd:
        throw new Error('Root did not complete. This is a bug in React.')
      case sl: {
        cl(n, oi, mo)
        break
      }
      case Ym: {
        if ((ls(n, s), cT(s) && !G2())) {
          var c = eE + O2 - or()
          if (c > 10) {
            var f = Ep(n, fe)
            if (f !== fe) break
            var m = n.suspendedLanes
            if (!cu(m, s)) {
              Hr(), pT(n, m)
              break
            }
            n.timeoutHandle = ry(cl.bind(null, n, oi, mo), c)
            break
          }
        }
        cl(n, oi, mo)
        break
      }
      case yd: {
        if ((ls(n, s), pL(s))) break
        if (!G2()) {
          var y = lL(n, s),
            b = y,
            S = or() - b,
            O = FF(S) - S
          if (O > 10) {
            n.timeoutHandle = ry(cl.bind(null, n, oi, mo), O)
            break
          }
        }
        cl(n, oi, mo)
        break
      }
      case _2: {
        cl(n, oi, mo)
        break
      }
      default:
        throw new Error('Unknown root exit status.')
    }
  }
  function yF(n) {
    for (var i = n; ; ) {
      if (i.flags & pp) {
        var s = i.updateQueue
        if (s !== null) {
          var c = s.stores
          if (c !== null)
            for (var f = 0; f < c.length; f++) {
              var m = c[f],
                y = m.getSnapshot,
                b = m.value
              try {
                if (!yi(y(), b)) return !1
              } catch {
                return !1
              }
            }
        }
      }
      var S = i.child
      if (i.subtreeFlags & pp && S !== null) {
        ;(S.return = i), (i = S)
        continue
      }
      if (i === n) return !0
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === n) return !0
        i = i.return
      }
      ;(i.sibling.return = i.return), (i = i.sibling)
    }
    return !0
  }
  function ls(n, i) {
    ;(i = Sp(i, Gm)), (i = Sp(i, Ed)), yL(n, i)
  }
  function L2(n) {
    if ((P7(), (Pt & (br | Ui)) !== Xn)) throw new Error('Should not already be working.')
    go()
    var i = Ep(n, fe)
    if (!mi(i, ct)) return si(n, or()), null
    var s = tv(n, i)
    if (n.tag !== Zo && s === sl) {
      var c = C0(n)
      c !== fe && ((i = c), (s = oE(n, c)))
    }
    if (s === gd) {
      var f = bd
      throw (ul(n, fe), ls(n, i), si(n, or()), f)
    }
    if (s === Qb) throw new Error('Root did not complete. This is a bug in React.')
    var m = n.current.alternate
    return (n.finishedWork = m), (n.finishedLanes = i), cl(n, oi, mo), si(n, or()), null
  }
  function bF(n, i) {
    i !== fe && (O0(n, Tt(i, ct)), si(n, or()), (Pt & (br | Ui)) === Xn && (Sd(), Xo()))
  }
  function sE(n, i) {
    var s = Pt
    Pt |= R2
    try {
      return n(i)
    } finally {
      ;(Pt = s), Pt === Xn && !la.isBatchingLegacy && (Sd(), DC())
    }
  }
  function EF(n, i, s, c, f) {
    var m = Xi(),
      y = yr.transition
    try {
      return (yr.transition = null), ur(vi), n(i, s, c, f)
    } finally {
      ur(m), (yr.transition = y), Pt === Xn && Sd()
    }
  }
  function vo(n) {
    os !== null && os.tag === Zo && (Pt & (br | Ui)) === Xn && go()
    var i = Pt
    Pt |= R2
    var s = yr.transition,
      c = Xi()
    try {
      return (yr.transition = null), ur(vi), n ? n() : void 0
    } finally {
      ur(c), (yr.transition = s), (Pt = i), (Pt & (br | Ui)) === Xn && Xo()
    }
  }
  function P2() {
    return (Pt & (br | Ui)) !== Xn
  }
  function ev(n, i) {
    kr(Jb, La, n), (La = Tt(La, i))
  }
  function lE(n) {
    ;(La = Jb.current), Or(Jb, n)
  }
  function ul(n, i) {
    ;(n.finishedWork = null), (n.finishedLanes = fe)
    var s = n.timeoutHandle
    if ((s !== iy && ((n.timeoutHandle = iy), q5(s)), _n !== null))
      for (var c = _n.return; c !== null; ) {
        var f = c.alternate
        c2(f, c), (c = c.return)
      }
    zr = n
    var m = fl(n.current, null)
    return (
      (_n = m),
      (Qn = La = i),
      (Jn = po),
      (bd = null),
      (qm = fe),
      (Ed = fe),
      (Gm = fe),
      (xd = null),
      (oi = null),
      m7(),
      ea.discardPendingWarnings(),
      m
    )
  }
  function I2(n, i) {
    do {
      var s = _n
      try {
        if ((cm(), ow(), ar(), (Xb.current = null), s === null || s.return === null)) {
          ;(Jn = gd), (bd = i), (_n = null)
          return
        }
        if ((kt && s.mode & on && jm(s, !0), Ye))
          if ((ou(), i !== null && typeof i == 'object' && typeof i.then == 'function')) {
            var c = i
            Z3(s, c, Qn)
          } else K3(s, i, Qn)
        H7(n, s.return, s, i, Qn), U2(s)
      } catch (f) {
        ;(i = f), _n === s && s !== null ? ((s = s.return), (_n = s)) : (s = _n)
        continue
      }
      return
    } while (!0)
  }
  function F2() {
    var n = Zb.current
    return (Zb.current = Lm), n === null ? Lm : n
  }
  function V2(n) {
    Zb.current = n
  }
  function xF() {
    eE = or()
  }
  function Rd(n) {
    qm = Tt(n, qm)
  }
  function SF() {
    Jn === po && (Jn = Ym)
  }
  function uE() {
    ;(Jn === po || Jn === Ym || Jn === sl) && (Jn = yd), zr !== null && (w0(qm) || w0(Ed)) && ls(zr, Qn)
  }
  function TF(n) {
    Jn !== yd && (Jn = sl), xd === null ? (xd = [n]) : xd.push(n)
  }
  function CF() {
    return Jn === po
  }
  function tv(n, i) {
    var s = Pt
    Pt |= br
    var c = F2()
    if (zr !== n || Qn !== i) {
      if (Zi) {
        var f = n.memoizedUpdaters
        f.size > 0 && (_d(n, Qn), f.clear()), vT(n, i)
      }
      ;(mo = gT()), ul(n, i)
    }
    aT(i)
    do
      try {
        wF()
        break
      } catch (m) {
        I2(n, m)
      }
    while (!0)
    if ((cm(), (Pt = s), V2(c), _n !== null))
      throw new Error(
        'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'
      )
    return oT(), (zr = null), (Qn = fe), Jn
  }
  function wF() {
    for (; _n !== null; ) j2(_n)
  }
  function RF(n, i) {
    var s = Pt
    Pt |= br
    var c = F2()
    if (zr !== n || Qn !== i) {
      if (Zi) {
        var f = n.memoizedUpdaters
        f.size > 0 && (_d(n, Qn), f.clear()), vT(n, i)
      }
      ;(mo = gT()), Sd(), ul(n, i)
    }
    aT(i)
    do
      try {
        _F()
        break
      } catch (m) {
        I2(n, m)
      }
    while (!0)
    return cm(), V2(c), (Pt = s), _n !== null ? (tL(), po) : (oT(), (zr = null), (Qn = fe), Jn)
  }
  function _F() {
    for (; _n !== null && !k3(); ) j2(_n)
  }
  function j2(n) {
    var i = n.alternate
    Rn(n)
    var s
    ;(n.mode & on) !== Je ? (db(n), (s = cE(i, n, La)), jm(n, !0)) : (s = cE(i, n, La)),
      ar(),
      (n.memoizedProps = n.pendingProps),
      s === null ? U2(n) : (_n = s),
      (Xb.current = null)
  }
  function U2(n) {
    var i = n
    do {
      var s = i.alternate,
        c = i.return
      if ((i.flags & uf) === et) {
        Rn(i)
        var f = void 0
        if (
          ((i.mode & on) === Je ? (f = u2(s, i, La)) : (db(i), (f = u2(s, i, La)), jm(i, !1)),
          ar(),
          f !== null)
        ) {
          _n = f
          return
        }
      } else {
        var m = SI(s, i)
        if (m !== null) {
          ;(m.flags &= T3), (_n = m)
          return
        }
        if ((i.mode & on) !== Je) {
          jm(i, !1)
          for (var y = i.actualDuration, b = i.child; b !== null; )
            (y += b.actualDuration), (b = b.sibling)
          i.actualDuration = y
        }
        if (c !== null) (c.flags |= uf), (c.subtreeFlags = et), (c.deletions = null)
        else {
          ;(Jn = Qb), (_n = null)
          return
        }
      }
      var S = i.sibling
      if (S !== null) {
        _n = S
        return
      }
      ;(i = c), (_n = i)
    } while (i !== null)
    Jn === po && (Jn = _2)
  }
  function cl(n, i, s) {
    var c = Xi(),
      f = yr.transition
    try {
      ;(yr.transition = null), ur(vi), OF(n, i, s, c)
    } finally {
      ;(yr.transition = f), ur(c)
    }
    return null
  }
  function OF(n, i, s, c) {
    do go()
    while (os !== null)
    if ((jF(), (Pt & (br | Ui)) !== Xn)) throw new Error('Should not already be working.')
    var f = n.finishedWork,
      m = n.finishedLanes
    if ((B3(m), f === null)) return nT(), null
    if (
      (m === fe && l('root.finishedLanes should not be empty during a commit. This is a bug in React.'),
      (n.finishedWork = null),
      (n.finishedLanes = fe),
      f === n.current)
    )
      throw new Error(
        'Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.'
      )
    ;(n.callbackNode = null), (n.callbackPriority = lr)
    var y = Tt(f.lanes, f.childLanes)
    bL(n, y),
      n === zr && ((zr = null), (_n = null), (Qn = fe)),
      ((f.subtreeFlags & iu) !== et || (f.flags & iu) !== et) &&
        (ll ||
          ((ll = !0),
          (rE = s),
          hE(zs, function () {
            return go(), null
          })))
    var b = (f.subtreeFlags & (Jg | e0 | cf | iu)) !== et,
      S = (f.flags & (Jg | e0 | cf | iu)) !== et
    if (b || S) {
      var O = yr.transition
      yr.transition = null
      var N = Xi()
      ur(vi)
      var U = Pt
      ;(Pt |= Ui),
        (Xb.current = null),
        _I(n, f),
        Dw(),
        $I(n, f, m),
        U5(n.containerInfo),
        (n.current = f),
        X3(m),
        BI(f, n, m),
        Q3(),
        A3(),
        (Pt = U),
        ur(N),
        (yr.transition = O)
    } else (n.current = f), Dw()
    var j = ll
    if (
      (ll ? ((ll = !1), (os = n), (Td = m)) : ((Uu = 0), (Xm = null)),
      (y = n.pendingLanes),
      y === fe && (ju = null),
      j || H2(n.current, !1),
      F3(f.stateNode, c),
      Zi && n.memoizedUpdaters.clear(),
      sF(),
      si(n, or()),
      i !== null)
    )
      for (var q = n.onRecoverableError, Z = 0; Z < i.length; Z++) {
        var ee = i[Z],
          Ae = ee.stack,
          Ze = ee.digest
        q(ee.value, { componentStack: Ae, digest: Ze })
      }
    if (Km) {
      Km = !1
      var We = tE
      throw ((tE = null), We)
    }
    return (
      mi(Td, ct) && n.tag !== Zo && go(),
      (y = n.pendingLanes),
      mi(y, ct) ? (M7(), n === iE ? Cd++ : ((Cd = 0), (iE = n))) : (Cd = 0),
      Xo(),
      nT(),
      null
    )
  }
  function go() {
    if (os !== null) {
      var n = yT(Td),
        i = TL(ao, n),
        s = yr.transition,
        c = Xi()
      try {
        return (yr.transition = null), ur(i), AF()
      } finally {
        ur(c), (yr.transition = s)
      }
    }
    return !1
  }
  function kF(n) {
    nE.push(n),
      ll ||
        ((ll = !0),
        hE(zs, function () {
          return go(), null
        }))
  }
  function AF() {
    if (os === null) return !1
    var n = rE
    rE = null
    var i = os,
      s = Td
    if (((os = null), (Td = fe), (Pt & (br | Ui)) !== Xn))
      throw new Error('Cannot flush passive effects while already rendering.')
    ;(aE = !0), (Zm = !1), J3(s)
    var c = Pt
    ;(Pt |= Ui), KI(i.current), WI(i, i.current, s, n)
    {
      var f = nE
      nE = []
      for (var m = 0; m < f.length; m++) {
        var y = f[m]
        DI(i, y)
      }
    }
    eL(),
      H2(i.current, !0),
      (Pt = c),
      Xo(),
      Zm ? (i === Xm ? Uu++ : ((Uu = 0), (Xm = i))) : (Uu = 0),
      (aE = !1),
      (Zm = !1),
      V3(i)
    {
      var b = i.current.stateNode
      ;(b.effectDuration = 0), (b.passiveEffectDuration = 0)
    }
    return !0
  }
  function $2(n) {
    return ju !== null && ju.has(n)
  }
  function DF(n) {
    ju === null ? (ju = new Set([n])) : ju.add(n)
  }
  function NF(n) {
    Km || ((Km = !0), (tE = n))
  }
  var MF = NF
  function B2(n, i, s) {
    var c = al(s, i),
      f = jw(n, c, ct),
      m = Jo(n, f, ct),
      y = Hr()
    m !== null && (yf(m, ct, y), si(m, y))
  }
  function pn(n, i, s) {
    if ((CI(s), Od(!1), n.tag === g)) {
      B2(n, n, s)
      return
    }
    var c = null
    for (c = i; c !== null; ) {
      if (c.tag === g) {
        B2(c, n, s)
        return
      } else if (c.tag === p) {
        var f = c.type,
          m = c.stateNode
        if (
          typeof f.getDerivedStateFromError == 'function' ||
          (typeof m.componentDidCatch == 'function' && !$2(m))
        ) {
          var y = al(s, n),
            b = Ab(c, y, ct),
            S = Jo(c, b, ct),
            O = Hr()
          S !== null && (yf(S, ct, O), si(S, O))
          return
        }
      }
      c = c.return
    }
    l(
      `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
      s
    )
  }
  function LF(n, i, s) {
    var c = n.pingCache
    c !== null && c.delete(i)
    var f = Hr()
    pT(n, s),
      zF(n),
      zr === n &&
        cu(Qn, s) &&
        (Jn === yd || (Jn === Ym && cT(Qn) && or() - eE < O2) ? ul(n, fe) : (Gm = Tt(Gm, s))),
      si(n, f)
  }
  function z2(n, i) {
    i === lr && (i = pF(n))
    var s = Hr(),
      c = ii(n, i)
    c !== null && (yf(c, i, s), si(c, s))
  }
  function PF(n) {
    var i = n.memoizedState,
      s = lr
    i !== null && (s = i.retryLane), z2(n, s)
  }
  function IF(n, i) {
    var s = lr,
      c
    switch (n.tag) {
      case F:
        c = n.stateNode
        var f = n.memoizedState
        f !== null && (s = f.retryLane)
        break
      case se:
        c = n.stateNode
        break
      default:
        throw new Error('Pinged unknown suspense boundary type. This is probably a bug in React.')
    }
    c !== null && c.delete(i), z2(n, s)
  }
  function FF(n) {
    return n < 120
      ? 120
      : n < 480
        ? 480
        : n < 1080
          ? 1080
          : n < 1920
            ? 1920
            : n < 3e3
              ? 3e3
              : n < 4320
                ? 4320
                : cF(n / 1960) * 1960
  }
  function VF() {
    if (Cd > dF)
      throw (
        ((Cd = 0),
        (iE = null),
        new Error(
          'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'
        ))
      )
    Uu > hF &&
      ((Uu = 0),
      (Xm = null),
      l(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      ))
  }
  function jF() {
    ea.flushLegacyContextWarning(), ea.flushPendingUnsafeLifecycleWarnings()
  }
  function H2(n, i) {
    Rn(n), nv(n, to, iF), i && nv(n, mp, aF), nv(n, to, nF), i && nv(n, mp, rF), ar()
  }
  function nv(n, i, s) {
    for (var c = n, f = null; c !== null; ) {
      var m = c.subtreeFlags & i
      c !== f && c.child !== null && m !== et
        ? (c = c.child)
        : ((c.flags & i) !== et && s(c), c.sibling !== null ? (c = c.sibling) : (c = f = c.return))
    }
  }
  var rv = null
  function W2(n) {
    {
      if ((Pt & br) !== Xn || !(n.mode & Lt)) return
      var i = n.tag
      if (i !== v && i !== g && i !== p && i !== h && i !== A && i !== z && i !== H) return
      var s = bt(n) || 'ReactComponent'
      if (rv !== null) {
        if (rv.has(s)) return
        rv.add(s)
      } else rv = new Set([s])
      var c = Rr
      try {
        Rn(n),
          l(
            "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
          )
      } finally {
        c ? Rn(n) : ar()
      }
    }
  }
  var cE
  {
    var UF = null
    cE = function (n, i, s) {
      var c = J2(UF, i)
      try {
        return i2(n, i, s)
      } catch (m) {
        if (QP() || (m !== null && typeof m == 'object' && typeof m.then == 'function')) throw m
        if ((cm(), ow(), c2(n, i), J2(i, c), i.mode & on && db(i), qg(null, i2, null, n, i, s), b3())) {
          var f = Gg()
          typeof f == 'object' &&
            f !== null &&
            f._suppressLogging &&
            typeof m == 'object' &&
            m !== null &&
            !m._suppressLogging &&
            (m._suppressLogging = !0)
        }
        throw m
      }
    }
  }
  var Y2 = !1,
    fE
  fE = new Set()
  function $F(n) {
    if (Ps && !A7())
      switch (n.tag) {
        case h:
        case A:
        case H: {
          var i = (_n && bt(_n)) || 'Unknown',
            s = i
          if (!fE.has(s)) {
            fE.add(s)
            var c = bt(n) || 'Unknown'
            l(
              'Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render',
              c,
              i,
              i
            )
          }
          break
        }
        case p: {
          Y2 ||
            (l(
              'Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.'
            ),
            (Y2 = !0))
          break
        }
      }
  }
  function _d(n, i) {
    if (Zi) {
      var s = n.memoizedUpdaters
      s.forEach(function (c) {
        mT(n, c, i)
      })
    }
  }
  var dE = {}
  function hE(n, i) {
    {
      var s = la.current
      return s !== null ? (s.push(i), dE) : tT(n, i)
    }
  }
  function q2(n) {
    if (n !== dE) return O3(n)
  }
  function G2() {
    return la.current !== null
  }
  function BF(n) {
    {
      if (n.mode & Lt) {
        if (!w2()) return
      } else if (!uF() || Pt !== Xn || (n.tag !== h && n.tag !== A && n.tag !== H)) return
      if (la.current === null) {
        var i = Rr
        try {
          Rn(n),
            l(
              `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`,
              bt(n)
            )
        } finally {
          i ? Rn(n) : ar()
        }
      }
    }
  }
  function zF(n) {
    n.tag !== Zo &&
      w2() &&
      la.current === null &&
      l(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`)
  }
  function Od(n) {
    D2 = n
  }
  var $i = null,
    $u = null,
    HF = function (n) {
      $i = n
    }
  function Bu(n) {
    {
      if ($i === null) return n
      var i = $i(n)
      return i === void 0 ? n : i.current
    }
  }
  function pE(n) {
    return Bu(n)
  }
  function mE(n) {
    {
      if ($i === null) return n
      var i = $i(n)
      if (i === void 0) {
        if (n != null && typeof n.render == 'function') {
          var s = Bu(n.render)
          if (n.render !== s) {
            var c = { $$typeof: ne, render: s }
            return n.displayName !== void 0 && (c.displayName = n.displayName), c
          }
        }
        return n
      }
      return i.current
    }
  }
  function K2(n, i) {
    {
      if ($i === null) return !1
      var s = n.elementType,
        c = i.type,
        f = !1,
        m = typeof c == 'object' && c !== null ? c.$$typeof : null
      switch (n.tag) {
        case p: {
          typeof c == 'function' && (f = !0)
          break
        }
        case h: {
          ;(typeof c == 'function' || m === ke) && (f = !0)
          break
        }
        case A: {
          ;(m === ne || m === ke) && (f = !0)
          break
        }
        case z:
        case H: {
          ;(m === Qe || m === ke) && (f = !0)
          break
        }
        default:
          return !1
      }
      if (f) {
        var y = $i(s)
        if (y !== void 0 && y === $i(c)) return !0
      }
      return !1
    }
  }
  function Z2(n) {
    {
      if ($i === null || typeof WeakSet != 'function') return
      $u === null && ($u = new WeakSet()), $u.add(n)
    }
  }
  var WF = function (n, i) {
      {
        if ($i === null) return
        var s = i.staleFamilies,
          c = i.updatedFamilies
        go(),
          vo(function () {
            vE(n.current, c, s)
          })
      }
    },
    YF = function (n, i) {
      {
        if (n.context !== bi) return
        go(),
          vo(function () {
            kd(i, n, null, null)
          })
      }
    }
  function vE(n, i, s) {
    {
      var c = n.alternate,
        f = n.child,
        m = n.sibling,
        y = n.tag,
        b = n.type,
        S = null
      switch (y) {
        case h:
        case H:
        case p:
          S = b
          break
        case A:
          S = b.render
          break
      }
      if ($i === null) throw new Error('Expected resolveFamily to be set during hot reload.')
      var O = !1,
        N = !1
      if (S !== null) {
        var U = $i(S)
        U !== void 0 && (s.has(U) ? (N = !0) : i.has(U) && (y === p ? (N = !0) : (O = !0)))
      }
      if (
        ($u !== null && ($u.has(n) || (c !== null && $u.has(c))) && (N = !0),
        N && (n._debugNeedsRemount = !0),
        N || O)
      ) {
        var j = ii(n, ct)
        j !== null && er(j, n, ct, vn)
      }
      f !== null && !N && vE(f, i, s), m !== null && vE(m, i, s)
    }
  }
  var qF = function (n, i) {
    {
      var s = new Set(),
        c = new Set(
          i.map(function (f) {
            return f.current
          })
        )
      return gE(n.current, c, s), s
    }
  }
  function gE(n, i, s) {
    {
      var c = n.child,
        f = n.sibling,
        m = n.tag,
        y = n.type,
        b = null
      switch (m) {
        case h:
        case H:
        case p:
          b = y
          break
        case A:
          b = y.render
          break
      }
      var S = !1
      b !== null && i.has(b) && (S = !0),
        S ? GF(n, s) : c !== null && gE(c, i, s),
        f !== null && gE(f, i, s)
    }
  }
  function GF(n, i) {
    {
      var s = KF(n, i)
      if (s) return
      for (var c = n; ; ) {
        switch (c.tag) {
          case x:
            i.add(c.stateNode)
            return
          case E:
            i.add(c.stateNode.containerInfo)
            return
          case g:
            i.add(c.stateNode.containerInfo)
            return
        }
        if (c.return === null) throw new Error('Expected to reach root first.')
        c = c.return
      }
    }
  }
  function KF(n, i) {
    for (var s = n, c = !1; ; ) {
      if (s.tag === x) (c = !0), i.add(s.stateNode)
      else if (s.child !== null) {
        ;(s.child.return = s), (s = s.child)
        continue
      }
      if (s === n) return c
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === n) return c
        s = s.return
      }
      ;(s.sibling.return = s.return), (s = s.sibling)
    }
    return !1
  }
  var yE
  {
    yE = !1
    try {
      var X2 = Object.preventExtensions({})
    } catch {
      yE = !0
    }
  }
  function ZF(n, i, s, c) {
    ;(this.tag = n),
      (this.key = s),
      (this.elementType = null),
      (this.type = null),
      (this.stateNode = null),
      (this.return = null),
      (this.child = null),
      (this.sibling = null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = i),
      (this.memoizedProps = null),
      (this.updateQueue = null),
      (this.memoizedState = null),
      (this.dependencies = null),
      (this.mode = c),
      (this.flags = et),
      (this.subtreeFlags = et),
      (this.deletions = null),
      (this.lanes = fe),
      (this.childLanes = fe),
      (this.alternate = null),
      (this.actualDuration = Number.NaN),
      (this.actualStartTime = Number.NaN),
      (this.selfBaseDuration = Number.NaN),
      (this.treeBaseDuration = Number.NaN),
      (this.actualDuration = 0),
      (this.actualStartTime = -1),
      (this.selfBaseDuration = 0),
      (this.treeBaseDuration = 0),
      (this._debugSource = null),
      (this._debugOwner = null),
      (this._debugNeedsRemount = !1),
      (this._debugHookTypes = null),
      !yE && typeof Object.preventExtensions == 'function' && Object.preventExtensions(this)
  }
  var Ei = function (n, i, s, c) {
    return new ZF(n, i, s, c)
  }
  function bE(n) {
    var i = n.prototype
    return !!(i && i.isReactComponent)
  }
  function XF(n) {
    return typeof n == 'function' && !bE(n) && n.defaultProps === void 0
  }
  function QF(n) {
    if (typeof n == 'function') return bE(n) ? p : h
    if (n != null) {
      var i = n.$$typeof
      if (i === ne) return A
      if (i === Qe) return z
    }
    return v
  }
  function fl(n, i) {
    var s = n.alternate
    s === null
      ? ((s = Ei(n.tag, i, n.key, n.mode)),
        (s.elementType = n.elementType),
        (s.type = n.type),
        (s.stateNode = n.stateNode),
        (s._debugSource = n._debugSource),
        (s._debugOwner = n._debugOwner),
        (s._debugHookTypes = n._debugHookTypes),
        (s.alternate = n),
        (n.alternate = s))
      : ((s.pendingProps = i),
        (s.type = n.type),
        (s.flags = et),
        (s.subtreeFlags = et),
        (s.deletions = null),
        (s.actualDuration = 0),
        (s.actualStartTime = -1)),
      (s.flags = n.flags & no),
      (s.childLanes = n.childLanes),
      (s.lanes = n.lanes),
      (s.child = n.child),
      (s.memoizedProps = n.memoizedProps),
      (s.memoizedState = n.memoizedState),
      (s.updateQueue = n.updateQueue)
    var c = n.dependencies
    switch (
      ((s.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
      (s.sibling = n.sibling),
      (s.index = n.index),
      (s.ref = n.ref),
      (s.selfBaseDuration = n.selfBaseDuration),
      (s.treeBaseDuration = n.treeBaseDuration),
      (s._debugNeedsRemount = n._debugNeedsRemount),
      s.tag)
    ) {
      case v:
      case h:
      case H:
        s.type = Bu(n.type)
        break
      case p:
        s.type = pE(n.type)
        break
      case A:
        s.type = mE(n.type)
        break
    }
    return s
  }
  function JF(n, i) {
    n.flags &= no | zn
    var s = n.alternate
    if (s === null)
      (n.childLanes = fe),
        (n.lanes = i),
        (n.child = null),
        (n.subtreeFlags = et),
        (n.memoizedProps = null),
        (n.memoizedState = null),
        (n.updateQueue = null),
        (n.dependencies = null),
        (n.stateNode = null),
        (n.selfBaseDuration = 0),
        (n.treeBaseDuration = 0)
    else {
      ;(n.childLanes = s.childLanes),
        (n.lanes = s.lanes),
        (n.child = s.child),
        (n.subtreeFlags = et),
        (n.deletions = null),
        (n.memoizedProps = s.memoizedProps),
        (n.memoizedState = s.memoizedState),
        (n.updateQueue = s.updateQueue),
        (n.type = s.type)
      var c = s.dependencies
      ;(n.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }),
        (n.selfBaseDuration = s.selfBaseDuration),
        (n.treeBaseDuration = s.treeBaseDuration)
    }
    return n
  }
  function e6(n, i, s) {
    var c
    return (
      n === em ? ((c = Lt), i === !0 && ((c |= Nn), (c |= Ca))) : (c = Je),
      Zi && (c |= on),
      Ei(g, null, null, c)
    )
  }
  function EE(n, i, s, c, f, m) {
    var y = v,
      b = n
    if (typeof n == 'function') bE(n) ? ((y = p), (b = pE(b))) : (b = Bu(b))
    else if (typeof n == 'string') y = x
    else
      e: switch (n) {
        case P:
          return us(s.children, f, m, i)
        case ce:
          ;(y = k), (f |= Nn), (f & Lt) !== Je && (f |= Ca)
          break
        case Te:
          return t6(s, f, m, i)
        case Ee:
          return n6(s, f, m, i)
        case _e:
          return r6(s, f, m, i)
        case re:
          return Q2(s, f, m, i)
        case ye:
        case ae:
        case qe:
        case tn:
        case V:
        default: {
          if (typeof n == 'object' && n !== null)
            switch (n.$$typeof) {
              case M:
                y = D
                break e
              case X:
                y = R
                break e
              case ne:
                ;(y = A), (b = mE(b))
                break e
              case Qe:
                y = z
                break e
              case ke:
                ;(y = $), (b = null)
                break e
            }
          var S = ''
          {
            ;(n === void 0 || (typeof n == 'object' && n !== null && Object.keys(n).length === 0)) &&
              (S +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
            var O = c ? bt(c) : null
            O &&
              (S +=
                `

Check the render method of \`` +
                O +
                '`.')
          }
          throw new Error(
            'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) ' +
              ('but got: ' + (n == null ? n : typeof n) + '.' + S)
          )
        }
      }
    var N = Ei(y, s, i, f)
    return (N.elementType = n), (N.type = b), (N.lanes = m), (N._debugOwner = c), N
  }
  function xE(n, i, s) {
    var c = null
    c = n._owner
    var f = n.type,
      m = n.key,
      y = n.props,
      b = EE(f, m, y, c, i, s)
    return (b._debugSource = n._source), (b._debugOwner = n._owner), b
  }
  function us(n, i, s, c) {
    var f = Ei(_, n, c, i)
    return (f.lanes = s), f
  }
  function t6(n, i, s, c) {
    typeof n.id != 'string' &&
      l(
        'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
        typeof n.id
      )
    var f = Ei(L, n, c, i | on)
    return (
      (f.elementType = Te),
      (f.lanes = s),
      (f.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
      f
    )
  }
  function n6(n, i, s, c) {
    var f = Ei(F, n, c, i)
    return (f.elementType = Ee), (f.lanes = s), f
  }
  function r6(n, i, s, c) {
    var f = Ei(se, n, c, i)
    return (f.elementType = _e), (f.lanes = s), f
  }
  function Q2(n, i, s, c) {
    var f = Ei(he, n, c, i)
    ;(f.elementType = re), (f.lanes = s)
    var m = { isHidden: !1 }
    return (f.stateNode = m), f
  }
  function SE(n, i, s) {
    var c = Ei(C, n, null, i)
    return (c.lanes = s), c
  }
  function i6() {
    var n = Ei(x, null, null, Je)
    return (n.elementType = 'DELETED'), n
  }
  function a6(n) {
    var i = Ei(ue, null, null, Je)
    return (i.stateNode = n), i
  }
  function TE(n, i, s) {
    var c = n.children !== null ? n.children : [],
      f = Ei(E, c, n.key, i)
    return (
      (f.lanes = s),
      (f.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
      }),
      f
    )
  }
  function J2(n, i) {
    return (
      n === null && (n = Ei(v, null, null, Je)),
      (n.tag = i.tag),
      (n.key = i.key),
      (n.elementType = i.elementType),
      (n.type = i.type),
      (n.stateNode = i.stateNode),
      (n.return = i.return),
      (n.child = i.child),
      (n.sibling = i.sibling),
      (n.index = i.index),
      (n.ref = i.ref),
      (n.pendingProps = i.pendingProps),
      (n.memoizedProps = i.memoizedProps),
      (n.updateQueue = i.updateQueue),
      (n.memoizedState = i.memoizedState),
      (n.dependencies = i.dependencies),
      (n.mode = i.mode),
      (n.flags = i.flags),
      (n.subtreeFlags = i.subtreeFlags),
      (n.deletions = i.deletions),
      (n.lanes = i.lanes),
      (n.childLanes = i.childLanes),
      (n.alternate = i.alternate),
      (n.actualDuration = i.actualDuration),
      (n.actualStartTime = i.actualStartTime),
      (n.selfBaseDuration = i.selfBaseDuration),
      (n.treeBaseDuration = i.treeBaseDuration),
      (n._debugSource = i._debugSource),
      (n._debugOwner = i._debugOwner),
      (n._debugNeedsRemount = i._debugNeedsRemount),
      (n._debugHookTypes = i._debugHookTypes),
      n
    )
  }
  function o6(n, i, s, c, f) {
    ;(this.tag = i),
      (this.containerInfo = n),
      (this.pendingChildren = null),
      (this.current = null),
      (this.pingCache = null),
      (this.finishedWork = null),
      (this.timeoutHandle = iy),
      (this.context = null),
      (this.pendingContext = null),
      (this.callbackNode = null),
      (this.callbackPriority = lr),
      (this.eventTimes = _0(fe)),
      (this.expirationTimes = _0(vn)),
      (this.pendingLanes = fe),
      (this.suspendedLanes = fe),
      (this.pingedLanes = fe),
      (this.expiredLanes = fe),
      (this.mutableReadLanes = fe),
      (this.finishedLanes = fe),
      (this.entangledLanes = fe),
      (this.entanglements = _0(fe)),
      (this.identifierPrefix = c),
      (this.onRecoverableError = f),
      (this.mutableSourceEagerHydrationData = null),
      (this.effectDuration = 0),
      (this.passiveEffectDuration = 0)
    {
      this.memoizedUpdaters = new Set()
      for (var m = (this.pendingUpdatersLaneMap = []), y = 0; y < i0; y++) m.push(new Set())
    }
    switch (i) {
      case em:
        this._debugRootType = s ? 'hydrateRoot()' : 'createRoot()'
        break
      case Zo:
        this._debugRootType = s ? 'hydrate()' : 'render()'
        break
    }
  }
  function eR(n, i, s, c, f, m, y, b, S, O) {
    var N = new o6(n, i, s, b, S),
      U = e6(i, m)
    ;(N.current = U), (U.stateNode = N)
    {
      var j = {
        element: c,
        isDehydrated: s,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
      }
      U.memoizedState = j
    }
    return Iy(U), N
  }
  var CE = '18.3.1'
  function s6(n, i, s) {
    var c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
    return (
      xn(c),
      { $$typeof: ir, key: c == null ? null : '' + c, children: n, containerInfo: i, implementation: s }
    )
  }
  var wE, RE
  ;(wE = !1), (RE = {})
  function tR(n) {
    if (!n) return bi
    var i = nu(n),
      s = zP(i)
    if (i.tag === p) {
      var c = i.type
      if (_a(c)) return OC(i, c, s)
    }
    return s
  }
  function l6(n, i) {
    {
      var s = nu(n)
      if (s === void 0) {
        if (typeof n.render == 'function')
          throw new Error('Unable to find node on an unmounted component.')
        var c = Object.keys(n).join(',')
        throw new Error('Argument appears to not be a ReactComponent. Keys: ' + c)
      }
      var f = Q1(s)
      if (f === null) return null
      if (f.mode & Nn) {
        var m = bt(s) || 'Component'
        if (!RE[m]) {
          RE[m] = !0
          var y = Rr
          try {
            Rn(f),
              s.mode & Nn
                ? l(
                    '%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
                    i,
                    i,
                    m
                  )
                : l(
                    '%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
                    i,
                    i,
                    m
                  )
          } finally {
            y ? Rn(y) : ar()
          }
        }
      }
      return f.stateNode
    }
  }
  function nR(n, i, s, c, f, m, y, b) {
    var S = !1,
      O = null
    return eR(n, i, S, O, s, c, f, m, y)
  }
  function rR(n, i, s, c, f, m, y, b, S, O) {
    var N = !0,
      U = eR(s, c, N, n, f, m, y, b, S)
    U.context = tR(null)
    var j = U.current,
      q = Hr(),
      Z = ss(j),
      ee = fo(q, Z)
    return (ee.callback = i ?? null), Jo(j, ee, Z), mF(U, Z, q), U
  }
  function kd(n, i, s, c) {
    I3(i, n)
    var f = i.current,
      m = Hr(),
      y = ss(f)
    nL(y)
    var b = tR(s)
    i.context === null ? (i.context = b) : (i.pendingContext = b),
      Ps &&
        Rr !== null &&
        !wE &&
        ((wE = !0),
        l(
          `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
          bt(Rr) || 'Unknown'
        ))
    var S = fo(m, y)
    ;(S.payload = { element: n }),
      (c = c === void 0 ? null : c),
      c !== null &&
        (typeof c != 'function' &&
          l(
            'render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
            c
          ),
        (S.callback = c))
    var O = Jo(f, S, y)
    return O !== null && (er(O, f, y, m), mm(O, f, y)), y
  }
  function iv(n) {
    var i = n.current
    if (!i.child) return null
    switch (i.child.tag) {
      case x:
        return i.child.stateNode
      default:
        return i.child.stateNode
    }
  }
  function u6(n) {
    switch (n.tag) {
      case g: {
        var i = n.stateNode
        if (Cp(i)) {
          var s = fL(i)
          bF(i, s)
        }
        break
      }
      case F: {
        vo(function () {
          var f = ii(n, ct)
          if (f !== null) {
            var m = Hr()
            er(f, n, ct, m)
          }
        })
        var c = ct
        _E(n, c)
        break
      }
    }
  }
  function iR(n, i) {
    var s = n.memoizedState
    s !== null && s.dehydrated !== null && (s.retryLane = gL(s.retryLane, i))
  }
  function _E(n, i) {
    iR(n, i)
    var s = n.alternate
    s && iR(s, i)
  }
  function c6(n) {
    if (n.tag === F) {
      var i = pf,
        s = ii(n, i)
      if (s !== null) {
        var c = Hr()
        er(s, n, i, c)
      }
      _E(n, i)
    }
  }
  function f6(n) {
    if (n.tag === F) {
      var i = ss(n),
        s = ii(n, i)
      if (s !== null) {
        var c = Hr()
        er(s, n, i, c)
      }
      _E(n, i)
    }
  }
  function aR(n) {
    var i = _3(n)
    return i === null ? null : i.stateNode
  }
  var oR = function (n) {
    return null
  }
  function d6(n) {
    return oR(n)
  }
  var sR = function (n) {
    return !1
  }
  function h6(n) {
    return sR(n)
  }
  var lR = null,
    uR = null,
    cR = null,
    fR = null,
    dR = null,
    hR = null,
    pR = null,
    mR = null,
    vR = null
  {
    var gR = function (n, i, s) {
        var c = i[s],
          f = Zt(n) ? n.slice() : vt({}, n)
        return s + 1 === i.length
          ? (Zt(f) ? f.splice(c, 1) : delete f[c], f)
          : ((f[c] = gR(n[c], i, s + 1)), f)
      },
      yR = function (n, i) {
        return gR(n, i, 0)
      },
      bR = function (n, i, s, c) {
        var f = i[c],
          m = Zt(n) ? n.slice() : vt({}, n)
        if (c + 1 === i.length) {
          var y = s[c]
          ;(m[y] = m[f]), Zt(m) ? m.splice(f, 1) : delete m[f]
        } else m[f] = bR(n[f], i, s, c + 1)
        return m
      },
      ER = function (n, i, s) {
        if (i.length !== s.length) {
          u('copyWithRename() expects paths of the same length')
          return
        } else
          for (var c = 0; c < s.length - 1; c++)
            if (i[c] !== s[c]) {
              u('copyWithRename() expects paths to be the same except for the deepest key')
              return
            }
        return bR(n, i, s, 0)
      },
      xR = function (n, i, s, c) {
        if (s >= i.length) return c
        var f = i[s],
          m = Zt(n) ? n.slice() : vt({}, n)
        return (m[f] = xR(n[f], i, s + 1, c)), m
      },
      SR = function (n, i, s) {
        return xR(n, i, 0, s)
      },
      OE = function (n, i) {
        for (var s = n.memoizedState; s !== null && i > 0; ) (s = s.next), i--
        return s
      }
    ;(lR = function (n, i, s, c) {
      var f = OE(n, i)
      if (f !== null) {
        var m = SR(f.memoizedState, s, c)
        ;(f.memoizedState = m), (f.baseState = m), (n.memoizedProps = vt({}, n.memoizedProps))
        var y = ii(n, ct)
        y !== null && er(y, n, ct, vn)
      }
    }),
      (uR = function (n, i, s) {
        var c = OE(n, i)
        if (c !== null) {
          var f = yR(c.memoizedState, s)
          ;(c.memoizedState = f), (c.baseState = f), (n.memoizedProps = vt({}, n.memoizedProps))
          var m = ii(n, ct)
          m !== null && er(m, n, ct, vn)
        }
      }),
      (cR = function (n, i, s, c) {
        var f = OE(n, i)
        if (f !== null) {
          var m = ER(f.memoizedState, s, c)
          ;(f.memoizedState = m), (f.baseState = m), (n.memoizedProps = vt({}, n.memoizedProps))
          var y = ii(n, ct)
          y !== null && er(y, n, ct, vn)
        }
      }),
      (fR = function (n, i, s) {
        ;(n.pendingProps = SR(n.memoizedProps, i, s)),
          n.alternate && (n.alternate.pendingProps = n.pendingProps)
        var c = ii(n, ct)
        c !== null && er(c, n, ct, vn)
      }),
      (dR = function (n, i) {
        ;(n.pendingProps = yR(n.memoizedProps, i)),
          n.alternate && (n.alternate.pendingProps = n.pendingProps)
        var s = ii(n, ct)
        s !== null && er(s, n, ct, vn)
      }),
      (hR = function (n, i, s) {
        ;(n.pendingProps = ER(n.memoizedProps, i, s)),
          n.alternate && (n.alternate.pendingProps = n.pendingProps)
        var c = ii(n, ct)
        c !== null && er(c, n, ct, vn)
      }),
      (pR = function (n) {
        var i = ii(n, ct)
        i !== null && er(i, n, ct, vn)
      }),
      (mR = function (n) {
        oR = n
      }),
      (vR = function (n) {
        sR = n
      })
  }
  function p6(n) {
    var i = Q1(n)
    return i === null ? null : i.stateNode
  }
  function m6(n) {
    return null
  }
  function v6() {
    return Rr
  }
  function g6(n) {
    var i = n.findFiberByHostInstance,
      s = r.ReactCurrentDispatcher
    return P3({
      bundleType: n.bundleType,
      version: n.version,
      rendererPackageName: n.rendererPackageName,
      rendererConfig: n.rendererConfig,
      overrideHookState: lR,
      overrideHookStateDeletePath: uR,
      overrideHookStateRenamePath: cR,
      overrideProps: fR,
      overridePropsDeletePath: dR,
      overridePropsRenamePath: hR,
      setErrorHandler: mR,
      setSuspenseHandler: vR,
      scheduleUpdate: pR,
      currentDispatcherRef: s,
      findHostInstanceByFiber: p6,
      findFiberByHostInstance: i || m6,
      findHostInstancesForRefresh: qF,
      scheduleRefresh: WF,
      scheduleRoot: YF,
      setRefreshHandler: HF,
      getCurrentFiber: v6,
      reconcilerVersion: CE
    })
  }
  var TR =
    typeof reportError == 'function'
      ? reportError
      : function (n) {
          console.error(n)
        }
  function kE(n) {
    this._internalRoot = n
  }
  ;(av.prototype.render = kE.prototype.render =
    function (n) {
      var i = this._internalRoot
      if (i === null) throw new Error('Cannot update an unmounted root.')
      {
        typeof arguments[1] == 'function'
          ? l(
              'render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
            )
          : ov(arguments[1])
            ? l(
                "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
              )
            : typeof arguments[1] < 'u' &&
              l('You passed a second argument to root.render(...) but it only accepts one argument.')
        var s = i.containerInfo
        if (s.nodeType !== Bn) {
          var c = aR(i.current)
          c &&
            c.parentNode !== s &&
            l(
              "render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container."
            )
        }
      }
      kd(n, i, null, null)
    }),
    (av.prototype.unmount = kE.prototype.unmount =
      function () {
        typeof arguments[0] == 'function' &&
          l(
            'unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
          )
        var n = this._internalRoot
        if (n !== null) {
          this._internalRoot = null
          var i = n.containerInfo
          P2() &&
            l(
              'Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.'
            ),
            vo(function () {
              kd(null, n, null, null)
            }),
            TC(i)
        }
      })
  function y6(n, i) {
    if (!ov(n)) throw new Error('createRoot(...): Target container is not a DOM element.')
    CR(n)
    var s = !1,
      c = !1,
      f = '',
      m = TR
    i != null &&
      (i.hydrate
        ? u(
            'hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.'
          )
        : typeof i == 'object' &&
          i !== null &&
          i.$$typeof === Sn &&
          l(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`),
      i.unstable_strictMode === !0 && (s = !0),
      i.identifierPrefix !== void 0 && (f = i.identifierPrefix),
      i.onRecoverableError !== void 0 && (m = i.onRecoverableError),
      i.transitionCallbacks !== void 0 && i.transitionCallbacks)
    var y = nR(n, em, null, s, c, f, m)
    qp(y.current, n)
    var b = n.nodeType === Bn ? n.parentNode : n
    return Pf(b), new kE(y)
  }
  function av(n) {
    this._internalRoot = n
  }
  function b6(n) {
    n && LL(n)
  }
  av.prototype.unstable_scheduleHydration = b6
  function E6(n, i, s) {
    if (!ov(n)) throw new Error('hydrateRoot(...): Target container is not a DOM element.')
    CR(n),
      i === void 0 &&
        l(
          'Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)'
        )
    var c = s ?? null,
      f = (s != null && s.hydratedSources) || null,
      m = !1,
      y = !1,
      b = '',
      S = TR
    s != null &&
      (s.unstable_strictMode === !0 && (m = !0),
      s.identifierPrefix !== void 0 && (b = s.identifierPrefix),
      s.onRecoverableError !== void 0 && (S = s.onRecoverableError))
    var O = rR(i, null, n, em, c, m, y, b, S)
    if ((qp(O.current, n), Pf(n), f))
      for (var N = 0; N < f.length; N++) {
        var U = f[N]
        C7(O, U)
      }
    return new av(O)
  }
  function ov(n) {
    return !!(n && (n.nodeType === ni || n.nodeType === Qa || n.nodeType === Ig || !Ue))
  }
  function Ad(n) {
    return !!(
      n &&
      (n.nodeType === ni ||
        n.nodeType === Qa ||
        n.nodeType === Ig ||
        (n.nodeType === Bn && n.nodeValue === ' react-mount-point-unstable '))
    )
  }
  function CR(n) {
    n.nodeType === ni &&
      n.tagName &&
      n.tagName.toUpperCase() === 'BODY' &&
      l(
        'createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.'
      ),
      Yf(n) &&
        (n._reactRootContainer
          ? l(
              'You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.'
            )
          : l(
              'You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.'
            ))
  }
  var x6 = r.ReactCurrentOwner,
    wR
  wR = function (n) {
    if (n._reactRootContainer && n.nodeType !== Bn) {
      var i = aR(n._reactRootContainer.current)
      i &&
        i.parentNode !== n &&
        l(
          'render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.'
        )
    }
    var s = !!n._reactRootContainer,
      c = AE(n),
      f = !!(c && Go(c))
    f &&
      !s &&
      l(
        'render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.'
      ),
      n.nodeType === ni &&
        n.tagName &&
        n.tagName.toUpperCase() === 'BODY' &&
        l(
          'render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.'
        )
  }
  function AE(n) {
    return n ? (n.nodeType === Qa ? n.documentElement : n.firstChild) : null
  }
  function RR() {}
  function S6(n, i, s, c, f) {
    if (f) {
      if (typeof c == 'function') {
        var m = c
        c = function () {
          var j = iv(y)
          m.call(j)
        }
      }
      var y = rR(i, c, n, Zo, null, !1, !1, '', RR)
      ;(n._reactRootContainer = y), qp(y.current, n)
      var b = n.nodeType === Bn ? n.parentNode : n
      return Pf(b), vo(), y
    } else {
      for (var S; (S = n.lastChild); ) n.removeChild(S)
      if (typeof c == 'function') {
        var O = c
        c = function () {
          var j = iv(N)
          O.call(j)
        }
      }
      var N = nR(n, Zo, null, !1, !1, '', RR)
      ;(n._reactRootContainer = N), qp(N.current, n)
      var U = n.nodeType === Bn ? n.parentNode : n
      return (
        Pf(U),
        vo(function () {
          kd(i, N, s, c)
        }),
        N
      )
    }
  }
  function T6(n, i) {
    n !== null &&
      typeof n != 'function' &&
      l(
        '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
        i,
        n
      )
  }
  function sv(n, i, s, c, f) {
    wR(s), T6(f === void 0 ? null : f, 'render')
    var m = s._reactRootContainer,
      y
    if (!m) y = S6(s, i, n, f, c)
    else {
      if (((y = m), typeof f == 'function')) {
        var b = f
        f = function () {
          var S = iv(y)
          b.call(S)
        }
      }
      kd(i, y, n, f)
    }
    return iv(y)
  }
  var _R = !1
  function C6(n) {
    {
      _R ||
        ((_R = !0),
        l(
          'findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node'
        ))
      var i = x6.current
      if (i !== null && i.stateNode !== null) {
        var s = i.stateNode._warnedAboutRefsInRender
        s ||
          l(
            '%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
            Bt(i.type) || 'A component'
          ),
          (i.stateNode._warnedAboutRefsInRender = !0)
      }
    }
    return n == null ? null : n.nodeType === ni ? n : l6(n, 'findDOMNode')
  }
  function w6(n, i, s) {
    if (
      (l(
        "ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !Ad(i))
    )
      throw new Error('Target container is not a DOM element.')
    {
      var c = Yf(i) && i._reactRootContainer === void 0
      c &&
        l(
          'You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?'
        )
    }
    return sv(null, n, i, !0, s)
  }
  function R6(n, i, s) {
    if (
      (l(
        "ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !Ad(i))
    )
      throw new Error('Target container is not a DOM element.')
    {
      var c = Yf(i) && i._reactRootContainer === void 0
      c &&
        l(
          'You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?'
        )
    }
    return sv(null, n, i, !1, s)
  }
  function _6(n, i, s, c) {
    if (
      (l(
        "ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !Ad(s))
    )
      throw new Error('Target container is not a DOM element.')
    if (n == null || !E3(n)) throw new Error('parentComponent must be a valid React Component')
    return sv(n, i, s, !1, c)
  }
  var OR = !1
  function O6(n) {
    if (
      (OR ||
        ((OR = !0),
        l(
          'unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot'
        )),
      !Ad(n))
    )
      throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.')
    {
      var i = Yf(n) && n._reactRootContainer === void 0
      i &&
        l(
          'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?'
        )
    }
    if (n._reactRootContainer) {
      {
        var s = AE(n),
          c = s && !Go(s)
        c &&
          l(
            "unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React."
          )
      }
      return (
        vo(function () {
          sv(null, null, n, !1, function () {
            ;(n._reactRootContainer = null), TC(n)
          })
        }),
        !0
      )
    } else {
      {
        var f = AE(n),
          m = !!(f && Go(f)),
          y = n.nodeType === ni && Ad(n.parentNode) && !!n.parentNode._reactRootContainer
        m &&
          l(
            "unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",
            y
              ? 'You may have accidentally passed in a React root node instead of its container.'
              : 'Instead, have the parent component update its state and rerender in order to remove this component.'
          )
      }
      return !1
    }
  }
  CL(u6),
    RL(c6),
    _L(f6),
    OL(Xi),
    kL(xL),
    (typeof Map != 'function' ||
      Map.prototype == null ||
      typeof Map.prototype.forEach != 'function' ||
      typeof Set != 'function' ||
      Set.prototype == null ||
      typeof Set.prototype.clear != 'function' ||
      typeof Set.prototype.forEach != 'function') &&
      l(
        'React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills'
      ),
    u3(A5),
    d3(sE, EF, vo)
  function k6(n, i) {
    var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
    if (!ov(i)) throw new Error('Target container is not a DOM element.')
    return s6(n, i, null, s)
  }
  function A6(n, i, s, c) {
    return _6(n, i, s, c)
  }
  var DE = { usingClientEntryPoint: !1, Events: [Go, bu, Gp, U1, $1, sE] }
  function D6(n, i) {
    return (
      DE.usingClientEntryPoint ||
        l(
          'You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
        ),
      y6(n, i)
    )
  }
  function N6(n, i, s) {
    return (
      DE.usingClientEntryPoint ||
        l(
          'You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
        ),
      E6(n, i, s)
    )
  }
  function M6(n) {
    return (
      P2() &&
        l(
          'flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.'
        ),
      vo(n)
    )
  }
  var L6 = g6({
    findFiberByHostInstance: Zs,
    bundleType: 1,
    version: CE,
    rendererPackageName: 'react-dom'
  })
  if (
    !L6 &&
    Re &&
    window.top === window.self &&
    ((navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1) ||
      navigator.userAgent.indexOf('Firefox') > -1)
  ) {
    var kR = window.location.protocol
    ;/^(https?|file):$/.test(kR) &&
      console.info(
        '%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools' +
          (kR === 'file:'
            ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq`
            : ''),
        'font-weight:bold'
      )
  }
  ;(Si.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = DE),
    (Si.createPortal = k6),
    (Si.createRoot = D6),
    (Si.findDOMNode = C6),
    (Si.flushSync = M6),
    (Si.hydrate = w6),
    (Si.hydrateRoot = N6),
    (Si.render = R6),
    (Si.unmountComponentAtNode = O6),
    (Si.unstable_batchedUpdates = sE),
    (Si.unstable_renderSubtreeIntoContainer = A6),
    (Si.version = CE),
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
})()
Nk.exports = Si
var Pr = Nk.exports,
  ME = Pr
{
  var uv = ME.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  ;(Tx.createRoot = function (e, t) {
    uv.usingClientEntryPoint = !0
    try {
      return ME.createRoot(e, t)
    } finally {
      uv.usingClientEntryPoint = !1
    }
  }),
    (Tx.hydrateRoot = function (e, t, r) {
      uv.usingClientEntryPoint = !0
      try {
        return ME.hydrateRoot(e, t, r)
      } finally {
        uv.usingClientEntryPoint = !1
      }
    })
}
var Lh = class {
    constructor() {
      ;(this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this))
    }
    subscribe(e) {
      return (
        this.listeners.add(e),
        this.onSubscribe(),
        () => {
          this.listeners.delete(e), this.onUnsubscribe()
        }
      )
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  Cc = typeof window > 'u' || 'Deno' in globalThis
function Wi() {}
function B6(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function Cx(e) {
  return typeof e == 'number' && e >= 0 && e !== 1 / 0
}
function Pk(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}
function ic(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function ha(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function DR(e, t) {
  const { type: r = 'all', exact: a, fetchStatus: o, predicate: u, queryKey: l, stale: d } = e
  if (l) {
    if (a) {
      if (t.queryHash !== xS(l, t.options)) return !1
    } else if (!ah(t.queryKey, l)) return !1
  }
  if (r !== 'all') {
    const h = t.isActive()
    if ((r === 'active' && !h) || (r === 'inactive' && h)) return !1
  }
  return !(
    (typeof d == 'boolean' && t.isStale() !== d) ||
    (o && o !== t.state.fetchStatus) ||
    (u && !u(t))
  )
}
function NR(e, t) {
  const { exact: r, status: a, predicate: o, mutationKey: u } = e
  if (u) {
    if (!t.options.mutationKey) return !1
    if (r) {
      if (ih(t.options.mutationKey) !== ih(u)) return !1
    } else if (!ah(t.options.mutationKey, u)) return !1
  }
  return !((a && t.state.status !== a) || (o && !o(t)))
}
function xS(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || ih)(e)
}
function ih(e) {
  return JSON.stringify(e, (t, r) =>
    Rx(r)
      ? Object.keys(r)
          .sort()
          .reduce((a, o) => ((a[o] = r[o]), a), {})
      : r
  )
}
function ah(e, t) {
  return e === t
    ? !0
    : typeof e != typeof t
      ? !1
      : e && t && typeof e == 'object' && typeof t == 'object'
        ? !Object.keys(t).some(r => !ah(e[r], t[r]))
        : !1
}
function Ik(e, t) {
  if (e === t) return e
  const r = MR(e) && MR(t)
  if (r || (Rx(e) && Rx(t))) {
    const a = r ? e : Object.keys(e),
      o = a.length,
      u = r ? t : Object.keys(t),
      l = u.length,
      d = r ? [] : {}
    let h = 0
    for (let p = 0; p < l; p++) {
      const v = r ? p : u[p]
      ;((!r && a.includes(v)) || r) && e[v] === void 0 && t[v] === void 0
        ? ((d[v] = void 0), h++)
        : ((d[v] = Ik(e[v], t[v])), d[v] === e[v] && e[v] !== void 0 && h++)
    }
    return o === l && h === o ? e : d
  }
  return t
}
function wx(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length) return !1
  for (const r in e) if (e[r] !== t[r]) return !1
  return !0
}
function MR(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function Rx(e) {
  if (!LR(e)) return !1
  const t = e.constructor
  if (t === void 0) return !0
  const r = t.prototype
  return !(!LR(r) || !r.hasOwnProperty('isPrototypeOf') || Object.getPrototypeOf(e) !== Object.prototype)
}
function LR(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
function z6(e) {
  return new Promise(t => {
    setTimeout(t, e)
  })
}
function _x(e, t, r) {
  if (typeof r.structuralSharing == 'function') return r.structuralSharing(e, t)
  if (r.structuralSharing !== !1) {
    try {
      JSON.stringify(e), JSON.stringify(t)
    } catch (a) {
      console.error(
        `StructuralSharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${a}`
      )
    }
    return Ik(e, t)
  }
  return t
}
function H6(e, t, r = 0) {
  const a = [...e, t]
  return r && a.length > r ? a.slice(1) : a
}
function W6(e, t, r = 0) {
  const a = [t, ...e]
  return r && a.length > r ? a.slice(0, -1) : a
}
var Ox = Symbol()
function Fk(e, t) {
  return (
    e.queryFn === Ox &&
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
      ),
    !e.queryFn && t != null && t.initialPromise
      ? () => t.initialPromise
      : !e.queryFn || e.queryFn === Ox
        ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`))
        : e.queryFn
  )
}
var Rl,
  hs,
  fc,
  Ek,
  Y6 =
    ((Ek = class extends Lh {
      constructor() {
        super()
        gt(this, Rl)
        gt(this, hs)
        gt(this, fc)
        He(this, fc, t => {
          if (!Cc && window.addEventListener) {
            const r = () => t()
            return (
              window.addEventListener('visibilitychange', r, !1),
              () => {
                window.removeEventListener('visibilitychange', r)
              }
            )
          }
        })
      }
      onSubscribe() {
        B(this, hs) || this.setEventListener(B(this, fc))
      }
      onUnsubscribe() {
        var t
        this.hasListeners() || ((t = B(this, hs)) == null || t.call(this), He(this, hs, void 0))
      }
      setEventListener(t) {
        var r
        He(this, fc, t),
          (r = B(this, hs)) == null || r.call(this),
          He(
            this,
            hs,
            t(a => {
              typeof a == 'boolean' ? this.setFocused(a) : this.onFocus()
            })
          )
      }
      setFocused(t) {
        B(this, Rl) !== t && (He(this, Rl, t), this.onFocus())
      }
      onFocus() {
        const t = this.isFocused()
        this.listeners.forEach(r => {
          r(t)
        })
      }
      isFocused() {
        var t
        return typeof B(this, Rl) == 'boolean'
          ? B(this, Rl)
          : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== 'hidden'
      }
    }),
    (Rl = new WeakMap()),
    (hs = new WeakMap()),
    (fc = new WeakMap()),
    Ek),
  SS = new Y6(),
  dc,
  ps,
  hc,
  xk,
  q6 =
    ((xk = class extends Lh {
      constructor() {
        super()
        gt(this, dc, !0)
        gt(this, ps)
        gt(this, hc)
        He(this, hc, t => {
          if (!Cc && window.addEventListener) {
            const r = () => t(!0),
              a = () => t(!1)
            return (
              window.addEventListener('online', r, !1),
              window.addEventListener('offline', a, !1),
              () => {
                window.removeEventListener('online', r), window.removeEventListener('offline', a)
              }
            )
          }
        })
      }
      onSubscribe() {
        B(this, ps) || this.setEventListener(B(this, hc))
      }
      onUnsubscribe() {
        var t
        this.hasListeners() || ((t = B(this, ps)) == null || t.call(this), He(this, ps, void 0))
      }
      setEventListener(t) {
        var r
        He(this, hc, t),
          (r = B(this, ps)) == null || r.call(this),
          He(this, ps, t(this.setOnline.bind(this)))
      }
      setOnline(t) {
        B(this, dc) !== t &&
          (He(this, dc, t),
          this.listeners.forEach(a => {
            a(t)
          }))
      }
      isOnline() {
        return B(this, dc)
      }
    }),
    (dc = new WeakMap()),
    (ps = new WeakMap()),
    (hc = new WeakMap()),
    xk),
  Iv = new q6()
function G6(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}
function Vk(e) {
  return (e ?? 'online') === 'online' ? Iv.isOnline() : !0
}
var jk = class extends Error {
  constructor(e) {
    super('CancelledError'),
      (this.revert = e == null ? void 0 : e.revert),
      (this.silent = e == null ? void 0 : e.silent)
  }
}
function LE(e) {
  return e instanceof jk
}
function Uk(e) {
  let t = !1,
    r = 0,
    a = !1,
    o,
    u,
    l
  const d = new Promise((R, D) => {
      ;(u = R), (l = D)
    }),
    h = R => {
      var D
      a || (C(new jk(R)), (D = e.abort) == null || D.call(e))
    },
    p = () => {
      t = !0
    },
    v = () => {
      t = !1
    },
    g = () => SS.isFocused() && (e.networkMode === 'always' || Iv.isOnline()) && e.canRun(),
    E = () => Vk(e.networkMode) && e.canRun(),
    x = R => {
      var D
      a || ((a = !0), (D = e.onSuccess) == null || D.call(e, R), o == null || o(), u(R))
    },
    C = R => {
      var D
      a || ((a = !0), (D = e.onError) == null || D.call(e, R), o == null || o(), l(R))
    },
    _ = () =>
      new Promise(R => {
        var D
        ;(o = A => {
          ;(a || g()) && R(A)
        }),
          (D = e.onPause) == null || D.call(e)
      }).then(() => {
        var R
        ;(o = void 0), a || (R = e.onContinue) == null || R.call(e)
      }),
    k = () => {
      if (a) return
      let R
      const D = r === 0 ? e.initialPromise : void 0
      try {
        R = D ?? e.fn()
      } catch (A) {
        R = Promise.reject(A)
      }
      Promise.resolve(R)
        .then(x)
        .catch(A => {
          var $
          if (a) return
          const L = e.retry ?? (Cc ? 0 : 3),
            F = e.retryDelay ?? G6,
            z = typeof F == 'function' ? F(r, A) : F,
            H = L === !0 || (typeof L == 'number' && r < L) || (typeof L == 'function' && L(r, A))
          if (t || !H) {
            C(A)
            return
          }
          r++,
            ($ = e.onFail) == null || $.call(e, r, A),
            z6(z)
              .then(() => (g() ? void 0 : _()))
              .then(() => {
                t ? C(A) : k()
              })
        })
    }
  return {
    promise: d,
    cancel: h,
    continue: () => (o == null || o(), d),
    cancelRetry: p,
    continueRetry: v,
    canStart: E,
    start: () => (E() ? k() : _().then(k), d)
  }
}
function K6() {
  let e = [],
    t = 0,
    r = E => {
      E()
    },
    a = E => {
      E()
    },
    o = E => setTimeout(E, 0)
  const u = E => {
      o = E
    },
    l = E => {
      let x
      t++
      try {
        x = E()
      } finally {
        t--, t || p()
      }
      return x
    },
    d = E => {
      t
        ? e.push(E)
        : o(() => {
            r(E)
          })
    },
    h =
      E =>
      (...x) => {
        d(() => {
          E(...x)
        })
      },
    p = () => {
      const E = e
      ;(e = []),
        E.length &&
          o(() => {
            a(() => {
              E.forEach(x => {
                r(x)
              })
            })
          })
    }
  return {
    batch: l,
    batchCalls: h,
    schedule: d,
    setNotifyFunction: E => {
      r = E
    },
    setBatchNotifyFunction: E => {
      a = E
    },
    setScheduler: u
  }
}
var Sr = K6(),
  _l,
  Sk,
  $k =
    ((Sk = class {
      constructor() {
        gt(this, _l)
      }
      destroy() {
        this.clearGcTimeout()
      }
      scheduleGc() {
        this.clearGcTimeout(),
          Cx(this.gcTime) &&
            He(
              this,
              _l,
              setTimeout(() => {
                this.optionalRemove()
              }, this.gcTime)
            )
      }
      updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (Cc ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
        B(this, _l) && (clearTimeout(B(this, _l)), He(this, _l, void 0))
      }
    }),
    (_l = new WeakMap()),
    Sk),
  pc,
  mc,
  Hi,
  Mr,
  Ah,
  Ol,
  da,
  bo,
  Tk,
  Z6 =
    ((Tk = class extends $k {
      constructor(t) {
        super()
        gt(this, da)
        gt(this, pc)
        gt(this, mc)
        gt(this, Hi)
        gt(this, Mr)
        gt(this, Ah)
        gt(this, Ol)
        He(this, Ol, !1),
          He(this, Ah, t.defaultOptions),
          this.setOptions(t.options),
          (this.observers = []),
          He(this, Hi, t.cache),
          (this.queryKey = t.queryKey),
          (this.queryHash = t.queryHash),
          He(this, pc, X6(this.options)),
          (this.state = t.state ?? B(this, pc)),
          this.scheduleGc()
      }
      get meta() {
        return this.options.meta
      }
      get promise() {
        var t
        return (t = B(this, Mr)) == null ? void 0 : t.promise
      }
      setOptions(t) {
        ;(this.options = { ...B(this, Ah), ...t }), this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
        !this.observers.length && this.state.fetchStatus === 'idle' && B(this, Hi).remove(this)
      }
      setData(t, r) {
        const a = _x(this.state.data, t, this.options)
        return (
          zt(this, da, bo).call(this, {
            data: a,
            type: 'success',
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
          }),
          a
        )
      }
      setState(t, r) {
        zt(this, da, bo).call(this, { type: 'setState', state: t, setStateOptions: r })
      }
      cancel(t) {
        var a, o
        const r = (a = B(this, Mr)) == null ? void 0 : a.promise
        return (o = B(this, Mr)) == null || o.cancel(t), r ? r.then(Wi).catch(Wi) : Promise.resolve()
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 })
      }
      reset() {
        this.destroy(), this.setState(B(this, pc))
      }
      isActive() {
        return this.observers.some(t => ha(t.options.enabled, this) !== !1)
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive()
      }
      isStale() {
        return this.state.isInvalidated
          ? !0
          : this.getObserversCount() > 0
            ? this.observers.some(t => t.getCurrentResult().isStale)
            : this.state.data === void 0
      }
      isStaleByTime(t = 0) {
        return this.state.isInvalidated || this.state.data === void 0 || !Pk(this.state.dataUpdatedAt, t)
      }
      onFocus() {
        var r
        const t = this.observers.find(a => a.shouldFetchOnWindowFocus())
        t == null || t.refetch({ cancelRefetch: !1 }), (r = B(this, Mr)) == null || r.continue()
      }
      onOnline() {
        var r
        const t = this.observers.find(a => a.shouldFetchOnReconnect())
        t == null || t.refetch({ cancelRefetch: !1 }), (r = B(this, Mr)) == null || r.continue()
      }
      addObserver(t) {
        this.observers.includes(t) ||
          (this.observers.push(t),
          this.clearGcTimeout(),
          B(this, Hi).notify({ type: 'observerAdded', query: this, observer: t }))
      }
      removeObserver(t) {
        this.observers.includes(t) &&
          ((this.observers = this.observers.filter(r => r !== t)),
          this.observers.length ||
            (B(this, Mr) &&
              (B(this, Ol) ? B(this, Mr).cancel({ revert: !0 }) : B(this, Mr).cancelRetry()),
            this.scheduleGc()),
          B(this, Hi).notify({ type: 'observerRemoved', query: this, observer: t }))
      }
      getObserversCount() {
        return this.observers.length
      }
      invalidate() {
        this.state.isInvalidated || zt(this, da, bo).call(this, { type: 'invalidate' })
      }
      fetch(t, r) {
        var h, p, v
        if (this.state.fetchStatus !== 'idle') {
          if (this.state.data !== void 0 && r != null && r.cancelRefetch) this.cancel({ silent: !0 })
          else if (B(this, Mr)) return B(this, Mr).continueRetry(), B(this, Mr).promise
        }
        if ((t && this.setOptions(t), !this.options.queryFn)) {
          const g = this.observers.find(E => E.options.queryFn)
          g && this.setOptions(g.options)
        }
        Array.isArray(this.options.queryKey) ||
          console.error(
            "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
          )
        const a = new AbortController(),
          o = g => {
            Object.defineProperty(g, 'signal', {
              enumerable: !0,
              get: () => (He(this, Ol, !0), a.signal)
            })
          },
          u = () => {
            const g = Fk(this.options, r),
              E = { queryKey: this.queryKey, meta: this.meta }
            return (
              o(E), He(this, Ol, !1), this.options.persister ? this.options.persister(g, E, this) : g(E)
            )
          },
          l = {
            fetchOptions: r,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: u
          }
        o(l),
          (h = this.options.behavior) == null || h.onFetch(l, this),
          He(this, mc, this.state),
          (this.state.fetchStatus === 'idle' ||
            this.state.fetchMeta !== ((p = l.fetchOptions) == null ? void 0 : p.meta)) &&
            zt(this, da, bo).call(this, {
              type: 'fetch',
              meta: (v = l.fetchOptions) == null ? void 0 : v.meta
            })
        const d = g => {
          var E, x, C, _
          ;(LE(g) && g.silent) || zt(this, da, bo).call(this, { type: 'error', error: g }),
            LE(g) ||
              ((x = (E = B(this, Hi).config).onError) == null || x.call(E, g, this),
              (_ = (C = B(this, Hi).config).onSettled) == null || _.call(C, this.state.data, g, this)),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1)
        }
        return (
          He(
            this,
            Mr,
            Uk({
              initialPromise: r == null ? void 0 : r.initialPromise,
              fn: l.fetchFn,
              abort: a.abort.bind(a),
              onSuccess: g => {
                var E, x, C, _
                if (g === void 0) {
                  console.error(
                    `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
                  ),
                    d(new Error(`${this.queryHash} data is undefined`))
                  return
                }
                try {
                  this.setData(g)
                } catch (k) {
                  d(k)
                  return
                }
                ;(x = (E = B(this, Hi).config).onSuccess) == null || x.call(E, g, this),
                  (_ = (C = B(this, Hi).config).onSettled) == null ||
                    _.call(C, g, this.state.error, this),
                  this.isFetchingOptimistic || this.scheduleGc(),
                  (this.isFetchingOptimistic = !1)
              },
              onError: d,
              onFail: (g, E) => {
                zt(this, da, bo).call(this, { type: 'failed', failureCount: g, error: E })
              },
              onPause: () => {
                zt(this, da, bo).call(this, { type: 'pause' })
              },
              onContinue: () => {
                zt(this, da, bo).call(this, { type: 'continue' })
              },
              retry: l.options.retry,
              retryDelay: l.options.retryDelay,
              networkMode: l.options.networkMode,
              canRun: () => !0
            })
          ),
          B(this, Mr).start()
        )
      }
    }),
    (pc = new WeakMap()),
    (mc = new WeakMap()),
    (Hi = new WeakMap()),
    (Mr = new WeakMap()),
    (Ah = new WeakMap()),
    (Ol = new WeakMap()),
    (da = new WeakSet()),
    (bo = function (t) {
      const r = a => {
        switch (t.type) {
          case 'failed':
            return { ...a, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }
          case 'pause':
            return { ...a, fetchStatus: 'paused' }
          case 'continue':
            return { ...a, fetchStatus: 'fetching' }
          case 'fetch':
            return { ...a, ...Bk(a.data, this.options), fetchMeta: t.meta ?? null }
          case 'success':
            return {
              ...a,
              data: t.data,
              dataUpdateCount: a.dataUpdateCount + 1,
              dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: 'success',
              ...(!t.manual && { fetchStatus: 'idle', fetchFailureCount: 0, fetchFailureReason: null })
            }
          case 'error':
            const o = t.error
            return LE(o) && o.revert && B(this, mc)
              ? { ...B(this, mc), fetchStatus: 'idle' }
              : {
                  ...a,
                  error: o,
                  errorUpdateCount: a.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: a.fetchFailureCount + 1,
                  fetchFailureReason: o,
                  fetchStatus: 'idle',
                  status: 'error'
                }
          case 'invalidate':
            return { ...a, isInvalidated: !0 }
          case 'setState':
            return { ...a, ...t.state }
        }
      }
      ;(this.state = r(this.state)),
        Sr.batch(() => {
          this.observers.forEach(a => {
            a.onQueryUpdate()
          }),
            B(this, Hi).notify({ query: this, type: 'updated', action: t })
        })
    }),
    Tk)
function Bk(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: Vk(t.networkMode) ? 'fetching' : 'paused',
    ...(e === void 0 && { error: null, status: 'pending' })
  }
}
function X6(e) {
  const t = typeof e.initialData == 'function' ? e.initialData() : e.initialData,
    r = t !== void 0,
    a = r
      ? typeof e.initialDataUpdatedAt == 'function'
        ? e.initialDataUpdatedAt()
        : e.initialDataUpdatedAt
      : 0
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? (a ?? Date.now()) : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? 'success' : 'pending',
    fetchStatus: 'idle'
  }
}
var Fa,
  Ck,
  Q6 =
    ((Ck = class extends Lh {
      constructor(t = {}) {
        super()
        gt(this, Fa)
        ;(this.config = t), He(this, Fa, new Map())
      }
      build(t, r, a) {
        const o = r.queryKey,
          u = r.queryHash ?? xS(o, r)
        let l = this.get(u)
        return (
          l ||
            ((l = new Z6({
              cache: this,
              queryKey: o,
              queryHash: u,
              options: t.defaultQueryOptions(r),
              state: a,
              defaultOptions: t.getQueryDefaults(o)
            })),
            this.add(l)),
          l
        )
      }
      add(t) {
        B(this, Fa).has(t.queryHash) ||
          (B(this, Fa).set(t.queryHash, t), this.notify({ type: 'added', query: t }))
      }
      remove(t) {
        const r = B(this, Fa).get(t.queryHash)
        r &&
          (t.destroy(),
          r === t && B(this, Fa).delete(t.queryHash),
          this.notify({ type: 'removed', query: t }))
      }
      clear() {
        Sr.batch(() => {
          this.getAll().forEach(t => {
            this.remove(t)
          })
        })
      }
      get(t) {
        return B(this, Fa).get(t)
      }
      getAll() {
        return [...B(this, Fa).values()]
      }
      find(t) {
        const r = { exact: !0, ...t }
        return this.getAll().find(a => DR(r, a))
      }
      findAll(t = {}) {
        const r = this.getAll()
        return Object.keys(t).length > 0 ? r.filter(a => DR(t, a)) : r
      }
      notify(t) {
        Sr.batch(() => {
          this.listeners.forEach(r => {
            r(t)
          })
        })
      }
      onFocus() {
        Sr.batch(() => {
          this.getAll().forEach(t => {
            t.onFocus()
          })
        })
      }
      onOnline() {
        Sr.batch(() => {
          this.getAll().forEach(t => {
            t.onOnline()
          })
        })
      }
    }),
    (Fa = new WeakMap()),
    Ck),
  Va,
  Gr,
  kl,
  ja,
  cs,
  wk,
  J6 =
    ((wk = class extends $k {
      constructor(t) {
        super()
        gt(this, ja)
        gt(this, Va)
        gt(this, Gr)
        gt(this, kl)
        ;(this.mutationId = t.mutationId),
          He(this, Gr, t.mutationCache),
          He(this, Va, []),
          (this.state = t.state || e9()),
          this.setOptions(t.options),
          this.scheduleGc()
      }
      setOptions(t) {
        ;(this.options = t), this.updateGcTime(this.options.gcTime)
      }
      get meta() {
        return this.options.meta
      }
      addObserver(t) {
        B(this, Va).includes(t) ||
          (B(this, Va).push(t),
          this.clearGcTimeout(),
          B(this, Gr).notify({ type: 'observerAdded', mutation: this, observer: t }))
      }
      removeObserver(t) {
        He(
          this,
          Va,
          B(this, Va).filter(r => r !== t)
        ),
          this.scheduleGc(),
          B(this, Gr).notify({ type: 'observerRemoved', mutation: this, observer: t })
      }
      optionalRemove() {
        B(this, Va).length ||
          (this.state.status === 'pending' ? this.scheduleGc() : B(this, Gr).remove(this))
      }
      continue() {
        var t
        return ((t = B(this, kl)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
      }
      async execute(t) {
        var o, u, l, d, h, p, v, g, E, x, C, _, k, R, D, A, L, F, z, H
        He(
          this,
          kl,
          Uk({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(t)
                : Promise.reject(new Error('No mutationFn found')),
            onFail: ($, Q) => {
              zt(this, ja, cs).call(this, { type: 'failed', failureCount: $, error: Q })
            },
            onPause: () => {
              zt(this, ja, cs).call(this, { type: 'pause' })
            },
            onContinue: () => {
              zt(this, ja, cs).call(this, { type: 'continue' })
            },
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => B(this, Gr).canRun(this)
          })
        )
        const r = this.state.status === 'pending',
          a = !B(this, kl).canStart()
        try {
          if (!r) {
            zt(this, ja, cs).call(this, { type: 'pending', variables: t, isPaused: a }),
              await ((u = (o = B(this, Gr).config).onMutate) == null ? void 0 : u.call(o, t, this))
            const Q = await ((d = (l = this.options).onMutate) == null ? void 0 : d.call(l, t))
            Q !== this.state.context &&
              zt(this, ja, cs).call(this, { type: 'pending', context: Q, variables: t, isPaused: a })
          }
          const $ = await B(this, kl).start()
          return (
            await ((p = (h = B(this, Gr).config).onSuccess) == null
              ? void 0
              : p.call(h, $, t, this.state.context, this)),
            await ((g = (v = this.options).onSuccess) == null
              ? void 0
              : g.call(v, $, t, this.state.context)),
            await ((x = (E = B(this, Gr).config).onSettled) == null
              ? void 0
              : x.call(E, $, null, this.state.variables, this.state.context, this)),
            await ((_ = (C = this.options).onSettled) == null
              ? void 0
              : _.call(C, $, null, t, this.state.context)),
            zt(this, ja, cs).call(this, { type: 'success', data: $ }),
            $
          )
        } catch ($) {
          try {
            throw (
              (await ((R = (k = B(this, Gr).config).onError) == null
                ? void 0
                : R.call(k, $, t, this.state.context, this)),
              await ((A = (D = this.options).onError) == null
                ? void 0
                : A.call(D, $, t, this.state.context)),
              await ((F = (L = B(this, Gr).config).onSettled) == null
                ? void 0
                : F.call(L, void 0, $, this.state.variables, this.state.context, this)),
              await ((H = (z = this.options).onSettled) == null
                ? void 0
                : H.call(z, void 0, $, t, this.state.context)),
              $)
            )
          } finally {
            zt(this, ja, cs).call(this, { type: 'error', error: $ })
          }
        } finally {
          B(this, Gr).runNext(this)
        }
      }
    }),
    (Va = new WeakMap()),
    (Gr = new WeakMap()),
    (kl = new WeakMap()),
    (ja = new WeakSet()),
    (cs = function (t) {
      const r = a => {
        switch (t.type) {
          case 'failed':
            return { ...a, failureCount: t.failureCount, failureReason: t.error }
          case 'pause':
            return { ...a, isPaused: !0 }
          case 'continue':
            return { ...a, isPaused: !1 }
          case 'pending':
            return {
              ...a,
              context: t.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: t.isPaused,
              status: 'pending',
              variables: t.variables,
              submittedAt: Date.now()
            }
          case 'success':
            return {
              ...a,
              data: t.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: !1
            }
          case 'error':
            return {
              ...a,
              data: void 0,
              error: t.error,
              failureCount: a.failureCount + 1,
              failureReason: t.error,
              isPaused: !1,
              status: 'error'
            }
        }
      }
      ;(this.state = r(this.state)),
        Sr.batch(() => {
          B(this, Va).forEach(a => {
            a.onMutationUpdate(t)
          }),
            B(this, Gr).notify({ mutation: this, type: 'updated', action: t })
        })
    }),
    wk)
function e9() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: 'idle',
    variables: void 0,
    submittedAt: 0
  }
}
var Ti,
  Dh,
  Rk,
  t9 =
    ((Rk = class extends Lh {
      constructor(t = {}) {
        super()
        gt(this, Ti)
        gt(this, Dh)
        ;(this.config = t), He(this, Ti, new Map()), He(this, Dh, Date.now())
      }
      build(t, r, a) {
        const o = new J6({
          mutationCache: this,
          mutationId: ++lv(this, Dh)._,
          options: t.defaultMutationOptions(r),
          state: a
        })
        return this.add(o), o
      }
      add(t) {
        const r = cv(t),
          a = B(this, Ti).get(r) ?? []
        a.push(t), B(this, Ti).set(r, a), this.notify({ type: 'added', mutation: t })
      }
      remove(t) {
        var a
        const r = cv(t)
        if (B(this, Ti).has(r)) {
          const o = (a = B(this, Ti).get(r)) == null ? void 0 : a.filter(u => u !== t)
          o && (o.length === 0 ? B(this, Ti).delete(r) : B(this, Ti).set(r, o))
        }
        this.notify({ type: 'removed', mutation: t })
      }
      canRun(t) {
        var a
        const r =
          (a = B(this, Ti).get(cv(t))) == null ? void 0 : a.find(o => o.state.status === 'pending')
        return !r || r === t
      }
      runNext(t) {
        var a
        const r =
          (a = B(this, Ti).get(cv(t))) == null ? void 0 : a.find(o => o !== t && o.state.isPaused)
        return (r == null ? void 0 : r.continue()) ?? Promise.resolve()
      }
      clear() {
        Sr.batch(() => {
          this.getAll().forEach(t => {
            this.remove(t)
          })
        })
      }
      getAll() {
        return [...B(this, Ti).values()].flat()
      }
      find(t) {
        const r = { exact: !0, ...t }
        return this.getAll().find(a => NR(r, a))
      }
      findAll(t = {}) {
        return this.getAll().filter(r => NR(t, r))
      }
      notify(t) {
        Sr.batch(() => {
          this.listeners.forEach(r => {
            r(t)
          })
        })
      }
      resumePausedMutations() {
        const t = this.getAll().filter(r => r.state.isPaused)
        return Sr.batch(() => Promise.all(t.map(r => r.continue().catch(Wi))))
      }
    }),
    (Ti = new WeakMap()),
    (Dh = new WeakMap()),
    Rk)
function cv(e) {
  var t
  return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId)
}
function n9(e) {
  return {
    onFetch: (t, r) => {
      const a = async () => {
        var C, _, k, R, D
        const o = t.options,
          u =
            (k = (_ = (C = t.fetchOptions) == null ? void 0 : C.meta) == null ? void 0 : _.fetchMore) ==
            null
              ? void 0
              : k.direction,
          l = ((R = t.state.data) == null ? void 0 : R.pages) || [],
          d = ((D = t.state.data) == null ? void 0 : D.pageParams) || [],
          h = { pages: [], pageParams: [] }
        let p = !1
        const v = A => {
            Object.defineProperty(A, 'signal', {
              enumerable: !0,
              get: () => (
                t.signal.aborted
                  ? (p = !0)
                  : t.signal.addEventListener('abort', () => {
                      p = !0
                    }),
                t.signal
              )
            })
          },
          g = Fk(t.options, t.fetchOptions),
          E = async (A, L, F) => {
            if (p) return Promise.reject()
            if (L == null && A.pages.length) return Promise.resolve(A)
            const z = {
              queryKey: t.queryKey,
              pageParam: L,
              direction: F ? 'backward' : 'forward',
              meta: t.options.meta
            }
            v(z)
            const H = await g(z),
              { maxPages: $ } = t.options,
              Q = F ? W6 : H6
            return { pages: Q(A.pages, H, $), pageParams: Q(A.pageParams, L, $) }
          }
        let x
        if (u && l.length) {
          const A = u === 'backward',
            L = A ? r9 : PR,
            F = { pages: l, pageParams: d },
            z = L(o, F)
          x = await E(F, z, A)
        } else {
          x = await E(h, d[0] ?? o.initialPageParam)
          const A = e ?? l.length
          for (let L = 1; L < A; L++) {
            const F = PR(o, x)
            if (F == null) break
            x = await E(x, F)
          }
        }
        return x
      }
      t.options.persister
        ? (t.fetchFn = () => {
            var o, u
            return (u = (o = t.options).persister) == null
              ? void 0
              : u.call(o, a, { queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, r)
          })
        : (t.fetchFn = a)
    }
  }
}
function PR(e, { pages: t, pageParams: r }) {
  const a = t.length - 1
  return t.length > 0 ? e.getNextPageParam(t[a], t, r[a], r) : void 0
}
function r9(e, { pages: t, pageParams: r }) {
  var a
  return t.length > 0
    ? (a = e.getPreviousPageParam) == null
      ? void 0
      : a.call(e, t[0], t, r[0], r)
    : void 0
}
var Ln,
  ms,
  vs,
  vc,
  gc,
  gs,
  yc,
  bc,
  _k,
  i9 =
    ((_k = class {
      constructor(e = {}) {
        gt(this, Ln)
        gt(this, ms)
        gt(this, vs)
        gt(this, vc)
        gt(this, gc)
        gt(this, gs)
        gt(this, yc)
        gt(this, bc)
        He(this, Ln, e.queryCache || new Q6()),
          He(this, ms, e.mutationCache || new t9()),
          He(this, vs, e.defaultOptions || {}),
          He(this, vc, new Map()),
          He(this, gc, new Map()),
          He(this, gs, 0)
      }
      mount() {
        lv(this, gs)._++,
          B(this, gs) === 1 &&
            (He(
              this,
              yc,
              SS.subscribe(async e => {
                e && (await this.resumePausedMutations(), B(this, Ln).onFocus())
              })
            ),
            He(
              this,
              bc,
              Iv.subscribe(async e => {
                e && (await this.resumePausedMutations(), B(this, Ln).onOnline())
              })
            ))
      }
      unmount() {
        var e, t
        lv(this, gs)._--,
          B(this, gs) === 0 &&
            ((e = B(this, yc)) == null || e.call(this),
            He(this, yc, void 0),
            (t = B(this, bc)) == null || t.call(this),
            He(this, bc, void 0))
      }
      isFetching(e) {
        return B(this, Ln).findAll({ ...e, fetchStatus: 'fetching' }).length
      }
      isMutating(e) {
        return B(this, ms).findAll({ ...e, status: 'pending' }).length
      }
      getQueryData(e) {
        var r
        const t = this.defaultQueryOptions({ queryKey: e })
        return (r = B(this, Ln).get(t.queryHash)) == null ? void 0 : r.state.data
      }
      ensureQueryData(e) {
        const t = this.getQueryData(e.queryKey)
        if (t === void 0) return this.fetchQuery(e)
        {
          const r = this.defaultQueryOptions(e),
            a = B(this, Ln).build(this, r)
          return (
            e.revalidateIfStale && a.isStaleByTime(ic(r.staleTime, a)) && this.prefetchQuery(r),
            Promise.resolve(t)
          )
        }
      }
      getQueriesData(e) {
        return B(this, Ln)
          .findAll(e)
          .map(({ queryKey: t, state: r }) => {
            const a = r.data
            return [t, a]
          })
      }
      setQueryData(e, t, r) {
        const a = this.defaultQueryOptions({ queryKey: e }),
          o = B(this, Ln).get(a.queryHash),
          u = o == null ? void 0 : o.state.data,
          l = B6(t, u)
        if (l !== void 0)
          return B(this, Ln)
            .build(this, a)
            .setData(l, { ...r, manual: !0 })
      }
      setQueriesData(e, t, r) {
        return Sr.batch(() =>
          B(this, Ln)
            .findAll(e)
            .map(({ queryKey: a }) => [a, this.setQueryData(a, t, r)])
        )
      }
      getQueryState(e) {
        var r
        const t = this.defaultQueryOptions({ queryKey: e })
        return (r = B(this, Ln).get(t.queryHash)) == null ? void 0 : r.state
      }
      removeQueries(e) {
        const t = B(this, Ln)
        Sr.batch(() => {
          t.findAll(e).forEach(r => {
            t.remove(r)
          })
        })
      }
      resetQueries(e, t) {
        const r = B(this, Ln),
          a = { type: 'active', ...e }
        return Sr.batch(
          () => (
            r.findAll(e).forEach(o => {
              o.reset()
            }),
            this.refetchQueries(a, t)
          )
        )
      }
      cancelQueries(e = {}, t = {}) {
        const r = { revert: !0, ...t },
          a = Sr.batch(() =>
            B(this, Ln)
              .findAll(e)
              .map(o => o.cancel(r))
          )
        return Promise.all(a).then(Wi).catch(Wi)
      }
      invalidateQueries(e = {}, t = {}) {
        return Sr.batch(() => {
          if (
            (B(this, Ln)
              .findAll(e)
              .forEach(a => {
                a.invalidate()
              }),
            e.refetchType === 'none')
          )
            return Promise.resolve()
          const r = { ...e, type: e.refetchType ?? e.type ?? 'active' }
          return this.refetchQueries(r, t)
        })
      }
      refetchQueries(e = {}, t) {
        const r = { ...t, cancelRefetch: (t == null ? void 0 : t.cancelRefetch) ?? !0 },
          a = Sr.batch(() =>
            B(this, Ln)
              .findAll(e)
              .filter(o => !o.isDisabled())
              .map(o => {
                let u = o.fetch(void 0, r)
                return (
                  r.throwOnError || (u = u.catch(Wi)),
                  o.state.fetchStatus === 'paused' ? Promise.resolve() : u
                )
              })
          )
        return Promise.all(a).then(Wi)
      }
      fetchQuery(e) {
        const t = this.defaultQueryOptions(e)
        t.retry === void 0 && (t.retry = !1)
        const r = B(this, Ln).build(this, t)
        return r.isStaleByTime(ic(t.staleTime, r)) ? r.fetch(t) : Promise.resolve(r.state.data)
      }
      prefetchQuery(e) {
        return this.fetchQuery(e).then(Wi).catch(Wi)
      }
      fetchInfiniteQuery(e) {
        return (e.behavior = n9(e.pages)), this.fetchQuery(e)
      }
      prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(Wi).catch(Wi)
      }
      resumePausedMutations() {
        return Iv.isOnline() ? B(this, ms).resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
        return B(this, Ln)
      }
      getMutationCache() {
        return B(this, ms)
      }
      getDefaultOptions() {
        return B(this, vs)
      }
      setDefaultOptions(e) {
        He(this, vs, e)
      }
      setQueryDefaults(e, t) {
        B(this, vc).set(ih(e), { queryKey: e, defaultOptions: t })
      }
      getQueryDefaults(e) {
        const t = [...B(this, vc).values()]
        let r = {}
        return (
          t.forEach(a => {
            ah(e, a.queryKey) && (r = { ...r, ...a.defaultOptions })
          }),
          r
        )
      }
      setMutationDefaults(e, t) {
        B(this, gc).set(ih(e), { mutationKey: e, defaultOptions: t })
      }
      getMutationDefaults(e) {
        const t = [...B(this, gc).values()]
        let r = {}
        return (
          t.forEach(a => {
            ah(e, a.mutationKey) && (r = { ...r, ...a.defaultOptions })
          }),
          r
        )
      }
      defaultQueryOptions(e) {
        if (e._defaulted) return e
        const t = { ...B(this, vs).queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }
        return (
          t.queryHash || (t.queryHash = xS(t.queryKey, t)),
          t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== 'always'),
          t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
          !t.networkMode && t.persister && (t.networkMode = 'offlineFirst'),
          t.enabled !== !0 && t.queryFn === Ox && (t.enabled = !1),
          t
        )
      }
      defaultMutationOptions(e) {
        return e != null && e._defaulted
          ? e
          : {
              ...B(this, vs).mutations,
              ...((e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey)),
              ...e,
              _defaulted: !0
            }
      }
      clear() {
        B(this, Ln).clear(), B(this, ms).clear()
      }
    }),
    (Ln = new WeakMap()),
    (ms = new WeakMap()),
    (vs = new WeakMap()),
    (vc = new WeakMap()),
    (gc = new WeakMap()),
    (gs = new WeakMap()),
    (yc = new WeakMap()),
    (bc = new WeakMap()),
    _k),
  li,
  Ht,
  Nh,
  Kr,
  Al,
  Ec,
  Ua,
  Mh,
  xc,
  Sc,
  Dl,
  Nl,
  ys,
  Tc,
  cn,
  $d,
  kx,
  Ax,
  Dx,
  Nx,
  Mx,
  Lx,
  Px,
  zk,
  Ok,
  a9 =
    ((Ok = class extends Lh {
      constructor(t, r) {
        super()
        gt(this, cn)
        gt(this, li)
        gt(this, Ht)
        gt(this, Nh)
        gt(this, Kr)
        gt(this, Al)
        gt(this, Ec)
        gt(this, Ua)
        gt(this, Mh)
        gt(this, xc)
        gt(this, Sc)
        gt(this, Dl)
        gt(this, Nl)
        gt(this, ys)
        gt(this, Tc, new Set())
        ;(this.options = r), He(this, li, t), He(this, Ua, null), this.bindMethods(), this.setOptions(r)
      }
      bindMethods() {
        this.refetch = this.refetch.bind(this)
      }
      onSubscribe() {
        this.listeners.size === 1 &&
          (B(this, Ht).addObserver(this),
          IR(B(this, Ht), this.options) ? zt(this, cn, $d).call(this) : this.updateResult(),
          zt(this, cn, Nx).call(this))
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy()
      }
      shouldFetchOnReconnect() {
        return Ix(B(this, Ht), this.options, this.options.refetchOnReconnect)
      }
      shouldFetchOnWindowFocus() {
        return Ix(B(this, Ht), this.options, this.options.refetchOnWindowFocus)
      }
      destroy() {
        ;(this.listeners = new Set()),
          zt(this, cn, Mx).call(this),
          zt(this, cn, Lx).call(this),
          B(this, Ht).removeObserver(this)
      }
      setOptions(t, r) {
        const a = this.options,
          o = B(this, Ht)
        if (
          ((this.options = B(this, li).defaultQueryOptions(t)),
          this.options.enabled !== void 0 &&
            typeof this.options.enabled != 'boolean' &&
            typeof this.options.enabled != 'function' &&
            typeof ha(this.options.enabled, B(this, Ht)) != 'boolean')
        )
          throw new Error('Expected enabled to be a boolean or a callback that returns a boolean')
        zt(this, cn, Px).call(this),
          B(this, Ht).setOptions(this.options),
          a._defaulted &&
            !wx(this.options, a) &&
            B(this, li)
              .getQueryCache()
              .notify({ type: 'observerOptionsUpdated', query: B(this, Ht), observer: this })
        const u = this.hasListeners()
        u && FR(B(this, Ht), o, this.options, a) && zt(this, cn, $d).call(this),
          this.updateResult(r),
          u &&
            (B(this, Ht) !== o ||
              ha(this.options.enabled, B(this, Ht)) !== ha(a.enabled, B(this, Ht)) ||
              ic(this.options.staleTime, B(this, Ht)) !== ic(a.staleTime, B(this, Ht))) &&
            zt(this, cn, kx).call(this)
        const l = zt(this, cn, Ax).call(this)
        u &&
          (B(this, Ht) !== o ||
            ha(this.options.enabled, B(this, Ht)) !== ha(a.enabled, B(this, Ht)) ||
            l !== B(this, ys)) &&
          zt(this, cn, Dx).call(this, l)
      }
      getOptimisticResult(t) {
        const r = B(this, li).getQueryCache().build(B(this, li), t),
          a = this.createResult(r, t)
        return (
          s9(this, a) && (He(this, Kr, a), He(this, Ec, this.options), He(this, Al, B(this, Ht).state)),
          a
        )
      }
      getCurrentResult() {
        return B(this, Kr)
      }
      trackResult(t, r) {
        const a = {}
        return (
          Object.keys(t).forEach(o => {
            Object.defineProperty(a, o, {
              configurable: !1,
              enumerable: !0,
              get: () => (this.trackProp(o), r == null || r(o), t[o])
            })
          }),
          a
        )
      }
      trackProp(t) {
        B(this, Tc).add(t)
      }
      getCurrentQuery() {
        return B(this, Ht)
      }
      refetch({ ...t } = {}) {
        return this.fetch({ ...t })
      }
      fetchOptimistic(t) {
        const r = B(this, li).defaultQueryOptions(t),
          a = B(this, li).getQueryCache().build(B(this, li), r)
        return (a.isFetchingOptimistic = !0), a.fetch().then(() => this.createResult(a, r))
      }
      fetch(t) {
        return zt(this, cn, $d)
          .call(this, { ...t, cancelRefetch: t.cancelRefetch ?? !0 })
          .then(() => (this.updateResult(), B(this, Kr)))
      }
      createResult(t, r) {
        var H
        const a = B(this, Ht),
          o = this.options,
          u = B(this, Kr),
          l = B(this, Al),
          d = B(this, Ec),
          p = t !== a ? t.state : B(this, Nh),
          { state: v } = t
        let g = { ...v },
          E = !1,
          x
        if (r._optimisticResults) {
          const $ = this.hasListeners(),
            Q = !$ && IR(t, r),
            ue = $ && FR(t, a, r, o)
          ;(Q || ue) && (g = { ...g, ...Bk(v.data, t.options) }),
            r._optimisticResults === 'isRestoring' && (g.fetchStatus = 'idle')
        }
        let { error: C, errorUpdatedAt: _, status: k } = g
        if (r.select && g.data !== void 0)
          if (u && g.data === (l == null ? void 0 : l.data) && r.select === B(this, Mh)) x = B(this, xc)
          else
            try {
              He(this, Mh, r.select),
                (x = r.select(g.data)),
                (x = _x(u == null ? void 0 : u.data, x, r)),
                He(this, xc, x),
                He(this, Ua, null)
            } catch ($) {
              He(this, Ua, $)
            }
        else x = g.data
        if (r.placeholderData !== void 0 && x === void 0 && k === 'pending') {
          let $
          if (
            u != null &&
            u.isPlaceholderData &&
            r.placeholderData === (d == null ? void 0 : d.placeholderData)
          )
            $ = u.data
          else if (
            (($ =
              typeof r.placeholderData == 'function'
                ? r.placeholderData((H = B(this, Sc)) == null ? void 0 : H.state.data, B(this, Sc))
                : r.placeholderData),
            r.select && $ !== void 0)
          )
            try {
              ;($ = r.select($)), He(this, Ua, null)
            } catch (Q) {
              He(this, Ua, Q)
            }
          $ !== void 0 && ((k = 'success'), (x = _x(u == null ? void 0 : u.data, $, r)), (E = !0))
        }
        B(this, Ua) && ((C = B(this, Ua)), (x = B(this, xc)), (_ = Date.now()), (k = 'error'))
        const R = g.fetchStatus === 'fetching',
          D = k === 'pending',
          A = k === 'error',
          L = D && R,
          F = x !== void 0
        return {
          status: k,
          fetchStatus: g.fetchStatus,
          isPending: D,
          isSuccess: k === 'success',
          isError: A,
          isInitialLoading: L,
          isLoading: L,
          data: x,
          dataUpdatedAt: g.dataUpdatedAt,
          error: C,
          errorUpdatedAt: _,
          failureCount: g.fetchFailureCount,
          failureReason: g.fetchFailureReason,
          errorUpdateCount: g.errorUpdateCount,
          isFetched: g.dataUpdateCount > 0 || g.errorUpdateCount > 0,
          isFetchedAfterMount:
            g.dataUpdateCount > p.dataUpdateCount || g.errorUpdateCount > p.errorUpdateCount,
          isFetching: R,
          isRefetching: R && !D,
          isLoadingError: A && !F,
          isPaused: g.fetchStatus === 'paused',
          isPlaceholderData: E,
          isRefetchError: A && F,
          isStale: TS(t, r),
          refetch: this.refetch
        }
      }
      updateResult(t) {
        const r = B(this, Kr),
          a = this.createResult(B(this, Ht), this.options)
        if (
          (He(this, Al, B(this, Ht).state),
          He(this, Ec, this.options),
          B(this, Al).data !== void 0 && He(this, Sc, B(this, Ht)),
          wx(a, r))
        )
          return
        He(this, Kr, a)
        const o = {},
          u = () => {
            if (!r) return !0
            const { notifyOnChangeProps: l } = this.options,
              d = typeof l == 'function' ? l() : l
            if (d === 'all' || (!d && !B(this, Tc).size)) return !0
            const h = new Set(d ?? B(this, Tc))
            return (
              this.options.throwOnError && h.add('error'),
              Object.keys(B(this, Kr)).some(p => {
                const v = p
                return B(this, Kr)[v] !== r[v] && h.has(v)
              })
            )
          }
        ;(t == null ? void 0 : t.listeners) !== !1 && u() && (o.listeners = !0),
          zt(this, cn, zk).call(this, { ...o, ...t })
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && zt(this, cn, Nx).call(this)
      }
    }),
    (li = new WeakMap()),
    (Ht = new WeakMap()),
    (Nh = new WeakMap()),
    (Kr = new WeakMap()),
    (Al = new WeakMap()),
    (Ec = new WeakMap()),
    (Ua = new WeakMap()),
    (Mh = new WeakMap()),
    (xc = new WeakMap()),
    (Sc = new WeakMap()),
    (Dl = new WeakMap()),
    (Nl = new WeakMap()),
    (ys = new WeakMap()),
    (Tc = new WeakMap()),
    (cn = new WeakSet()),
    ($d = function (t) {
      zt(this, cn, Px).call(this)
      let r = B(this, Ht).fetch(this.options, t)
      return (t != null && t.throwOnError) || (r = r.catch(Wi)), r
    }),
    (kx = function () {
      zt(this, cn, Mx).call(this)
      const t = ic(this.options.staleTime, B(this, Ht))
      if (Cc || B(this, Kr).isStale || !Cx(t)) return
      const a = Pk(B(this, Kr).dataUpdatedAt, t) + 1
      He(
        this,
        Dl,
        setTimeout(() => {
          B(this, Kr).isStale || this.updateResult()
        }, a)
      )
    }),
    (Ax = function () {
      return (
        (typeof this.options.refetchInterval == 'function'
          ? this.options.refetchInterval(B(this, Ht))
          : this.options.refetchInterval) ?? !1
      )
    }),
    (Dx = function (t) {
      zt(this, cn, Lx).call(this),
        He(this, ys, t),
        !(Cc || ha(this.options.enabled, B(this, Ht)) === !1 || !Cx(B(this, ys)) || B(this, ys) === 0) &&
          He(
            this,
            Nl,
            setInterval(
              () => {
                ;(this.options.refetchIntervalInBackground || SS.isFocused()) &&
                  zt(this, cn, $d).call(this)
              },
              B(this, ys)
            )
          )
    }),
    (Nx = function () {
      zt(this, cn, kx).call(this), zt(this, cn, Dx).call(this, zt(this, cn, Ax).call(this))
    }),
    (Mx = function () {
      B(this, Dl) && (clearTimeout(B(this, Dl)), He(this, Dl, void 0))
    }),
    (Lx = function () {
      B(this, Nl) && (clearInterval(B(this, Nl)), He(this, Nl, void 0))
    }),
    (Px = function () {
      const t = B(this, li).getQueryCache().build(B(this, li), this.options)
      if (t === B(this, Ht)) return
      const r = B(this, Ht)
      He(this, Ht, t),
        He(this, Nh, t.state),
        this.hasListeners() && (r == null || r.removeObserver(this), t.addObserver(this))
    }),
    (zk = function (t) {
      Sr.batch(() => {
        t.listeners &&
          this.listeners.forEach(r => {
            r(B(this, Kr))
          }),
          B(this, li)
            .getQueryCache()
            .notify({ query: B(this, Ht), type: 'observerResultsUpdated' })
      })
    }),
    Ok)
function o9(e, t) {
  return (
    ha(t.enabled, e) !== !1 &&
    e.state.data === void 0 &&
    !(e.state.status === 'error' && t.retryOnMount === !1)
  )
}
function IR(e, t) {
  return o9(e, t) || (e.state.data !== void 0 && Ix(e, t, t.refetchOnMount))
}
function Ix(e, t, r) {
  if (ha(t.enabled, e) !== !1) {
    const a = typeof r == 'function' ? r(e) : r
    return a === 'always' || (a !== !1 && TS(e, t))
  }
  return !1
}
function FR(e, t, r, a) {
  return (e !== t || ha(a.enabled, e) === !1) && (!r.suspense || e.state.status !== 'error') && TS(e, r)
}
function TS(e, t) {
  return ha(t.enabled, e) !== !1 && e.isStaleByTime(ic(t.staleTime, e))
}
function s9(e, t) {
  return !wx(e.getCurrentResult(), t)
}
var Hk = { exports: {} },
  Tv = {}
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  var e = w,
    t = Symbol.for('react.element'),
    r = Symbol.for('react.portal'),
    a = Symbol.for('react.fragment'),
    o = Symbol.for('react.strict_mode'),
    u = Symbol.for('react.profiler'),
    l = Symbol.for('react.provider'),
    d = Symbol.for('react.context'),
    h = Symbol.for('react.forward_ref'),
    p = Symbol.for('react.suspense'),
    v = Symbol.for('react.suspense_list'),
    g = Symbol.for('react.memo'),
    E = Symbol.for('react.lazy'),
    x = Symbol.for('react.offscreen'),
    C = Symbol.iterator,
    _ = '@@iterator'
  function k(M) {
    if (M === null || typeof M != 'object') return null
    var X = (C && M[C]) || M[_]
    return typeof X == 'function' ? X : null
  }
  var R = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  function D(M) {
    {
      for (var X = arguments.length, ne = new Array(X > 1 ? X - 1 : 0), Ee = 1; Ee < X; Ee++)
        ne[Ee - 1] = arguments[Ee]
      A('error', M, ne)
    }
  }
  function A(M, X, ne) {
    {
      var Ee = R.ReactDebugCurrentFrame,
        _e = Ee.getStackAddendum()
      _e !== '' && ((X += '%s'), (ne = ne.concat([_e])))
      var Qe = ne.map(function (ke) {
        return String(ke)
      })
      Qe.unshift('Warning: ' + X), Function.prototype.apply.call(console[M], console, Qe)
    }
  }
  var L = !1,
    F = !1,
    z = !1,
    H = !1,
    $ = !1,
    Q
  Q = Symbol.for('react.module.reference')
  function ue(M) {
    return !!(
      typeof M == 'string' ||
      typeof M == 'function' ||
      M === a ||
      M === u ||
      $ ||
      M === o ||
      M === p ||
      M === v ||
      H ||
      M === x ||
      L ||
      F ||
      z ||
      (typeof M == 'object' &&
        M !== null &&
        (M.$$typeof === E ||
          M.$$typeof === g ||
          M.$$typeof === l ||
          M.$$typeof === d ||
          M.$$typeof === h ||
          M.$$typeof === Q ||
          M.getModuleId !== void 0))
    )
  }
  function se(M, X, ne) {
    var Ee = M.displayName
    if (Ee) return Ee
    var _e = X.displayName || X.name || ''
    return _e !== '' ? ne + '(' + _e + ')' : ne
  }
  function we(M) {
    return M.displayName || 'Context'
  }
  function he(M) {
    if (M == null) return null
    if (
      (typeof M.tag == 'number' &&
        D(
          'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
        ),
      typeof M == 'function')
    )
      return M.displayName || M.name || null
    if (typeof M == 'string') return M
    switch (M) {
      case a:
        return 'Fragment'
      case r:
        return 'Portal'
      case u:
        return 'Profiler'
      case o:
        return 'StrictMode'
      case p:
        return 'Suspense'
      case v:
        return 'SuspenseList'
    }
    if (typeof M == 'object')
      switch (M.$$typeof) {
        case d:
          var X = M
          return we(X) + '.Consumer'
        case l:
          var ne = M
          return we(ne._context) + '.Provider'
        case h:
          return se(M, M.render, 'ForwardRef')
        case g:
          var Ee = M.displayName || null
          return Ee !== null ? Ee : he(M.type) || 'Memo'
        case E: {
          var _e = M,
            Qe = _e._payload,
            ke = _e._init
          try {
            return he(ke(Qe))
          } catch {
            return null
          }
        }
      }
    return null
  }
  var G = Object.assign,
    ge = 0,
    De,
    de,
    ve,
    Ke,
    ot,
    Me,
    Ue
  function pe() {}
  pe.__reactDisabledLog = !0
  function xt() {
    {
      if (ge === 0) {
        ;(De = console.log),
          (de = console.info),
          (ve = console.warn),
          (Ke = console.error),
          (ot = console.group),
          (Me = console.groupCollapsed),
          (Ue = console.groupEnd)
        var M = { configurable: !0, enumerable: !0, value: pe, writable: !0 }
        Object.defineProperties(console, {
          info: M,
          log: M,
          warn: M,
          error: M,
          group: M,
          groupCollapsed: M,
          groupEnd: M
        })
      }
      ge++
    }
  }
  function Ye() {
    {
      if ((ge--, ge === 0)) {
        var M = { configurable: !0, enumerable: !0, writable: !0 }
        Object.defineProperties(console, {
          log: G({}, M, { value: De }),
          info: G({}, M, { value: de }),
          warn: G({}, M, { value: ve }),
          error: G({}, M, { value: Ke }),
          group: G({}, M, { value: ot }),
          groupCollapsed: G({}, M, { value: Me }),
          groupEnd: G({}, M, { value: Ue })
        })
      }
      ge < 0 && D('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
    }
  }
  var kt = R.ReactCurrentDispatcher,
    yt
  function Et(M, X, ne) {
    {
      if (yt === void 0)
        try {
          throw Error()
        } catch (_e) {
          var Ee = _e.stack.trim().match(/\n( *(at )?)/)
          yt = (Ee && Ee[1]) || ''
        }
      return (
        `
` +
        yt +
        M
      )
    }
  }
  var st = !1,
    At
  {
    var en = typeof WeakMap == 'function' ? WeakMap : Map
    At = new en()
  }
  function nn(M, X) {
    if (!M || st) return ''
    {
      var ne = At.get(M)
      if (ne !== void 0) return ne
    }
    var Ee
    st = !0
    var _e = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    var Qe
    ;(Qe = kt.current), (kt.current = null), xt()
    try {
      if (X) {
        var ke = function () {
          throw Error()
        }
        if (
          (Object.defineProperty(ke.prototype, 'props', {
            set: function () {
              throw Error()
            }
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(ke, [])
          } catch ($t) {
            Ee = $t
          }
          Reflect.construct(M, [], ke)
        } else {
          try {
            ke.call()
          } catch ($t) {
            Ee = $t
          }
          M.call(ke.prototype)
        }
      } else {
        try {
          throw Error()
        } catch ($t) {
          Ee = $t
        }
        M()
      }
    } catch ($t) {
      if ($t && Ee && typeof $t.stack == 'string') {
        for (
          var ae = $t.stack.split(`
`),
            V = Ee.stack.split(`
`),
            re = ae.length - 1,
            ye = V.length - 1;
          re >= 1 && ye >= 0 && ae[re] !== V[ye];

        )
          ye--
        for (; re >= 1 && ye >= 0; re--, ye--)
          if (ae[re] !== V[ye]) {
            if (re !== 1 || ye !== 1)
              do
                if ((re--, ye--, ye < 0 || ae[re] !== V[ye])) {
                  var qe =
                    `
` + ae[re].replace(' at new ', ' at ')
                  return (
                    M.displayName &&
                      qe.includes('<anonymous>') &&
                      (qe = qe.replace('<anonymous>', M.displayName)),
                    typeof M == 'function' && At.set(M, qe),
                    qe
                  )
                }
              while (re >= 1 && ye >= 0)
            break
          }
      }
    } finally {
      ;(st = !1), (kt.current = Qe), Ye(), (Error.prepareStackTrace = _e)
    }
    var tn = M ? M.displayName || M.name : '',
      Qt = tn ? Et(tn) : ''
    return typeof M == 'function' && At.set(M, Qt), Qt
  }
  function Re(M, X, ne) {
    return nn(M, !1)
  }
  function Oe(M) {
    var X = M.prototype
    return !!(X && X.isReactComponent)
  }
  function Xe(M, X, ne) {
    if (M == null) return ''
    if (typeof M == 'function') return nn(M, Oe(M))
    if (typeof M == 'string') return Et(M)
    switch (M) {
      case p:
        return Et('Suspense')
      case v:
        return Et('SuspenseList')
    }
    if (typeof M == 'object')
      switch (M.$$typeof) {
        case h:
          return Re(M.render)
        case g:
          return Xe(M.type, X, ne)
        case E: {
          var Ee = M,
            _e = Ee._payload,
            Qe = Ee._init
          try {
            return Xe(Qe(_e), X, ne)
          } catch {}
        }
      }
    return ''
  }
  var Dt = Object.prototype.hasOwnProperty,
    Vt = {},
    Cn = R.ReactDebugCurrentFrame
  function xn(M) {
    if (M) {
      var X = M._owner,
        ne = Xe(M.type, M._source, X ? X.type : null)
      Cn.setExtraStackFrame(ne)
    } else Cn.setExtraStackFrame(null)
  }
  function Pn(M, X, ne, Ee, _e) {
    {
      var Qe = Function.call.bind(Dt)
      for (var ke in M)
        if (Qe(M, ke)) {
          var ae = void 0
          try {
            if (typeof M[ke] != 'function') {
              var V = Error(
                (Ee || 'React class') +
                  ': ' +
                  ne +
                  ' type `' +
                  ke +
                  '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                  typeof M[ke] +
                  '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
              )
              throw ((V.name = 'Invariant Violation'), V)
            }
            ae = M[ke](X, ke, Ee, ne, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
          } catch (re) {
            ae = re
          }
          ae &&
            !(ae instanceof Error) &&
            (xn(_e),
            D(
              '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
              Ee || 'React class',
              ne,
              ke,
              typeof ae
            ),
            xn(null)),
            ae instanceof Error &&
              !(ae.message in Vt) &&
              ((Vt[ae.message] = !0), xn(_e), D('Failed %s type: %s', ne, ae.message), xn(null))
        }
    }
  }
  var tr = Array.isArray
  function Un(M) {
    return tr(M)
  }
  function In(M) {
    {
      var X = typeof Symbol == 'function' && Symbol.toStringTag,
        ne = (X && M[Symbol.toStringTag]) || M.constructor.name || 'Object'
      return ne
    }
  }
  function $n(M) {
    try {
      return mn(M), !1
    } catch {
      return !0
    }
  }
  function mn(M) {
    return '' + M
  }
  function wn(M) {
    if ($n(M))
      return (
        D(
          'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
          In(M)
        ),
        mn(M)
      )
  }
  var rn = R.ReactCurrentOwner,
    fr = { key: !0, ref: !0, __self: !0, __source: !0 },
    jr,
    Cr,
    Se
  Se = {}
  function $e(M) {
    if (Dt.call(M, 'ref')) {
      var X = Object.getOwnPropertyDescriptor(M, 'ref').get
      if (X && X.isReactWarning) return !1
    }
    return M.ref !== void 0
  }
  function pt(M) {
    if (Dt.call(M, 'key')) {
      var X = Object.getOwnPropertyDescriptor(M, 'key').get
      if (X && X.isReactWarning) return !1
    }
    return M.key !== void 0
  }
  function St(M, X) {
    if (typeof M.ref == 'string' && rn.current && X && rn.current.stateNode !== X) {
      var ne = he(rn.current.type)
      Se[ne] ||
        (D(
          'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
          he(rn.current.type),
          M.ref
        ),
        (Se[ne] = !0))
    }
  }
  function _t(M, X) {
    {
      var ne = function () {
        jr ||
          ((jr = !0),
          D(
            '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            X
          ))
      }
      ;(ne.isReactWarning = !0), Object.defineProperty(M, 'key', { get: ne, configurable: !0 })
    }
  }
  function gn(M, X) {
    {
      var ne = function () {
        Cr ||
          ((Cr = !0),
          D(
            '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            X
          ))
      }
      ;(ne.isReactWarning = !0), Object.defineProperty(M, 'ref', { get: ne, configurable: !0 })
    }
  }
  var fn = function (M, X, ne, Ee, _e, Qe, ke) {
    var ae = { $$typeof: t, type: M, key: X, ref: ne, props: ke, _owner: Qe }
    return (
      (ae._store = {}),
      Object.defineProperty(ae._store, 'validated', {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }),
      Object.defineProperty(ae, '_self', { configurable: !1, enumerable: !1, writable: !1, value: Ee }),
      Object.defineProperty(ae, '_source', {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _e
      }),
      Object.freeze && (Object.freeze(ae.props), Object.freeze(ae)),
      ae
    )
  }
  function nr(M, X, ne, Ee, _e) {
    {
      var Qe,
        ke = {},
        ae = null,
        V = null
      ne !== void 0 && (wn(ne), (ae = '' + ne)),
        pt(X) && (wn(X.key), (ae = '' + X.key)),
        $e(X) && ((V = X.ref), St(X, _e))
      for (Qe in X) Dt.call(X, Qe) && !fr.hasOwnProperty(Qe) && (ke[Qe] = X[Qe])
      if (M && M.defaultProps) {
        var re = M.defaultProps
        for (Qe in re) ke[Qe] === void 0 && (ke[Qe] = re[Qe])
      }
      if (ae || V) {
        var ye = typeof M == 'function' ? M.displayName || M.name || 'Unknown' : M
        ae && _t(ke, ye), V && gn(ke, ye)
      }
      return fn(M, ae, V, _e, Ee, rn.current, ke)
    }
  }
  var Nt = R.ReactCurrentOwner,
    rr = R.ReactDebugCurrentFrame
  function Wt(M) {
    if (M) {
      var X = M._owner,
        ne = Xe(M.type, M._source, X ? X.type : null)
      rr.setExtraStackFrame(ne)
    } else rr.setExtraStackFrame(null)
  }
  var lt
  lt = !1
  function Fn(M) {
    return typeof M == 'object' && M !== null && M.$$typeof === t
  }
  function wr() {
    {
      if (Nt.current) {
        var M = he(Nt.current.type)
        if (M)
          return (
            `

Check the render method of \`` +
            M +
            '`.'
          )
      }
      return ''
    }
  }
  function Ni(M) {
    return ''
  }
  var ci = {}
  function xa(M) {
    {
      var X = wr()
      if (!X) {
        var ne = typeof M == 'string' ? M : M.displayName || M.name
        ne &&
          (X =
            `

Check the top-level render call using <` +
            ne +
            '>.')
      }
      return X
    }
  }
  function fi(M, X) {
    {
      if (!M._store || M._store.validated || M.key != null) return
      M._store.validated = !0
      var ne = xa(X)
      if (ci[ne]) return
      ci[ne] = !0
      var Ee = ''
      M &&
        M._owner &&
        M._owner !== Nt.current &&
        (Ee = ' It was passed a child from ' + he(M._owner.type) + '.'),
        Wt(M),
        D(
          'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
          ne,
          Ee
        ),
        Wt(null)
    }
  }
  function Mi(M, X) {
    {
      if (typeof M != 'object') return
      if (Un(M))
        for (var ne = 0; ne < M.length; ne++) {
          var Ee = M[ne]
          Fn(Ee) && fi(Ee, X)
        }
      else if (Fn(M)) M._store && (M._store.validated = !0)
      else if (M) {
        var _e = k(M)
        if (typeof _e == 'function' && _e !== M.entries)
          for (var Qe = _e.call(M), ke; !(ke = Qe.next()).done; ) Fn(ke.value) && fi(ke.value, X)
      }
    }
  }
  function Jr(M) {
    {
      var X = M.type
      if (X == null || typeof X == 'string') return
      var ne
      if (typeof X == 'function') ne = X.propTypes
      else if (typeof X == 'object' && (X.$$typeof === h || X.$$typeof === g)) ne = X.propTypes
      else return
      if (ne) {
        var Ee = he(X)
        Pn(ne, M.props, 'prop', Ee, M)
      } else if (X.PropTypes !== void 0 && !lt) {
        lt = !0
        var _e = he(X)
        D(
          'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
          _e || 'Unknown'
        )
      }
      typeof X.getDefaultProps == 'function' &&
        !X.getDefaultProps.isReactClassApproved &&
        D(
          'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
        )
    }
  }
  function di(M) {
    {
      for (var X = Object.keys(M.props), ne = 0; ne < X.length; ne++) {
        var Ee = X[ne]
        if (Ee !== 'children' && Ee !== 'key') {
          Wt(M),
            D(
              'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
              Ee
            ),
            Wt(null)
          break
        }
      }
      M.ref !== null && (Wt(M), D('Invalid attribute `ref` supplied to `React.Fragment`.'), Wt(null))
    }
  }
  var ei = {}
  function Sn(M, X, ne, Ee, _e, Qe) {
    {
      var ke = ue(M)
      if (!ke) {
        var ae = ''
        ;(M === void 0 || (typeof M == 'object' && M !== null && Object.keys(M).length === 0)) &&
          (ae +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
        var V = Ni()
        V ? (ae += V) : (ae += wr())
        var re
        M === null
          ? (re = 'null')
          : Un(M)
            ? (re = 'array')
            : M !== void 0 && M.$$typeof === t
              ? ((re = '<' + (he(M.type) || 'Unknown') + ' />'),
                (ae = ' Did you accidentally export a JSX literal instead of a component?'))
              : (re = typeof M),
          D(
            'React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
            re,
            ae
          )
      }
      var ye = nr(M, X, ne, _e, Qe)
      if (ye == null) return ye
      if (ke) {
        var qe = X.children
        if (qe !== void 0)
          if (Ee)
            if (Un(qe)) {
              for (var tn = 0; tn < qe.length; tn++) Mi(qe[tn], M)
              Object.freeze && Object.freeze(qe)
            } else
              D(
                'React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.'
              )
          else Mi(qe, M)
      }
      if (Dt.call(X, 'key')) {
        var Qt = he(M),
          $t = Object.keys(X).filter(function (yn) {
            return yn !== 'key'
          }),
          Tn = $t.length > 0 ? '{key: someKey, ' + $t.join(': ..., ') + ': ...}' : '{key: someKey}'
        if (!ei[Qt + Tn]) {
          var vt = $t.length > 0 ? '{' + $t.join(': ..., ') + ': ...}' : '{}'
          D(
            `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
            Tn,
            Qt,
            vt,
            Qt
          ),
            (ei[Qt + Tn] = !0)
        }
      }
      return M === a ? di(ye) : Jr(ye), ye
    }
  }
  function ir(M, X, ne) {
    return Sn(M, X, ne, !0)
  }
  function P(M, X, ne) {
    return Sn(M, X, ne, !1)
  }
  var ce = P,
    Te = ir
  ;(Tv.Fragment = a), (Tv.jsx = ce), (Tv.jsxs = Te)
})()
Hk.exports = Tv
var dt = Hk.exports,
  Wk = w.createContext(void 0),
  l9 = e => {
    const t = w.useContext(Wk)
    if (!t) throw new Error('No QueryClient set, use QueryClientProvider to set one')
    return t
  },
  u9 = ({ client: e, children: t }) => (
    w.useEffect(
      () => (
        e.mount(),
        () => {
          e.unmount()
        }
      ),
      [e]
    ),
    dt.jsx(Wk.Provider, { value: e, children: t })
  ),
  Yk = w.createContext(!1),
  c9 = () => w.useContext(Yk)
Yk.Provider
function f9() {
  let e = !1
  return {
    clearReset: () => {
      e = !1
    },
    reset: () => {
      e = !0
    },
    isReset: () => e
  }
}
var d9 = w.createContext(f9()),
  h9 = () => w.useContext(d9)
function p9(e, t) {
  return typeof e == 'function' ? e(...t) : !!e
}
var m9 = (e, t) => {
    ;(e.suspense || e.throwOnError) && (t.isReset() || (e.retryOnMount = !1))
  },
  v9 = e => {
    w.useEffect(() => {
      e.clearReset()
    }, [e])
  },
  g9 = ({ result: e, errorResetBoundary: t, throwOnError: r, query: a }) =>
    e.isError && !t.isReset() && !e.isFetching && a && p9(r, [e.error, a]),
  y9 = e => {
    e.suspense &&
      (typeof e.staleTime != 'number' && (e.staleTime = 1e3),
      typeof e.gcTime == 'number' && (e.gcTime = Math.max(e.gcTime, 1e3)))
  },
  b9 = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending,
  E9 = (e, t, r) =>
    t.fetchOptimistic(e).catch(() => {
      r.clearReset()
    })
function x9(e, t, r) {
  var p, v, g, E
  if (typeof e != 'object' || Array.isArray(e))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    )
  const a = l9(),
    o = c9(),
    u = h9(),
    l = a.defaultQueryOptions(e)
  ;(v = (p = a.getDefaultOptions().queries) == null ? void 0 : p._experimental_beforeQuery) == null ||
    v.call(p, l),
    (l._optimisticResults = o ? 'isRestoring' : 'optimistic'),
    y9(l),
    m9(l, u),
    v9(u)
  const [d] = w.useState(() => new t(a, l)),
    h = d.getOptimisticResult(l)
  if (
    (w.useSyncExternalStore(
      w.useCallback(
        x => {
          const C = o ? () => {} : d.subscribe(Sr.batchCalls(x))
          return d.updateResult(), C
        },
        [d, o]
      ),
      () => d.getCurrentResult(),
      () => d.getCurrentResult()
    ),
    w.useEffect(() => {
      d.setOptions(l, { listeners: !1 })
    }, [l, d]),
    b9(l, h))
  )
    throw E9(l, d, u)
  if (
    g9({
      result: h,
      errorResetBoundary: u,
      throwOnError: l.throwOnError,
      query: a.getQueryCache().get(l.queryHash)
    })
  )
    throw h.error
  return (
    (E = (g = a.getDefaultOptions().queries) == null ? void 0 : g._experimental_afterQuery) == null ||
      E.call(g, l, h),
    l.notifyOnChangeProps ? h : d.trackResult(h)
  )
}
function qk(e, t) {
  return x9(e, a9)
}
const VR = 'pushstate',
  jR = 'popstate',
  Gk = 'beforeunload',
  Kk = e => (e.preventDefault(), (e.returnValue = '')),
  S9 = () => {
    removeEventListener(Gk, Kk, { capture: !0 })
  }
function Zk(e) {
  let t = e.getLocation()
  const r = new Set()
  let a = []
  const o = () => {
      ;(t = e.getLocation()), r.forEach(l => l())
    },
    u = async (l, d) => {
      var h
      if (!((d == null ? void 0 : d.ignoreBlocker) ?? !1) && typeof document < 'u' && a.length) {
        for (const v of a)
          if (!(await v())) {
            ;(h = e.onBlocked) == null || h.call(e, o)
            return
          }
      }
      l()
    }
  return {
    get location() {
      return t
    },
    subscribers: r,
    subscribe: l => (
      r.add(l),
      () => {
        r.delete(l)
      }
    ),
    push: (l, d, h) => {
      ;(d = qd(d)),
        u(() => {
          e.pushState(l, d), o()
        }, h)
    },
    replace: (l, d, h) => {
      ;(d = qd(d)),
        u(() => {
          e.replaceState(l, d), o()
        }, h)
    },
    go: (l, d) => {
      u(() => {
        e.go(l), o()
      }, d)
    },
    back: l => {
      u(() => {
        e.back(), o()
      }, l)
    },
    forward: l => {
      u(() => {
        e.forward(), o()
      }, l)
    },
    createHref: l => e.createHref(l),
    block: l => (
      a.push(l),
      a.length === 1 && addEventListener(Gk, Kk, { capture: !0 }),
      () => {
        ;(a = a.filter(d => d !== l)), a.length || S9()
      }
    ),
    flush: () => {
      var l
      return (l = e.flush) == null ? void 0 : l.call(e)
    },
    destroy: () => {
      var l
      return (l = e.destroy) == null ? void 0 : l.call(e)
    },
    notify: o
  }
}
function qd(e) {
  return e || (e = {}), { ...e, key: Xk() }
}
function T9(e) {
  const t = typeof document < 'u' ? window : void 0,
    r = t.history.pushState,
    a = t.history.replaceState,
    o = _ => _,
    u = () => Fv(`${t.location.pathname}${t.location.search}${t.location.hash}`, t.history.state)
  let l = u(),
    d
  const h = () => l
  let p, v
  const g = () => {
      p &&
        ((C._ignoreSubscribers = !0),
        (p.isPush ? t.history.pushState : t.history.replaceState)(p.state, '', p.href),
        (C._ignoreSubscribers = !1),
        (p = void 0),
        (v = void 0),
        (d = void 0))
    },
    E = (_, k, R) => {
      const D = o(k)
      v || (d = l),
        (l = Fv(k, R)),
        (p = { href: D, state: R, isPush: (p == null ? void 0 : p.isPush) || _ === 'push' }),
        v || (v = Promise.resolve().then(() => g()))
    },
    x = () => {
      ;(l = u()), C.notify()
    },
    C = Zk({
      getLocation: h,
      pushState: (_, k) => E('push', _, k),
      replaceState: (_, k) => E('replace', _, k),
      back: () => t.history.back(),
      forward: () => t.history.forward(),
      go: _ => t.history.go(_),
      createHref: _ => o(_),
      flush: g,
      destroy: () => {
        ;(t.history.pushState = r),
          (t.history.replaceState = a),
          t.removeEventListener(VR, x),
          t.removeEventListener(jR, x)
      },
      onBlocked: _ => {
        d && l !== d && ((l = d), _())
      }
    })
  return (
    t.addEventListener(VR, x),
    t.addEventListener(jR, x),
    (t.history.pushState = function (..._) {
      const k = r.apply(t.history, _)
      return C._ignoreSubscribers || x(), k
    }),
    (t.history.replaceState = function (..._) {
      const k = a.apply(t.history, _)
      return C._ignoreSubscribers || x(), k
    }),
    C
  )
}
function C9(e = { initialEntries: ['/'] }) {
  const t = e.initialEntries
  let r = e.initialIndex ?? t.length - 1,
    a = { key: Xk() }
  return Zk({
    getLocation: () => Fv(t[r], a),
    pushState: (u, l) => {
      ;(a = l), t.splice, r < t.length - 1 && t.splice(r + 1), t.push(u), (r = Math.max(t.length - 1, 0))
    },
    replaceState: (u, l) => {
      ;(a = l), (t[r] = u)
    },
    back: () => {
      ;(a = qd(a)), (r = Math.max(r - 1, 0))
    },
    forward: () => {
      ;(a = qd(a)), (r = Math.min(r + 1, t.length - 1))
    },
    go: u => {
      ;(a = qd(a)), (r = Math.min(Math.max(r + u, 0), t.length - 1))
    },
    createHref: u => u
  })
}
function Fv(e, t) {
  const r = e.indexOf('#'),
    a = e.indexOf('?')
  return {
    href: e,
    pathname: e.substring(0, r > 0 ? (a > 0 ? Math.min(r, a) : r) : a > 0 ? a : e.length),
    hash: r > -1 ? e.substring(r) : '',
    search: a > -1 ? e.slice(a, r === -1 ? void 0 : r) : '',
    state: t || {}
  }
}
function Xk() {
  return (Math.random() + 1).toString(36).substring(7)
}
var UR = 'Invariant failed'
function ui(e, t) {
  if (!e) {
    var r = typeof t == 'function' ? t() : t,
      a = r ? ''.concat(UR, ': ').concat(r) : UR
    throw new Error(a)
  }
}
function Il(e, t) {
  {
    if (e) return
    var r = 'Warning: ' + t
    typeof console < 'u' && console.warn(r)
    try {
      throw Error(r)
    } catch {}
  }
}
const PE = w.createContext(null)
function Qk() {
  return typeof document > 'u'
    ? PE
    : window.__TSR_ROUTER_CONTEXT__
      ? window.__TSR_ROUTER_CONTEXT__
      : ((window.__TSR_ROUTER_CONTEXT__ = PE), PE)
}
function Ao(e) {
  const t = w.useContext(Qk())
  return (
    Il(
      !(((e == null ? void 0 : e.warn) ?? !0) && !t),
      'useRouter must be used inside a <RouterProvider> component!'
    ),
    t
  )
}
var Jk = { exports: {} },
  eA = {},
  tA = { exports: {} },
  nA = {}
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
  var e = w,
    t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  function r(A) {
    {
      for (var L = arguments.length, F = new Array(L > 1 ? L - 1 : 0), z = 1; z < L; z++)
        F[z - 1] = arguments[z]
      a('error', A, F)
    }
  }
  function a(A, L, F) {
    {
      var z = t.ReactDebugCurrentFrame,
        H = z.getStackAddendum()
      H !== '' && ((L += '%s'), (F = F.concat([H])))
      var $ = F.map(function (Q) {
        return String(Q)
      })
      $.unshift('Warning: ' + L), Function.prototype.apply.call(console[A], console, $)
    }
  }
  function o(A, L) {
    return (A === L && (A !== 0 || 1 / A === 1 / L)) || (A !== A && L !== L)
  }
  var u = typeof Object.is == 'function' ? Object.is : o,
    l = e.useState,
    d = e.useEffect,
    h = e.useLayoutEffect,
    p = e.useDebugValue,
    v = !1,
    g = !1
  function E(A, L, F) {
    v ||
      (e.startTransition !== void 0 &&
        ((v = !0),
        r(
          'You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.'
        )))
    var z = L()
    if (!g) {
      var H = L()
      u(z, H) || (r('The result of getSnapshot should be cached to avoid an infinite loop'), (g = !0))
    }
    var $ = l({ inst: { value: z, getSnapshot: L } }),
      Q = $[0].inst,
      ue = $[1]
    return (
      h(
        function () {
          ;(Q.value = z), (Q.getSnapshot = L), x(Q) && ue({ inst: Q })
        },
        [A, z, L]
      ),
      d(
        function () {
          x(Q) && ue({ inst: Q })
          var se = function () {
            x(Q) && ue({ inst: Q })
          }
          return A(se)
        },
        [A]
      ),
      p(z),
      z
    )
  }
  function x(A) {
    var L = A.getSnapshot,
      F = A.value
    try {
      var z = L()
      return !u(F, z)
    } catch {
      return !0
    }
  }
  function C(A, L, F) {
    return L()
  }
  var _ =
      typeof window < 'u' && typeof window.document < 'u' && typeof window.document.createElement < 'u',
    k = !_,
    R = k ? C : E,
    D = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : R
  ;(nA.useSyncExternalStore = D),
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
})()
tA.exports = nA
var w9 = tA.exports
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
  var e = w,
    t = w9
  function r(v, g) {
    return (v === g && (v !== 0 || 1 / v === 1 / g)) || (v !== v && g !== g)
  }
  var a = typeof Object.is == 'function' ? Object.is : r,
    o = t.useSyncExternalStore,
    u = e.useRef,
    l = e.useEffect,
    d = e.useMemo,
    h = e.useDebugValue
  function p(v, g, E, x, C) {
    var _ = u(null),
      k
    _.current === null ? ((k = { hasValue: !1, value: null }), (_.current = k)) : (k = _.current)
    var R = d(
        function () {
          var F = !1,
            z,
            H,
            $ = function (we) {
              if (!F) {
                ;(F = !0), (z = we)
                var he = x(we)
                if (C !== void 0 && k.hasValue) {
                  var G = k.value
                  if (C(G, he)) return (H = G), G
                }
                return (H = he), he
              }
              var ge = z,
                De = H
              if (a(ge, we)) return De
              var de = x(we)
              return C !== void 0 && C(De, de) ? De : ((z = we), (H = de), de)
            },
            Q = E === void 0 ? null : E,
            ue = function () {
              return $(g())
            },
            se =
              Q === null
                ? void 0
                : function () {
                    return $(Q())
                  }
          return [ue, se]
        },
        [g, E, x, C]
      ),
      D = R[0],
      A = R[1],
      L = o(v, D, A)
    return (
      l(
        function () {
          ;(k.hasValue = !0), (k.value = L)
        },
        [L]
      ),
      h(L),
      L
    )
  }
  ;(eA.useSyncExternalStoreWithSelector = p),
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
})()
Jk.exports = eA
var R9 = Jk.exports
class _9 {
  constructor(t, r) {
    ;(this.listeners = new Set()),
      (this._batching = !1),
      (this._flushing = 0),
      (this.subscribe = a => {
        var o, u
        this.listeners.add(a)
        const l =
          (u = (o = this.options) == null ? void 0 : o.onSubscribe) == null ? void 0 : u.call(o, a, this)
        return () => {
          this.listeners.delete(a), l == null || l()
        }
      }),
      (this.setState = a => {
        var o, u, l
        const d = this.state
        ;(this.state = (o = this.options) != null && o.updateFn ? this.options.updateFn(d)(a) : a(d)),
          (l = (u = this.options) == null ? void 0 : u.onUpdate) == null || l.call(u),
          this._flush()
      }),
      (this._flush = () => {
        if (this._batching) return
        const a = ++this._flushing
        this.listeners.forEach(o => {
          this._flushing === a && o()
        })
      }),
      (this.batch = a => {
        if (this._batching) return a()
        ;(this._batching = !0), a(), (this._batching = !1), this._flush()
      }),
      (this.state = t),
      (this.options = r)
  }
}
function O9(e, t = r => r) {
  return R9.useSyncExternalStoreWithSelector(
    e.subscribe,
    () => e.state,
    () => e.state,
    t,
    k9
  )
}
function k9(e, t) {
  if (Object.is(e, t)) return !0
  if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
  const r = Object.keys(e)
  if (r.length !== Object.keys(t).length) return !1
  for (let a = 0; a < r.length; a++)
    if (!Object.prototype.hasOwnProperty.call(t, r[a]) || !Object.is(e[r[a]], t[r[a]])) return !1
  return !0
}
const Ci = '__root__'
function A9(e, t) {
  let r,
    a,
    o,
    u = ''
  for (r in e)
    if ((o = e[r]) !== void 0)
      if (Array.isArray(o))
        for (a = 0; a < o.length; a++)
          u && (u += '&'), (u += encodeURIComponent(r) + '=' + encodeURIComponent(o[a]))
      else u && (u += '&'), (u += encodeURIComponent(r) + '=' + encodeURIComponent(o))
  return '' + u
}
function $R(e) {
  if (!e) return ''
  const t = decodeURIComponent(e)
  return t === 'false' ? !1 : t === 'true' ? !0 : +t * 0 === 0 && +t + '' === t ? +t : t
}
function D9(e, t) {
  let r, a
  const o = {},
    u = e.split('&')
  for (; (r = u.shift()); ) {
    const l = r.indexOf('=')
    if (l !== -1) {
      ;(a = r.slice(0, l)), (a = decodeURIComponent(a))
      const d = r.slice(l + 1)
      o[a] !== void 0 ? (o[a] = [].concat(o[a], $R(d))) : (o[a] = $R(d))
    } else (a = r), (a = decodeURIComponent(a)), (o[a] = '')
  }
  return o
}
const N9 = L9(JSON.parse),
  M9 = P9(JSON.stringify, JSON.parse)
function L9(e) {
  return t => {
    t.substring(0, 1) === '?' && (t = t.substring(1))
    const r = D9(t)
    for (const a in r) {
      const o = r[a]
      if (typeof o == 'string')
        try {
          r[a] = e(o)
        } catch {}
    }
    return r
  }
}
function P9(e, t) {
  function r(a) {
    if (typeof a == 'object' && a !== null)
      try {
        return e(a)
      } catch {}
    else if (typeof a == 'string' && typeof t == 'function')
      try {
        return t(a), e(a)
      } catch {}
    return a
  }
  return a => {
    ;(a = { ...a }),
      Object.keys(a).forEach(u => {
        const l = a[u]
        typeof l > 'u' || l === void 0 ? delete a[u] : (a[u] = r(l))
      })
    const o = A9(a).toString()
    return o ? `?${o}` : ''
  }
}
function Gd(e) {
  return e[e.length - 1]
}
function I9(e) {
  return typeof e == 'function'
}
function El(e, t) {
  return I9(e) ? e(t) : e
}
function Kd(e, t) {
  return t.reduce((r, a) => ((r[a] = e[a]), r), {})
}
function Ku(e, t) {
  if (e === t) return e
  const r = t,
    a = zR(e) && zR(r)
  if (a || (wc(e) && wc(r))) {
    const o = a ? e : Object.keys(e),
      u = o.length,
      l = a ? r : Object.keys(r),
      d = l.length,
      h = a ? [] : {}
    let p = 0
    for (let v = 0; v < d; v++) {
      const g = a ? v : l[v]
      ;((!a && o.includes(g)) || a) && e[g] === void 0 && r[g] === void 0
        ? ((h[g] = void 0), p++)
        : ((h[g] = Ku(e[g], r[g])), h[g] === e[g] && e[g] !== void 0 && p++)
    }
    return u === d && p === u ? e : h
  }
  return r
}
function wc(e) {
  if (!BR(e)) return !1
  const t = e.constructor
  if (typeof t > 'u') return !0
  const r = t.prototype
  return !(!BR(r) || !r.hasOwnProperty('isPrototypeOf'))
}
function BR(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
function zR(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function ac(e, t, r = !1) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (wc(e) && wc(t)) {
    const a = Object.keys(e).filter(u => e[u] !== void 0),
      o = Object.keys(t).filter(u => t[u] !== void 0)
    return !r && a.length !== o.length ? !1 : !o.some(u => !(u in e) || !ac(e[u], t[u], r))
  }
  return Array.isArray(e) && Array.isArray(t)
    ? e.length !== t.length
      ? !1
      : !e.some((a, o) => !ac(a, t[o], r))
    : !1
}
const IE = typeof window < 'u' ? w.useLayoutEffect : w.useEffect
function Zu(e) {
  let t, r
  const a = new Promise((o, u) => {
    ;(t = o), (r = u)
  })
  return (
    (a.status = 'pending'),
    (a.resolve = o => {
      ;(a.status = 'resolved'), (a.value = o), t(o), e == null || e(o)
    }),
    (a.reject = o => {
      ;(a.status = 'rejected'), r(o)
    }),
    a
  )
}
function HR(e) {
  const t = w.useRef({ value: e, prev: null }),
    r = t.current.value
  return e !== r && (t.current = { value: e, prev: r }), t.current.prev
}
function F9(e, t, r = {}, a = {}) {
  const o = w.useRef(typeof IntersectionObserver == 'function'),
    u = w.useRef(null)
  return (
    w.useEffect(() => {
      if (!(!e.current || !o.current || a.disabled))
        return (
          (u.current = new IntersectionObserver(([l]) => {
            t(l)
          }, r)),
          u.current.observe(e.current),
          () => {
            var l
            ;(l = u.current) == null || l.disconnect()
          }
        )
    }, [t, r, a.disabled, e]),
    u.current
  )
}
function V9(e) {
  const t = w.useRef(null)
  return (
    w.useEffect(() => {
      e && (typeof e == 'function' ? e(t.current) : (e.current = t.current))
    }),
    t
  )
}
function Es(e) {
  return og(e.filter(t => t !== void 0).join('/'))
}
function og(e) {
  return e.replace(/\/{2,}/g, '/')
}
function CS(e) {
  return e === '/' ? e : e.replace(/^\/{1,}/, '')
}
function xl(e) {
  return e === '/' ? e : e.replace(/\/{1,}$/, '')
}
function j9(e) {
  return xl(CS(e))
}
function Vv(e, t) {
  return e.endsWith('/') && e !== '/' && e !== `${t}/` ? e.slice(0, -1) : e
}
function U9(e, t, r) {
  return Vv(e, r) === Vv(t, r)
}
function $9({ basepath: e, base: t, to: r, trailingSlash: a = 'never' }) {
  var o, u
  ;(t = jv(e, t)), (r = jv(e, r))
  let l = Rc(t)
  const d = Rc(r)
  l.length > 1 && ((o = Gd(l)) == null ? void 0 : o.value) === '/' && l.pop(),
    d.forEach((p, v) => {
      p.value === '/'
        ? v
          ? v === d.length - 1 && l.push(p)
          : (l = [p])
        : p.value === '..'
          ? l.pop()
          : p.value === '.' || l.push(p)
    }),
    l.length > 1 &&
      (((u = Gd(l)) == null ? void 0 : u.value) === '/'
        ? a === 'never' && l.pop()
        : a === 'always' && l.push({ type: 'pathname', value: '/' }))
  const h = Es([e, ...l.map(p => p.value)])
  return og(h)
}
function Rc(e) {
  if (!e) return []
  e = og(e)
  const t = []
  if ((e.slice(0, 1) === '/' && ((e = e.substring(1)), t.push({ type: 'pathname', value: '/' })), !e))
    return t
  const r = e.split('/').filter(Boolean)
  return (
    t.push(
      ...r.map(a =>
        a === '$' || a === '*'
          ? { type: 'wildcard', value: a }
          : a.charAt(0) === '$'
            ? { type: 'param', value: a }
            : { type: 'pathname', value: decodeURI(a) }
      )
    ),
    e.slice(-1) === '/' && ((e = e.substring(1)), t.push({ type: 'pathname', value: '/' })),
    t
  )
}
function FE({ path: e, params: t, leaveWildcards: r, leaveParams: a }) {
  const o = Rc(e),
    u = {}
  for (const [l, d] of Object.entries(t)) {
    const h = typeof d == 'string'
    ;['*', '_splat'].includes(l) ? (u[l] = h ? encodeURI(d) : d) : (u[l] = h ? encodeURIComponent(d) : d)
  }
  return Es(
    o.map(l => {
      if (l.type === 'wildcard') {
        const d = u._splat
        return r ? `${l.value}${d ?? ''}` : d
      }
      if (l.type === 'param') {
        if (a) {
          const d = u[l.value]
          return `${l.value}${d ?? ''}`
        }
        return u[l.value.substring(1)] ?? 'undefined'
      }
      return l.value
    })
  )
}
function fv(e, t, r) {
  const a = B9(e, t, r)
  if (!(r.to && !a)) return a ?? {}
}
function jv(e, t) {
  switch (!0) {
    case e === '/':
      return t
    case t === e:
      return ''
    case t.length < e.length:
      return t
    case t[e.length] !== '/':
      return t
    case t.startsWith(e):
      return t.slice(e.length)
    default:
      return t
  }
}
function B9(e, t, r) {
  t = jv(e, t)
  const a = jv(e, `${r.to ?? '$'}`),
    o = Rc(t),
    u = Rc(a)
  t.startsWith('/') || o.unshift({ type: 'pathname', value: '/' }),
    a.startsWith('/') || u.unshift({ type: 'pathname', value: '/' })
  const l = {}
  return (() => {
    for (let h = 0; h < Math.max(o.length, u.length); h++) {
      const p = o[h],
        v = u[h],
        g = h >= o.length - 1,
        E = h >= u.length - 1
      if (v) {
        if (v.type === 'wildcard') {
          const x = decodeURI(Es(o.slice(h).map(C => C.value)))
          return (l['*'] = x), (l._splat = x), !0
        }
        if (v.type === 'pathname') {
          if (v.value === '/' && !(p != null && p.value)) return !0
          if (p) {
            if (r.caseSensitive) {
              if (v.value !== p.value) return !1
            } else if (v.value.toLowerCase() !== p.value.toLowerCase()) return !1
          }
        }
        if (!p) return !1
        if (v.type === 'param') {
          if (p.value === '/') return !1
          p.value.charAt(0) !== '$' && (l[v.value.substring(1)] = decodeURIComponent(p.value))
        }
      }
      if (!g && E)
        return (
          (l['**'] = Es(o.slice(h + 1).map(x => x.value))),
          !!r.fuzzy && (v == null ? void 0 : v.value) !== '/'
        )
    }
    return !0
  })()
    ? l
    : void 0
}
function pl(e) {
  return !!(e != null && e.isRedirect)
}
function WR(e) {
  return !!(e != null && e.isRedirect) && e.href
}
function wS(e) {
  const t = e.errorComponent ?? sg
  return dt.jsx(z9, {
    getResetKey: e.getResetKey,
    onCatch: e.onCatch,
    children: ({ error: r, reset: a }) => (r ? w.createElement(t, { error: r, reset: a }) : e.children)
  })
}
class z9 extends w.Component {
  constructor() {
    super(...arguments), (this.state = { error: null })
  }
  static getDerivedStateFromProps(t) {
    return { resetKey: t.getResetKey() }
  }
  static getDerivedStateFromError(t) {
    return { error: t }
  }
  reset() {
    this.setState({ error: null })
  }
  componentDidUpdate(t, r) {
    r.error && r.resetKey !== this.state.resetKey && this.reset()
  }
  componentDidCatch(t, r) {
    this.props.onCatch && this.props.onCatch(t, r)
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset()
      }
    })
  }
}
function sg({ error: e }) {
  const [t, r] = w.useState(!0)
  return dt.jsxs('div', {
    style: { padding: '.5rem', maxWidth: '100%' },
    children: [
      dt.jsxs('div', {
        style: { display: 'flex', alignItems: 'center', gap: '.5rem' },
        children: [
          dt.jsx('strong', { style: { fontSize: '1rem' }, children: 'Something went wrong!' }),
          dt.jsx('button', {
            style: {
              appearance: 'none',
              fontSize: '.6em',
              border: '1px solid currentColor',
              padding: '.1rem .2rem',
              fontWeight: 'bold',
              borderRadius: '.25rem'
            },
            onClick: () => r(a => !a),
            children: t ? 'Hide Error' : 'Show Error'
          })
        ]
      }),
      dt.jsx('div', { style: { height: '.25rem' } }),
      t
        ? dt.jsx('div', {
            children: dt.jsx('pre', {
              style: {
                fontSize: '.7em',
                border: '1px solid red',
                borderRadius: '.25rem',
                padding: '.3rem',
                color: 'red',
                overflow: 'auto'
              },
              children: e.message ? dt.jsx('code', { children: e.message }) : null
            })
          })
        : null
    ]
  })
}
function Ri(e) {
  const t = Ao({ warn: (e == null ? void 0 : e.router) === void 0 })
  return O9(((e == null ? void 0 : e.router) || t).__store, e == null ? void 0 : e.select)
}
function Ia(e) {
  return !!(e != null && e.isNotFound)
}
function H9(e) {
  const t = Ri({ select: r => `not-found-${r.location.pathname}-${r.status}` })
  return dt.jsx(wS, {
    getResetKey: () => t,
    onCatch: (r, a) => {
      var o
      if (Ia(r)) (o = e.onCatch) == null || o.call(e, r, a)
      else throw r
    },
    errorComponent: ({ error: r }) => {
      var a
      return (a = e.fallback) == null ? void 0 : a.call(e, r)
    },
    children: e.children
  })
}
function W9() {
  return dt.jsx('p', { children: 'Not Found' })
}
const Y9 = {
    stringify: e =>
      JSON.stringify(e, function (r, a) {
        const o = this[r],
          u = YR.find(l => l.stringifyCondition(o))
        return u ? u.stringify(o) : a
      }),
    parse: e =>
      JSON.parse(e, function (r, a) {
        const o = this[r],
          u = YR.find(l => l.parseCondition(o))
        return u ? u.parse(o) : a
      })
  },
  YR = [
    {
      stringifyCondition: e => e instanceof Date,
      stringify: e => ({ $date: e.toISOString() }),
      parseCondition: e => wc(e) && e.$date,
      parse: e => new Date(e.$date)
    },
    {
      stringifyCondition: e => e === void 0,
      stringify: () => ({ $undefined: '' }),
      parseCondition: e => wc(e) && e.$undefined === '',
      parse: () => {}
    }
  ],
  q9 = ['component', 'errorComponent', 'pendingComponent', 'notFoundComponent']
function G9(e) {
  return new K9(e)
}
class K9 {
  constructor(t) {
    ;(this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`),
      (this.resetNextScroll = !0),
      (this.shouldViewTransition = void 0),
      (this.subscribers = new Set()),
      (this.startReactTransition = r => r()),
      (this.update = r => {
        r.notFoundRoute &&
          console.warn(
            'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.'
          )
        const a = this.options
        ;(this.options = { ...this.options, ...r }),
          (this.isServer = this.options.isServer ?? typeof document > 'u'),
          (!this.basepath || (r.basepath && r.basepath !== a.basepath)) &&
            (r.basepath === void 0 || r.basepath === '' || r.basepath === '/'
              ? (this.basepath = '/')
              : (this.basepath = `/${j9(r.basepath)}`)),
          (!this.history || (this.options.history && this.options.history !== this.history)) &&
            ((this.history =
              this.options.history ??
              (this.isServer ? C9({ initialEntries: [this.basepath || '/'] }) : T9())),
            (this.latestLocation = this.parseLocation())),
          this.options.routeTree !== this.routeTree &&
            ((this.routeTree = this.options.routeTree), this.buildRouteTree()),
          this.__store ||
            (this.__store = new _9(Q9(this.latestLocation), {
              onUpdate: () => {
                this.__store.state = {
                  ...this.state,
                  cachedMatches: this.state.cachedMatches.filter(o => !['redirected'].includes(o.status))
                }
              }
            }))
      }),
      (this.buildRouteTree = () => {
        ;(this.routesById = {}), (this.routesByPath = {})
        const r = this.options.notFoundRoute
        r && (r.init({ originalIndex: 99999999999 }), (this.routesById[r.id] = r))
        const a = l => {
          l.forEach((d, h) => {
            d.init({ originalIndex: h })
            const p = this.routesById[d.id]
            if (
              (ui(!p, `Duplicate routes found with id: ${String(d.id)}`),
              (this.routesById[d.id] = d),
              !d.isRoot && d.path)
            ) {
              const g = xl(d.fullPath)
              ;(!this.routesByPath[g] || d.fullPath.endsWith('/')) && (this.routesByPath[g] = d)
            }
            const v = d.children
            v != null && v.length && a(v)
          })
        }
        a([this.routeTree])
        const o = []
        Object.values(this.routesById).forEach((l, d) => {
          var h
          if (l.isRoot || !l.path) return
          const p = CS(l.fullPath),
            v = Rc(p)
          for (; v.length > 1 && ((h = v[0]) == null ? void 0 : h.value) === '/'; ) v.shift()
          const g = v.map(E =>
            E.value === '/' ? 0.75 : E.type === 'param' ? 0.5 : E.type === 'wildcard' ? 0.25 : 1
          )
          o.push({ child: l, trimmed: p, parsed: v, index: d, scores: g })
        }),
          (this.flatRoutes = o
            .sort((l, d) => {
              const h = Math.min(l.scores.length, d.scores.length)
              for (let p = 0; p < h; p++)
                if (l.scores[p] !== d.scores[p]) return d.scores[p] - l.scores[p]
              if (l.scores.length !== d.scores.length) return d.scores.length - l.scores.length
              for (let p = 0; p < h; p++)
                if (l.parsed[p].value !== d.parsed[p].value)
                  return l.parsed[p].value > d.parsed[p].value ? 1 : -1
              return l.index - d.index
            })
            .map((l, d) => ((l.child.rank = d), l.child)))
      }),
      (this.subscribe = (r, a) => {
        const o = { eventType: r, fn: a }
        return (
          this.subscribers.add(o),
          () => {
            this.subscribers.delete(o)
          }
        )
      }),
      (this.emit = r => {
        this.subscribers.forEach(a => {
          a.eventType === r.type && a.fn(r)
        })
      }),
      (this.parseLocation = r => {
        const a = ({ pathname: d, search: h, hash: p, state: v }) => {
            const g = this.options.parseSearch(h),
              E = this.options.stringifySearch(g)
            return {
              pathname: d,
              searchStr: E,
              search: Ku(r == null ? void 0 : r.search, g),
              hash: p.split('#').reverse()[0] ?? '',
              href: `${d}${E}${p}`,
              state: Ku(r == null ? void 0 : r.state, v)
            }
          },
          o = a(this.history.location),
          { __tempLocation: u, __tempKey: l } = o.state
        if (u && (!l || l === this.tempLocationKey)) {
          const d = a(u)
          return (d.state.key = o.state.key), delete d.state.__tempLocation, { ...d, maskedLocation: o }
        }
        return o
      }),
      (this.resolvePathWithBase = (r, a) =>
        $9({ basepath: this.basepath, base: r, to: og(a), trailingSlash: this.options.trailingSlash })),
      (this.cancelMatch = r => {
        const a = this.getMatch(r)
        a && (a.abortController.abort(), clearTimeout(a.pendingTimeout))
      }),
      (this.cancelMatches = () => {
        var r
        ;(r = this.state.pendingMatches) == null ||
          r.forEach(a => {
            this.cancelMatch(a.id)
          })
      }),
      (this.buildLocation = r => {
        const a = (u = {}, l) => {
            var d, h, p, v
            const g = u._fromLocation ? this.matchRoutes(u._fromLocation) : this.state.matches,
              E =
                u.from != null
                  ? g.find(G =>
                      fv(this.basepath, xl(G.pathname), { to: u.from, caseSensitive: !1, fuzzy: !1 })
                    )
                  : void 0,
              x = (E == null ? void 0 : E.pathname) || this.latestLocation.pathname
            ui(u.from == null || E != null, 'Could not find match for from: ' + u.from)
            const C = this.state.pendingMatches
                ? (d = Gd(this.state.pendingMatches)) == null
                  ? void 0
                  : d.search
                : ((h = Gd(g)) == null ? void 0 : h.search) || this.latestLocation.search,
              _ = l == null ? void 0 : l.filter(G => g.find(ge => ge.routeId === G.routeId)),
              k =
                this.routesById[
                  (p = _ == null ? void 0 : _.find(G => G.pathname === x)) == null ? void 0 : p.routeId
                ]
            let R = u.to
              ? this.resolvePathWithBase(x, `${u.to}`)
              : this.resolvePathWithBase(x, (k == null ? void 0 : k.to) ?? x)
            const D = { ...((v = Gd(g)) == null ? void 0 : v.params) }
            let A = (u.params ?? !0) === !0 ? D : { ...D, ...El(u.params, D) }
            Object.keys(A).length > 0 &&
              (l == null ||
                l
                  .map(G => {
                    var ge
                    const De = this.looseRoutesById[G.routeId]
                    return (
                      ((ge = De == null ? void 0 : De.options.params) == null ? void 0 : ge.stringify) ??
                      De.options.stringifyParams
                    )
                  })
                  .filter(Boolean)
                  .forEach(G => {
                    A = { ...A, ...G(A) }
                  })),
              (R = FE({ path: R, params: A ?? {}, leaveWildcards: !1, leaveParams: r.leaveParams }))
            const L =
                (_ == null
                  ? void 0
                  : _.map(G => this.looseRoutesById[G.routeId].options.preSearchFilters ?? [])
                      .flat()
                      .filter(Boolean)) ?? [],
              F =
                (_ == null
                  ? void 0
                  : _.map(G => this.looseRoutesById[G.routeId].options.postSearchFilters ?? [])
                      .flat()
                      .filter(Boolean)) ?? [],
              z = L.length ? L.reduce((G, ge) => ge(G), C) : C,
              H = u.search === !0 ? z : u.search ? El(u.search, z) : L.length ? z : {},
              $ = F.length ? F.reduce((G, ge) => ge(G), H) : H,
              Q = Ku(C, $),
              ue = this.options.stringifySearch(Q),
              se =
                u.hash === !0
                  ? this.latestLocation.hash
                  : u.hash
                    ? El(u.hash, this.latestLocation.hash)
                    : void 0,
              we = se ? `#${se}` : ''
            let he =
              u.state === !0
                ? this.latestLocation.state
                : u.state
                  ? El(u.state, this.latestLocation.state)
                  : {}
            return (
              (he = Ku(this.latestLocation.state, he)),
              {
                pathname: R,
                search: Q,
                searchStr: ue,
                state: he,
                hash: se ?? '',
                href: `${R}${ue}${we}`,
                unmaskOnReload: u.unmaskOnReload
              }
            )
          },
          o = (u = {}, l) => {
            var d
            const h = a(u)
            let p = l ? a(l) : void 0
            if (!p) {
              let C = {}
              const _ =
                (d = this.options.routeMasks) == null
                  ? void 0
                  : d.find(k => {
                      const R = fv(this.basepath, h.pathname, {
                        to: k.from,
                        caseSensitive: !1,
                        fuzzy: !1
                      })
                      return R ? ((C = R), !0) : !1
                    })
              if (_) {
                const { from: k, ...R } = _
                ;(l = { ...Kd(r, ['from']), ...R, params: C }), (p = a(l))
              }
            }
            const v = this.matchRoutes(h),
              g = p ? this.matchRoutes(p) : void 0,
              E = p ? a(l, g) : void 0,
              x = a(u, v)
            return E && (x.maskedLocation = E), x
          }
        return r.mask ? o(r, { ...Kd(r, ['from']), ...r.mask }) : o(r)
      }),
      (this.commitLocation = ({ viewTransition: r, ignoreBlocker: a, ...o }) => {
        const u = () => {
            o.state.key = this.latestLocation.state.key
            const h = ac(o.state, this.latestLocation.state)
            return delete o.state.key, h
          },
          l = this.latestLocation.href === o.href,
          d = this.commitLocationPromise
        if (
          ((this.commitLocationPromise = Zu(() => {
            d == null || d.resolve()
          })),
          l && u())
        )
          this.load()
        else {
          let { maskedLocation: h, ...p } = o
          h &&
            ((p = {
              ...h,
              state: {
                ...h.state,
                __tempKey: void 0,
                __tempLocation: {
                  ...p,
                  search: p.searchStr,
                  state: { ...p.state, __tempKey: void 0, __tempLocation: void 0, key: void 0 }
                }
              }
            }),
            (p.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) &&
              (p.state.__tempKey = this.tempLocationKey)),
            (this.shouldViewTransition = r),
            this.history[o.replace ? 'replace' : 'push'](p.href, p.state, { ignoreBlocker: a })
        }
        return (
          (this.resetNextScroll = o.resetScroll ?? !0),
          this.history.subscribers.size || this.load(),
          this.commitLocationPromise
        )
      }),
      (this.buildAndCommitLocation = ({
        replace: r,
        resetScroll: a,
        viewTransition: o,
        ignoreBlocker: u,
        ...l
      } = {}) => {
        const d = l.href
        if (d) {
          const p = Fv(d, {})
          ;(l.to = p.pathname), (l.search = this.options.parseSearch(p.search)), (l.hash = p.hash)
        }
        const h = this.buildLocation(l)
        return this.commitLocation({
          ...h,
          viewTransition: o,
          replace: r,
          resetScroll: a,
          ignoreBlocker: u
        })
      }),
      (this.navigate = ({ to: r, __isRedirect: a, ...o }) => {
        const u = String(r)
        let l
        try {
          new URL(`${u}`), (l = !0)
        } catch {}
        return (
          ui(!l, 'Attempting to navigate to external url with router.navigate!'),
          this.buildAndCommitLocation({ ...o, to: r })
        )
      }),
      (this.load = async () => {
        this.latestLocation = this.parseLocation(this.latestLocation)
        let r, a, o
        for (
          o = new Promise(u => {
            this.startReactTransition(async () => {
              var l
              try {
                const d = this.latestLocation,
                  h = this.state.resolvedLocation,
                  p = h.href !== d.href
                this.cancelMatches()
                let v
                this.__store.batch(() => {
                  ;(v = this.matchRoutes(d)),
                    this.__store.setState(g => ({
                      ...g,
                      status: 'pending',
                      isLoading: !0,
                      location: d,
                      pendingMatches: v,
                      cachedMatches: g.cachedMatches.filter(E => !v.find(x => x.id === E.id))
                    }))
                }),
                  this.state.redirect ||
                    this.emit({
                      type: 'onBeforeNavigate',
                      fromLocation: h,
                      toLocation: d,
                      pathChanged: p
                    }),
                  this.emit({ type: 'onBeforeLoad', fromLocation: h, toLocation: d, pathChanged: p }),
                  await this.loadMatches({
                    matches: v,
                    location: d,
                    onReady: async () => {
                      this.startViewTransition(async () => {
                        let g, E, x
                        this.__store.batch(() => {
                          this.__store.setState(C => {
                            const _ = C.matches,
                              k = C.pendingMatches || C.matches
                            return (
                              (g = _.filter(R => !k.find(D => D.id === R.id))),
                              (E = k.filter(R => !_.find(D => D.id === R.id))),
                              (x = _.filter(R => k.find(D => D.id === R.id))),
                              {
                                ...C,
                                isLoading: !1,
                                loadedAt: Date.now(),
                                matches: k,
                                pendingMatches: void 0,
                                cachedMatches: [
                                  ...C.cachedMatches,
                                  ...g.filter(R => R.status !== 'error')
                                ]
                              }
                            )
                          }),
                            this.cleanCache()
                        }),
                          [
                            [g, 'onLeave'],
                            [E, 'onEnter'],
                            [x, 'onStay']
                          ].forEach(([C, _]) => {
                            C.forEach(k => {
                              var R, D
                              ;(D = (R = this.looseRoutesById[k.routeId].options)[_]) == null ||
                                D.call(R, k)
                            })
                          })
                      })
                    }
                  })
              } catch (d) {
                WR(d)
                  ? ((r = d), this.isServer || this.navigate({ ...d, replace: !0, __isRedirect: !0 }))
                  : Ia(d) && (a = d),
                  this.__store.setState(h => ({
                    ...h,
                    statusCode: r
                      ? r.statusCode
                      : a
                        ? 404
                        : h.matches.some(p => p.status === 'error')
                          ? 500
                          : 200,
                    redirect: r
                  }))
              }
              this.latestLoadPromise === o &&
                ((l = this.commitLocationPromise) == null || l.resolve(),
                (this.latestLoadPromise = void 0),
                (this.commitLocationPromise = void 0)),
                u()
            })
          }),
            this.latestLoadPromise = o,
            await o;
          this.latestLoadPromise && o !== this.latestLoadPromise;

        )
          await this.latestLoadPromise
      }),
      (this.startViewTransition = r => {
        var a, o
        const u = this.shouldViewTransition ?? this.options.defaultViewTransition
        delete this.shouldViewTransition,
          ((o =
            (a = u && typeof document < 'u' ? document : void 0) == null
              ? void 0
              : a.startViewTransition) != null &&
            o.call(a, r)) ||
            r()
      }),
      (this.updateMatch = (r, a) => {
        var o
        let u
        const l = (o = this.state.pendingMatches) == null ? void 0 : o.find(p => p.id === r),
          d = this.state.matches.find(p => p.id === r),
          h = l ? 'pendingMatches' : d ? 'matches' : 'cachedMatches'
        return (
          this.__store.setState(p => {
            var v
            return { ...p, [h]: (v = p[h]) == null ? void 0 : v.map(g => (g.id === r ? (u = a(g)) : g)) }
          }),
          u
        )
      }),
      (this.getMatch = r =>
        [...this.state.cachedMatches, ...(this.state.pendingMatches ?? []), ...this.state.matches].find(
          a => a.id === r
        )),
      (this.loadMatches = async ({
        location: r,
        matches: a,
        preload: o,
        onReady: u,
        updateMatch: l = this.updateMatch
      }) => {
        let d,
          h = !1
        const p = async () => {
          h || ((h = !0), await (u == null ? void 0 : u()))
        }
        !this.isServer && !this.state.matches.length && p()
        const v = (g, E) => {
          var x, C, _
          if (WR(E)) throw E
          if (pl(E) || Ia(E)) {
            if (
              (l(g.id, k => ({
                ...k,
                status: pl(E) ? 'redirected' : Ia(E) ? 'notFound' : 'error',
                isFetching: !1,
                error: E,
                beforeLoadPromise: void 0,
                loaderPromise: void 0
              })),
              E.routeId || (E.routeId = g.routeId),
              (x = g.beforeLoadPromise) == null || x.resolve(),
              (C = g.loaderPromise) == null || C.resolve(),
              (_ = g.loadPromise) == null || _.resolve(),
              pl(E))
            )
              throw ((h = !0), (E = this.resolveRedirect({ ...E, _fromLocation: r })), E)
            if (Ia(E)) throw (this._handleNotFound(a, E, { updateMatch: l }), E)
          }
        }
        try {
          await new Promise((g, E) => {
            ;(async () => {
              var x, C, _
              try {
                const k = (A, L, F) => {
                  var z, H
                  const { id: $, routeId: Q } = a[A],
                    ue = this.looseRoutesById[Q]
                  if (L instanceof Promise) throw L
                  ;(L.routerCode = F), (d = d ?? A), v(this.getMatch($), L)
                  try {
                    ;(H = (z = ue.options).onError) == null || H.call(z, L)
                  } catch (se) {
                    ;(L = se), v(this.getMatch($), L)
                  }
                  l($, se => {
                    var we
                    return (
                      (we = se.beforeLoadPromise) == null || we.resolve(),
                      {
                        ...se,
                        error: L,
                        status: 'error',
                        isFetching: !1,
                        updatedAt: Date.now(),
                        abortController: new AbortController(),
                        beforeLoadPromise: void 0
                      }
                    )
                  })
                }
                for (const [A, { id: L, routeId: F }] of a.entries()) {
                  const z = this.getMatch(L),
                    H = (x = a[A - 1]) == null ? void 0 : x.id,
                    $ = this.looseRoutesById[F],
                    Q = $.options.pendingMs ?? this.options.defaultPendingMs,
                    ue = !!(
                      u &&
                      !this.isServer &&
                      !o &&
                      ($.options.loader || $.options.beforeLoad) &&
                      typeof Q == 'number' &&
                      Q !== 1 / 0 &&
                      ($.options.pendingComponent ?? this.options.defaultPendingComponent)
                    )
                  if (z.beforeLoadPromise || z.loaderPromise)
                    ue &&
                      setTimeout(() => {
                        try {
                          p()
                        } catch {}
                      }, Q),
                      await z.beforeLoadPromise
                  else {
                    try {
                      l(L, Ue => ({
                        ...Ue,
                        loadPromise: Zu(() => {
                          var pe
                          ;(pe = Ue.loadPromise) == null || pe.resolve()
                        }),
                        beforeLoadPromise: Zu()
                      }))
                      const se = new AbortController()
                      let we
                      ue &&
                        (we = setTimeout(() => {
                          try {
                            p()
                          } catch {}
                        }, Q))
                      const { paramsError: he, searchError: G } = this.getMatch(L)
                      he && k(A, he, 'PARSE_PARAMS'), G && k(A, G, 'VALIDATE_SEARCH')
                      const ge = () => (H ? this.getMatch(H).context : (this.options.context ?? {}))
                      l(L, Ue => ({
                        ...Ue,
                        isFetching: 'beforeLoad',
                        fetchCount: Ue.fetchCount + 1,
                        abortController: se,
                        pendingTimeout: we,
                        context: { ...ge(), ...Ue.__routeContext, ...Ue.__beforeLoadContext }
                      }))
                      const { search: De, params: de, context: ve, cause: Ke } = this.getMatch(L),
                        ot = {
                          search: De,
                          abortController: se,
                          params: de,
                          preload: !!o,
                          context: ve,
                          location: r,
                          navigate: Ue => this.navigate({ ...Ue, _fromLocation: r }),
                          buildLocation: this.buildLocation,
                          cause: o ? 'preload' : Ke,
                          matches: a
                        }
                      let Me =
                        (await ((_ = (C = $.options).beforeLoad) == null ? void 0 : _.call(C, ot))) ?? {}
                      this.serializeLoaderData &&
                        (Me = this.serializeLoaderData('__beforeLoadContext', Me, {
                          router: this,
                          match: this.getMatch(L)
                        })),
                        (pl(Me) || Ia(Me)) && k(A, Me, 'BEFORE_LOAD'),
                        l(L, Ue => ({
                          ...Ue,
                          __beforeLoadContext: Me,
                          context: { ...ge(), ...Ue.__routeContext, ...Me },
                          abortController: se
                        }))
                    } catch (se) {
                      k(A, se, 'BEFORE_LOAD')
                    }
                    l(L, se => {
                      var we
                      return (
                        (we = se.beforeLoadPromise) == null || we.resolve(),
                        { ...se, beforeLoadPromise: void 0, isFetching: !1 }
                      )
                    })
                  }
                }
                const R = a.slice(0, d),
                  D = []
                R.forEach(({ id: A, routeId: L }, F) => {
                  D.push(
                    (async () => {
                      const { loaderPromise: z } = this.getMatch(A)
                      let H = !1
                      if (z) await z
                      else {
                        const $ = D[F - 1],
                          Q = this.looseRoutesById[L],
                          ue = () => {
                            const {
                              params: ot,
                              loaderDeps: Me,
                              abortController: Ue,
                              context: pe,
                              cause: xt
                            } = this.getMatch(A)
                            return {
                              params: ot,
                              deps: Me,
                              preload: !!o,
                              parentMatchPromise: $,
                              abortController: Ue,
                              context: pe,
                              location: r,
                              navigate: Ye => this.navigate({ ...Ye, _fromLocation: r }),
                              cause: o ? 'preload' : xt,
                              route: Q
                            }
                          },
                          se = Date.now() - this.getMatch(A).updatedAt,
                          we = o
                            ? (Q.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4)
                            : (Q.options.staleTime ?? this.options.defaultStaleTime ?? 0),
                          he = Q.options.shouldReload,
                          G = typeof he == 'function' ? he(ue()) : he
                        l(A, ot => ({
                          ...ot,
                          loaderPromise: Zu(),
                          preload: !!o && !this.state.matches.find(Me => Me.id === A)
                        }))
                        const ge = async () => {
                            var ot, Me, Ue, pe, xt, Ye, kt, yt
                            try {
                              const Et = async () => {
                                const st = this.getMatch(A)
                                st.minPendingPromise && (await st.minPendingPromise)
                              }
                              try {
                                Q._lazyPromise =
                                  Q._lazyPromise ||
                                  (Q.lazyFn
                                    ? Q.lazyFn().then(Re => {
                                        Object.assign(Q.options, Re.options)
                                      })
                                    : Promise.resolve())
                                const st =
                                  this.getMatch(A).componentsPromise ||
                                  Q._lazyPromise.then(() =>
                                    Promise.all(
                                      q9.map(async Re => {
                                        const Oe = Q.options[Re]
                                        Oe != null && Oe.preload && (await Oe.preload())
                                      })
                                    )
                                  )
                                l(A, Re => ({ ...Re, isFetching: 'loader', componentsPromise: st })),
                                  await Q._lazyPromise
                                let At = await ((Me = (ot = Q.options).loader) == null
                                  ? void 0
                                  : Me.call(ot, ue()))
                                this.serializeLoaderData &&
                                  (At = this.serializeLoaderData('loaderData', At, {
                                    router: this,
                                    match: this.getMatch(A)
                                  })),
                                  v(this.getMatch(A), At),
                                  await Et()
                                const en =
                                    (pe = (Ue = Q.options).meta) == null
                                      ? void 0
                                      : pe.call(Ue, {
                                          matches: a,
                                          match: this.getMatch(A),
                                          params: this.getMatch(A).params,
                                          loaderData: At
                                        }),
                                  nn =
                                    (Ye = (xt = Q.options).headers) == null
                                      ? void 0
                                      : Ye.call(xt, { loaderData: At })
                                l(A, Re => ({
                                  ...Re,
                                  error: void 0,
                                  status: 'success',
                                  isFetching: !1,
                                  updatedAt: Date.now(),
                                  loaderData: At,
                                  meta: en,
                                  headers: nn
                                }))
                              } catch (st) {
                                let At = st
                                await Et(), v(this.getMatch(A), st)
                                try {
                                  ;(yt = (kt = Q.options).onError) == null || yt.call(kt, st)
                                } catch (en) {
                                  ;(At = en), v(this.getMatch(A), en)
                                }
                                l(A, en => ({ ...en, error: At, status: 'error', isFetching: !1 }))
                              }
                              await this.getMatch(A).componentsPromise
                            } catch (Et) {
                              v(this.getMatch(A), Et)
                            }
                          },
                          { status: De, invalid: de } = this.getMatch(A)
                        ;(H = De === 'success' && (de || (G ?? se > we))),
                          (o && Q.options.preload === !1) ||
                            (H
                              ? (async () => {
                                  try {
                                    await ge()
                                  } catch {}
                                })()
                              : De !== 'success' && (await ge()))
                        const { loaderPromise: ve, loadPromise: Ke } = this.getMatch(A)
                        ve == null || ve.resolve(), Ke == null || Ke.resolve()
                      }
                      l(A, $ => ({ ...$, isFetching: H ? $.isFetching : !1, loaderPromise: void 0 }))
                    })()
                  )
                }),
                  await Promise.all(D),
                  g()
              } catch (k) {
                E(k)
              }
            })()
          }),
            await p()
        } catch (g) {
          if (pl(g) || Ia(g)) throw (Ia(g) && !o && (await p()), g)
        }
        return a
      }),
      (this.invalidate = () => {
        const r = a => ({
          ...a,
          invalid: !0,
          ...(a.status === 'error' ? { status: 'pending', error: void 0 } : {})
        })
        return (
          this.__store.setState(a => {
            var o
            return {
              ...a,
              matches: a.matches.map(r),
              cachedMatches: a.cachedMatches.map(r),
              pendingMatches: (o = a.pendingMatches) == null ? void 0 : o.map(r)
            }
          }),
          this.load()
        )
      }),
      (this.resolveRedirect = r => {
        const a = r
        return a.href || (a.href = this.buildLocation(a).href), a
      }),
      (this.cleanCache = () => {
        this.__store.setState(r => ({
          ...r,
          cachedMatches: r.cachedMatches.filter(a => {
            const o = this.looseRoutesById[a.routeId]
            if (!o.options.loader) return !1
            const u =
              (a.preload
                ? (o.options.preloadGcTime ?? this.options.defaultPreloadGcTime)
                : (o.options.gcTime ?? this.options.defaultGcTime)) ?? 5 * 60 * 1e3
            return a.status !== 'error' && Date.now() - a.updatedAt < u
          })
        }))
      }),
      (this.preloadRoute = async r => {
        const a = this.buildLocation(r)
        let o = this.matchRoutes(a, { throwOnError: !0, preload: !0 })
        const u = Object.fromEntries(
          [...this.state.matches, ...(this.state.pendingMatches ?? []), ...this.state.cachedMatches].map(
            d => [d.id, !0]
          )
        )
        this.__store.batch(() => {
          o.forEach(d => {
            u[d.id] || this.__store.setState(h => ({ ...h, cachedMatches: [...h.cachedMatches, d] }))
          })
        })
        const l = new Set([...this.state.matches, ...(this.state.pendingMatches ?? [])].map(d => d.id))
        try {
          return (
            (o = await this.loadMatches({
              matches: o,
              location: a,
              preload: !0,
              updateMatch: (d, h) => {
                l.has(d) ? (o = o.map(p => (p.id === d ? h(p) : p))) : this.updateMatch(d, h)
              }
            })),
            o
          )
        } catch (d) {
          if (pl(d)) return await this.preloadRoute({ ...d, _fromLocation: a })
          console.error(d)
          return
        }
      }),
      (this.matchRoute = (r, a) => {
        const o = {
            ...r,
            to: r.to ? this.resolvePathWithBase(r.from || '', r.to) : void 0,
            params: r.params || {},
            leaveParams: !0
          },
          u = this.buildLocation(o)
        if (a != null && a.pending && this.state.status !== 'pending') return !1
        const d = ((a == null ? void 0 : a.pending) === void 0 ? !this.state.isLoading : a.pending)
            ? this.latestLocation
            : this.state.resolvedLocation,
          h = fv(this.basepath, d.pathname, { ...a, to: u.pathname })
        return !h || (r.params && !ac(h, r.params, !0))
          ? !1
          : h && ((a == null ? void 0 : a.includeSearch) ?? !0)
            ? ac(d.search, u.search, !0)
              ? h
              : !1
            : h
      }),
      (this.dehydrate = () => {
        var r
        const a = ((r = this.options.errorSerializer) == null ? void 0 : r.serialize) ?? J9
        return {
          state: {
            dehydratedMatches: this.state.matches.map(o => ({
              ...Kd(o, ['id', 'status', 'updatedAt']),
              error: o.error ? { data: a(o.error), __isServerError: !0 } : void 0
            }))
          },
          manifest: this.manifest
        }
      }),
      (this.hydrate = () => {
        var r, a, o
        let u
        typeof document < 'u' &&
          (u = this.options.transformer.parse((r = window.__TSR__) == null ? void 0 : r.dehydrated)),
          ui(
            u,
            'Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!'
          ),
          (this.dehydratedData = u.payload),
          (o = (a = this.options).hydrate) == null || o.call(a, u.payload)
        const l = u.router.state,
          d = this.matchRoutes(this.state.location).map(h => {
            const p = l.dehydratedMatches.find(v => v.id === h.id)
            return (
              ui(p, `Could not find a client-side match for dehydrated match with id: ${h.id}!`),
              { ...h, ...p }
            )
          })
        this.__store.setState(h => ({ ...h, matches: d })), (this.manifest = u.router.manifest)
      }),
      (this.injectedHtml = []),
      (this.injectHtml = r => {
        const a = () => ((this.injectedHtml = this.injectedHtml.filter(o => o !== a)), r)
        this.injectedHtml.push(a)
      }),
      (this.streamedKeys = new Set()),
      (this.getStreamedValue = r => {
        var a
        if (this.isServer) return
        const o = (a = window.__TSR__) == null ? void 0 : a.streamedValues[r]
        if (o) return o.parsed || (o.parsed = this.options.transformer.parse(o.value)), o.parsed
      }),
      (this.streamValue = (r, a) => {
        var o
        Il(!this.streamedKeys.has(r), 'Key has already been streamed: ' + r), this.streamedKeys.add(r)
        const u = `__TSR__.streamedValues['${r}'] = { value: ${(o = this.serializer) == null ? void 0 : o.call(this, this.options.transformer.stringify(a))}}`
        this.injectHtml(
          `<script class='tsr-once'>${u}${`; console.info(\`Injected From Server:
        ${u}\`)`}; __TSR__.cleanScripts()<\/script>`
        )
      }),
      (this._handleNotFound = (r, a, { updateMatch: o = this.updateMatch } = {}) => {
        const u = Object.fromEntries(r.map(h => [h.routeId, h]))
        let l =
          (a.global ? this.looseRoutesById[Ci] : this.looseRoutesById[a.routeId]) ||
          this.looseRoutesById[Ci]
        for (; !l.options.notFoundComponent && !this.options.defaultNotFoundComponent && l.id !== Ci; )
          (l = l.parentRoute), ui(l, 'Found invalid route tree while trying to find not-found handler.')
        const d = u[l.id]
        ui(d, 'Could not find match for route: ' + l.id),
          o(d.id, h => ({ ...h, status: 'notFound', error: a, isFetching: !1 })),
          a.routerCode === 'BEFORE_LOAD' &&
            l.parentRoute &&
            ((a.routeId = l.parentRoute.id), this._handleNotFound(r, a, { updateMatch: o }))
      }),
      (this.hasNotFoundMatch = () =>
        this.__store.state.matches.some(r => r.status === 'notFound' || r.globalNotFound)),
      this.update({
        defaultPreloadDelay: 50,
        defaultPendingMs: 1e3,
        defaultPendingMinMs: 500,
        context: void 0,
        ...t,
        notFoundMode: t.notFoundMode ?? 'fuzzy',
        stringifySearch: t.stringifySearch ?? M9,
        parseSearch: t.parseSearch ?? N9,
        transformer: t.transformer ?? Y9
      }),
      typeof document < 'u' && (window.__TSR__ROUTER__ = this)
  }
  get state() {
    return this.__store.state
  }
  get looseRoutesById() {
    return this.routesById
  }
  matchRoutes(t, r, a) {
    return typeof t == 'string'
      ? this.matchRoutesInternal({ pathname: t, search: r }, a)
      : this.matchRoutesInternal(t, r)
  }
  matchRoutesInternal(t, r) {
    let a = {}
    const o = this.flatRoutes.find(g => {
      const E = fv(this.basepath, xl(t.pathname), {
        to: g.fullPath,
        caseSensitive: g.options.caseSensitive ?? this.options.caseSensitive,
        fuzzy: !0
      })
      return E ? ((a = E), !0) : !1
    })
    let u = o || this.routesById[Ci]
    const l = [u]
    let d = !1
    for (
      (o ? o.path !== '/' && a['**'] : xl(t.pathname)) &&
      (this.options.notFoundRoute ? l.push(this.options.notFoundRoute) : (d = !0));
      u.parentRoute;

    )
      (u = u.parentRoute), l.unshift(u)
    const h = (() => {
        if (d) {
          if (this.options.notFoundMode !== 'root')
            for (let g = l.length - 1; g >= 0; g--) {
              const E = l[g]
              if (E.children) return E.id
            }
          return Ci
        }
      })(),
      p = l.map(g => {
        var E
        let x
        const C = ((E = g.options.params) == null ? void 0 : E.parse) ?? g.options.parseParams
        if (C)
          try {
            const _ = C(a)
            Object.assign(a, _)
          } catch (_) {
            if (((x = new X9(_.message, { cause: _ })), r != null && r.throwOnError)) throw x
            return x
          }
      }),
      v = []
    return (
      l.forEach((g, E) => {
        var x, C, _, k, R, D, A, L, F, z, H, $
        const Q = v[E - 1],
          [ue, se] = (() => {
            const Ue = (Q == null ? void 0 : Q.search) ?? t.search
            try {
              const pe =
                  typeof g.options.validateSearch == 'object'
                    ? g.options.validateSearch.parse
                    : g.options.validateSearch,
                xt = (pe == null ? void 0 : pe(Ue)) ?? {}
              return [{ ...Ue, ...xt }, void 0]
            } catch (pe) {
              const xt = new Z9(pe.message, { cause: pe })
              if (r != null && r.throwOnError) throw xt
              return [Ue, xt]
            }
          })(),
          we = ((C = (x = g.options).loaderDeps) == null ? void 0 : C.call(x, { search: ue })) ?? '',
          he = we ? JSON.stringify(we) : '',
          G = FE({ path: g.fullPath, params: a }),
          ge = FE({ path: g.id, params: a, leaveWildcards: !0 }) + he,
          De = this.getMatch(ge),
          de = this.state.matches.find(Ue => Ue.id === ge) ? 'stay' : 'enter'
        let ve
        if (De) ve = { ...De, cause: de, params: a }
        else {
          const Ue = g.options.loader || g.options.beforeLoad || g.lazyFn ? 'pending' : 'success'
          ve = {
            id: ge,
            index: E,
            routeId: g.id,
            params: a,
            pathname: Es([this.basepath, G]),
            updatedAt: Date.now(),
            search: {},
            searchError: void 0,
            status: Ue,
            isFetching: !1,
            error: void 0,
            paramsError: p[E],
            __routeContext: {},
            __beforeLoadContext: {},
            context: {},
            abortController: new AbortController(),
            fetchCount: 0,
            cause: de,
            loaderDeps: we,
            invalid: !1,
            preload: !1,
            links: (k = (_ = g.options).links) == null ? void 0 : k.call(_),
            scripts: (D = (R = g.options).scripts) == null ? void 0 : D.call(R),
            staticData: g.options.staticData || {},
            loadPromise: Zu(),
            fullPath: g.fullPath
          }
        }
        ve.status === 'success' &&
          ((ve.meta =
            (L = (A = g.options).meta) == null
              ? void 0
              : L.call(A, { matches: v, match: ve, params: ve.params, loaderData: ve.loaderData })),
          (ve.headers =
            (z = (F = g.options).headers) == null ? void 0 : z.call(F, { loaderData: ve.loaderData }))),
          (r != null && r.preload) || (ve.globalNotFound = h === g.id),
          (ve.search = Ku(ve.search, ue)),
          (ve.searchError = se)
        const ot = (Q == null ? void 0 : Q.id)
          ? (Q.context ?? this.options.context ?? {})
          : (this.options.context ?? {})
        ve.context = { ...ot, ...ve.__routeContext, ...ve.__beforeLoadContext }
        const Me = {
          search: ve.search,
          params: ve.params,
          context: ve.context,
          location: t,
          navigate: Ue => this.navigate({ ...Ue, _fromLocation: t }),
          buildLocation: this.buildLocation,
          cause: ve.cause,
          abortController: ve.abortController,
          preload: !!ve.preload,
          matches: v
        }
        ;(ve.__routeContext = (($ = (H = g.options).context) == null ? void 0 : $.call(H, Me)) ?? {}),
          (ve.context = { ...ot, ...ve.__routeContext, ...ve.__beforeLoadContext }),
          v.push(ve)
      }),
      v
    )
  }
}
class Z9 extends Error {}
class X9 extends Error {}
function Q9(e) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: 'idle',
    resolvedLocation: { ...e },
    location: e,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  }
}
function J9(e) {
  if (e instanceof Error) {
    const t = { name: e.name, message: e.message }
    return (t.stack = e.stack), t
  }
  return { data: e }
}
function qR(e) {
  return !(typeof e == 'object' && e && 'data' in e) ||
    !('__isServerError' in e && e.__isServerError) ||
    !(typeof e.data == 'object' && e.data)
    ? !1
    : e.__isServerError === !0
}
function GR(e) {
  if ('name' in e && 'message' in e) {
    const t = new Error(e.message)
    return (t.name = e.name), (t.stack = e.stack), t
  }
  return e.data
}
const lg = w.createContext(void 0)
function xs(e) {
  const t = w.useContext(lg)
  return Ri({
    select: a => {
      const o = a.matches.find(u => (e.from ? e.from === u.routeId : u.id === t))
      if (
        (ui(
          !((e.shouldThrow ?? !0) && !o),
          `Could not find ${e.from ? `an active match from "${e.from}"` : 'a nearest match!'}`
        ),
        o !== void 0)
      )
        return e.select ? e.select(o) : o
    }
  })
}
function rA(e) {
  return xs({
    ...e,
    select: t => (typeof e.select == 'function' ? e.select(t.loaderDeps) : t.loaderDeps)
  })
}
function iA(e) {
  return xs({
    ...e,
    select: t => (typeof e.select == 'function' ? e.select(t.loaderData) : t.loaderData)
  })
}
function aA(e) {
  return xs({ ...e, select: t => (e.select ? e.select(t.params) : t.params) })
}
function Mc(e) {
  return xs({ ...e, select: t => (e.select ? e.select(t.search) : t.search) })
}
function Lc(e) {
  const { navigate: t } = Ao()
  return w.useCallback(r => t({ ...r }), [t])
}
let oA = class {
  constructor(t) {
    ;(this.init = r => {
      var a, o
      this.originalIndex = r.originalIndex
      const u = this.options,
        l = !(u != null && u.path) && !(u != null && u.id)
      ;(this.parentRoute = (o = (a = this.options).getParentRoute) == null ? void 0 : o.call(a)),
        l
          ? (this._path = Ci)
          : ui(
              this.parentRoute,
              "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance."
            )
      let d = l ? Ci : u.path
      d && d !== '/' && (d = CS(d))
      const h = (u == null ? void 0 : u.id) || d
      let p = l ? Ci : Es([this.parentRoute.id === Ci ? '' : this.parentRoute.id, h])
      d === Ci && (d = '/'), p !== Ci && (p = Es(['/', p]))
      const v = p === Ci ? '/' : Es([this.parentRoute.fullPath, d])
      ;(this._path = d), (this._id = p), (this._fullPath = v), (this._to = v)
    }),
      (this.updateLoader = r => (Object.assign(this.options, r), this)),
      (this.update = r => (Object.assign(this.options, r), this)),
      (this.lazy = r => ((this.lazyFn = r), this)),
      (this.useMatch = r => xs({ ...r, from: this.id })),
      (this.useRouteContext = r =>
        xs({
          ...r,
          from: this.id,
          select: a => (r != null && r.select ? r.select(a.context) : a.context)
        })),
      (this.useSearch = r => Mc({ ...r, from: this.id })),
      (this.useParams = r => aA({ ...r, from: this.id })),
      (this.useLoaderDeps = r => rA({ ...r, from: this.id })),
      (this.useLoaderData = r => iA({ ...r, from: this.id })),
      (this.useNavigate = () => Lc({ from: this.id })),
      (this.options = t || {}),
      (this.isRoot = !(t != null && t.getParentRoute)),
      ui(
        !(t != null && t.id && t != null && t.path),
        "Route cannot have both an 'id' and a 'path' option."
      ),
      (this.$$typeof = Symbol.for('react.memo'))
  }
  get to() {
    return this._to
  }
  get id() {
    return this._id
  }
  get path() {
    return this._path
  }
  get fullPath() {
    return this._fullPath
  }
  addChildren(t) {
    return this._addFileChildren(t)
  }
  _addFileChildren(t) {
    return (
      Array.isArray(t) && (this.children = t),
      typeof t == 'object' && t !== null && (this.children = Object.values(t)),
      this
    )
  }
}
function eV(e) {
  return new oA(e)
}
class tV extends oA {
  constructor(t) {
    super(t)
  }
  addChildren(t) {
    return super.addChildren(t), this
  }
  _addFileChildren(t) {
    return super._addFileChildren(t), this
  }
  _addFileTypes() {
    return this
  }
}
function nV(e) {
  return new tV(e)
}
function sA(e) {
  return new rV(e, { silent: !0 }).createRoute
}
class rV {
  constructor(t, r) {
    ;(this.path = t),
      (this.createRoute = a => {
        Il(
          this.silent,
          'FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.'
        )
        const o = eV(a)
        return (o.isRoot = !1), o
      }),
      (this.silent = r == null ? void 0 : r.silent)
  }
}
class iV {
  constructor(t) {
    ;(this.useMatch = r => xs({ select: r == null ? void 0 : r.select, from: this.options.id })),
      (this.useRouteContext = r =>
        xs({
          from: this.options.id,
          select: a => (r != null && r.select ? r.select(a.context) : a.context)
        })),
      (this.useSearch = r => Mc({ ...r, from: this.options.id })),
      (this.useParams = r => aA({ ...r, from: this.options.id })),
      (this.useLoaderDeps = r => rA({ ...r, from: this.options.id })),
      (this.useLoaderData = r => iA({ ...r, from: this.options.id })),
      (this.useNavigate = () => Lc({ from: this.options.id })),
      (this.options = t),
      (this.$$typeof = Symbol.for('react.memo'))
  }
}
const aV = /\(.+\)/g
function oV(e) {
  return e.replaceAll(aV, '').replaceAll('//', '/')
}
function vZ(e) {
  return t => new iV({ id: oV(e), ...t })
}
const sV = 'Error preloading route! '
function lV(e, t) {
  const r = Ao(),
    [a, o] = w.useState(!1),
    u = V9(t),
    {
      activeProps: l = () => ({ className: 'active' }),
      inactiveProps: d = () => ({}),
      activeOptions: h,
      hash: p,
      search: v,
      params: g,
      to: E,
      state: x,
      mask: C,
      preload: _,
      preloadDelay: k,
      replace: R,
      startTransition: D,
      resetScroll: A,
      viewTransition: L,
      children: F,
      target: z,
      disabled: H,
      style: $,
      className: Q,
      onClick: ue,
      onFocus: se,
      onMouseEnter: we,
      onMouseLeave: he,
      onTouchStart: G,
      ignoreBlocker: ge,
      ...De
    } = e,
    de = w.useMemo(() => {
      try {
        return new URL(`${E}`), 'external'
      } catch {}
      return 'internal'
    }, [E]),
    ve = w.useMemo(() => r.buildLocation(e), [r, e]),
    Ke = w.useMemo(() => _ ?? r.options.defaultPreload, [r.options.defaultPreload, _]),
    ot = k ?? r.options.defaultPreloadDelay ?? 0,
    Me = Ri({
      select: Oe => {
        const Xe = Vv(Oe.location.pathname, r.basepath).split('/'),
          Vt = Vv(ve.pathname, r.basepath)
            .split('/')
            .every((tr, Un) => tr === Xe[Un]),
          Cn = h != null && h.exact ? U9(Oe.location.pathname, ve.pathname, r.basepath) : Vt,
          xn = h != null && h.includeHash ? Oe.location.hash === ve.hash : !0,
          Pn =
            ((h == null ? void 0 : h.includeSearch) ?? !0)
              ? ac(Oe.location.search, ve.search, !(h != null && h.exact))
              : !0
        return Cn && xn && Pn
      }
    }),
    Ue = w.useCallback(() => {
      r.preloadRoute(e).catch(Oe => {
        console.warn(Oe), console.warn(sV)
      })
    }, [e, r]),
    pe = w.useCallback(
      Oe => {
        Oe != null && Oe.isIntersecting && Ue()
      },
      [Ue]
    )
  if ((F9(u, pe, { rootMargin: '100px' }, { disabled: !!H || Ke !== 'viewport' }), de === 'external'))
    return {
      ...De,
      ref: u,
      type: de,
      href: E,
      ...(F && { children: F }),
      ...(z && { target: z }),
      ...(H && { disabled: H }),
      ...($ && { style: $ }),
      ...(Q && { className: Q }),
      ...(ue && { onClick: ue }),
      ...(se && { onFocus: se }),
      ...(we && { onMouseEnter: we }),
      ...(he && { onMouseLeave: he }),
      ...(G && { onTouchStart: G })
    }
  const xt = Oe => {
      if (!H && !cV(Oe) && !Oe.defaultPrevented && (!z || z === '_self') && Oe.button === 0) {
        Oe.preventDefault(),
          Pr.flushSync(() => {
            o(!0)
          })
        const Xe = r.subscribe('onResolved', () => {
          Xe(), o(!1)
        })
        r.commitLocation({
          ...ve,
          replace: R,
          resetScroll: A,
          startTransition: D,
          viewTransition: L,
          ignoreBlocker: ge
        })
      }
    },
    Ye = Oe => {
      H || (Ke && Ue())
    },
    kt = Ye,
    yt = Oe => {
      if (H) return
      const Xe = Oe.target || {}
      if (Ke) {
        if (Xe.preloadTimeout) return
        Xe.preloadTimeout = setTimeout(() => {
          ;(Xe.preloadTimeout = null), Ue()
        }, ot)
      }
    },
    Et = Oe => {
      if (H) return
      const Xe = Oe.target || {}
      Xe.preloadTimeout && (clearTimeout(Xe.preloadTimeout), (Xe.preloadTimeout = null))
    },
    st = Oe => Xe => {
      var Dt
      ;(Dt = Xe.persist) == null || Dt.call(Xe),
        Oe.filter(Boolean).forEach(Vt => {
          Xe.defaultPrevented || Vt(Xe)
        })
    },
    At = Me ? (El(l, {}) ?? {}) : {},
    en = Me ? {} : El(d, {}),
    nn = [Q, At.className, en.className].filter(Boolean).join(' '),
    Re = { ...$, ...At.style, ...en.style }
  return {
    ...At,
    ...en,
    ...De,
    href: H
      ? void 0
      : ve.maskedLocation
        ? r.history.createHref(ve.maskedLocation.href)
        : r.history.createHref(ve.href),
    ref: u,
    onClick: st([ue, xt]),
    onFocus: st([se, Ye]),
    onMouseEnter: st([we, yt]),
    onMouseLeave: st([he, Et]),
    onTouchStart: st([G, kt]),
    disabled: !!H,
    target: z,
    ...(Object.keys(Re).length && { style: Re }),
    ...(nn && { className: nn }),
    ...(H && { role: 'link', 'aria-disabled': !0 }),
    ...(Me && { 'data-status': 'active', 'aria-current': 'page' }),
    ...(a && { 'data-transitioning': 'transitioning' })
  }
}
const uV = w.forwardRef((e, t) => {
  const { _asChild: r, ...a } = e,
    { type: o, ref: u, ...l } = lV(a, t),
    d =
      typeof a.children == 'function'
        ? a.children({ isActive: l['data-status'] === 'active' })
        : a.children
  return typeof r > 'u' && delete l.disabled, w.createElement(r || 'a', { ...l, ref: u }, d)
})
function cV(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function fV() {
  const e = Ao(),
    t = w.useRef({ router: e, mounted: !1 }),
    r = Ri({ select: p => Kd(p, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']) }),
    [a, o] = w.useTransition(),
    u = Ri({ select: p => p.matches.some(v => v.status === 'pending') }),
    l = HR(r.isLoading),
    d = r.isLoading || a || u,
    h = HR(d)
  return (
    e.isServer || (e.startReactTransition = o),
    w.useEffect(() => {
      const p = e.history.subscribe(e.load),
        v = e.buildLocation({
          to: e.latestLocation.pathname,
          search: !0,
          params: !0,
          hash: !0,
          state: !0
        })
      return (
        xl(e.latestLocation.href) !== xl(v.href) && e.commitLocation({ ...v, replace: !0 }),
        () => {
          p()
        }
      )
    }, [e, e.history]),
    IE(() => {
      var p
      if (
        (typeof window < 'u' && (p = window.__TSR__) != null && p.dehydrated) ||
        (t.current.router === e && t.current.mounted)
      )
        return
      ;(t.current = { router: e, mounted: !0 }),
        (async () => {
          try {
            await e.load()
          } catch (g) {
            console.error(g)
          }
        })()
    }, [e]),
    IE(() => {
      if (l && !r.isLoading) {
        const p = e.state.location,
          v = e.state.resolvedLocation,
          g = v.href !== p.href
        e.emit({ type: 'onLoad', fromLocation: v, toLocation: p, pathChanged: g })
      }
    }, [l, e, r.isLoading]),
    IE(() => {
      if (h && !d) {
        const p = e.state.location,
          v = e.state.resolvedLocation,
          g = v.href !== p.href
        if (
          (e.emit({ type: 'onResolved', fromLocation: v, toLocation: p, pathChanged: g }),
          e.__store.setState(E => ({ ...E, status: 'idle', resolvedLocation: E.location })),
          typeof document < 'u' && document.querySelector && e.state.location.hash !== '')
        ) {
          const E = document.getElementById(e.state.location.hash)
          E && E.scrollIntoView()
        }
      }
    }, [d, h, e]),
    null
  )
}
function Cv(e) {
  return dt.jsx(dt.Fragment, { children: e.children })
}
function lA(e, t, r) {
  return t.options.notFoundComponent
    ? dt.jsx(t.options.notFoundComponent, { data: r })
    : e.options.defaultNotFoundComponent
      ? dt.jsx(e.options.defaultNotFoundComponent, { data: r })
      : (Il(
          t.options.notFoundComponent,
          `A notFoundError was encountered on the route with ID "${t.id}", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`
        ),
        dt.jsx(W9, {}))
}
const uA = w.memo(function ({ matchId: t }) {
    var r, a
    const o = Ao(),
      u = Ri({
        select: k => {
          var R
          return (R = k.matches.find(D => D.id === t)) == null ? void 0 : R.routeId
        }
      })
    ui(u, `Could not find routeId for matchId "${t}". Please file an issue!`)
    const l = o.routesById[u],
      d = l.options.pendingComponent ?? o.options.defaultPendingComponent,
      h = d ? dt.jsx(d, {}) : null,
      p = l.options.errorComponent ?? o.options.defaultErrorComponent,
      v = l.options.onCatch ?? o.options.defaultOnCatch,
      g = l.isRoot
        ? (l.options.notFoundComponent ??
          ((r = o.options.notFoundRoute) == null ? void 0 : r.options.component))
        : l.options.notFoundComponent,
      E =
        (!l.isRoot || l.options.wrapInSuspense) &&
        (l.options.wrapInSuspense ?? d ?? ((a = l.options.errorComponent) == null ? void 0 : a.preload))
          ? w.Suspense
          : Cv,
      x = p ? wS : Cv,
      C = g ? H9 : Cv,
      _ = Ri({ select: k => k.loadedAt })
    return dt.jsx(lg.Provider, {
      value: t,
      children: dt.jsx(E, {
        fallback: h,
        children: dt.jsx(x, {
          getResetKey: () => _,
          errorComponent: p || sg,
          onCatch: (k, R) => {
            if (Ia(k)) throw k
            Il(!1, `Error in route match: ${t}`), v == null || v(k, R)
          },
          children: dt.jsx(C, {
            fallback: k => {
              if (!g || (k.routeId && k.routeId !== u) || (!k.routeId && !l.isRoot)) throw k
              return w.createElement(g, k)
            },
            children: dt.jsx(dV, { matchId: t })
          })
        })
      })
    })
  }),
  dV = w.memo(function ({ matchId: t }) {
    var r, a, o
    const u = Ao(),
      {
        match: l,
        matchIndex: d,
        routeId: h
      } = Ri({
        select: E => {
          const x = E.matches.findIndex(k => k.id === t),
            C = E.matches[x]
          return {
            routeId: C.routeId,
            matchIndex: x,
            match: Kd(C, ['id', 'status', 'error', 'loadPromise'])
          }
        }
      }),
      p = u.routesById[h],
      v = w.useMemo(() => {
        const E = p.options.component ?? u.options.defaultComponent
        return E ? dt.jsx(E, {}) : dt.jsx(cA, {})
      }, [p.options.component, u.options.defaultComponent]),
      g = (p.options.errorComponent ?? u.options.defaultErrorComponent) || sg
    if (l.status === 'notFound') {
      let E
      return (
        qR(l.error)
          ? (E = (((r = u.options.errorSerializer) == null ? void 0 : r.deserialize) ?? GR)(
              l.error.data
            ))
          : (E = l.error),
        ui(Ia(E), 'Expected a notFound error'),
        lA(u, p, E)
      )
    }
    if (l.status === 'redirected') throw (ui(pl(l.error), 'Expected a redirect error'), l.loadPromise)
    if (l.status === 'error') {
      if (u.isServer) return dt.jsx(g, { error: l.error, info: { componentStack: '' } })
      throw qR(l.error)
        ? (((a = u.options.errorSerializer) == null ? void 0 : a.deserialize) ?? GR)(l.error.data)
        : l.error
    }
    if (l.status === 'pending') {
      const E = p.options.pendingMinMs ?? u.options.defaultPendingMinMs
      if (E && !((o = u.getMatch(l.id)) != null && o.minPendingPromise) && !u.isServer) {
        const x = Zu()
        Promise.resolve().then(() => {
          u.updateMatch(l.id, C => ({ ...C, minPendingPromise: x }))
        }),
          setTimeout(() => {
            x.resolve(), u.updateMatch(l.id, C => ({ ...C, minPendingPromise: void 0 }))
          }, E)
      }
      throw l.loadPromise
    }
    return dt.jsxs(dt.Fragment, {
      children: [v, u.AfterEachMatch ? dt.jsx(u.AfterEachMatch, { match: l, matchIndex: d }) : null]
    })
  }),
  cA = w.memo(function () {
    const t = Ao(),
      r = w.useContext(lg),
      a = Ri({
        select: p => {
          var v
          return (v = p.matches.find(g => g.id === r)) == null ? void 0 : v.routeId
        }
      }),
      o = t.routesById[a],
      { parentGlobalNotFound: u } = Ri({
        select: p => {
          const g = p.matches.find(E => E.id === r)
          return (
            ui(g, `Could not find parent match for matchId "${r}"`),
            { parentGlobalNotFound: g.globalNotFound }
          )
        }
      }),
      l = Ri({
        select: p => {
          var v
          const g = p.matches,
            E = g.findIndex(x => x.id === r)
          return (v = g[E + 1]) == null ? void 0 : v.id
        }
      })
    if (u) return lA(t, o, void 0)
    if (!l) return null
    const d = dt.jsx(uA, { matchId: l }),
      h = t.options.defaultPendingComponent ? dt.jsx(t.options.defaultPendingComponent, {}) : null
    return r === Ci ? dt.jsx(w.Suspense, { fallback: h, children: d }) : d
  })
function hV() {
  const e = Ao(),
    t = e.options.defaultPendingComponent ? dt.jsx(e.options.defaultPendingComponent, {}) : null,
    r = e.isServer || (typeof document < 'u' && window.__TSR__) ? Cv : w.Suspense,
    a = dt.jsxs(r, { fallback: t, children: [dt.jsx(fV, {}), dt.jsx(pV, {})] })
  return e.options.InnerWrap ? dt.jsx(e.options.InnerWrap, { children: a }) : a
}
function pV() {
  const e = Ri({
      select: r => {
        var a
        return (a = r.matches[0]) == null ? void 0 : a.id
      }
    }),
    t = Ri({ select: r => r.loadedAt })
  return dt.jsx(lg.Provider, {
    value: e,
    children: dt.jsx(wS, {
      getResetKey: () => t,
      errorComponent: sg,
      onCatch: r => {
        Il(
          !1,
          "The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!"
        ),
          Il(!1, r.message || r.toString())
      },
      children: e ? dt.jsx(uA, { matchId: e }) : null
    })
  })
}
function mV({ router: e, children: t, ...r }) {
  e.update({ ...e.options, ...r, context: { ...e.options.context, ...r.context } })
  const a = Qk(),
    o = dt.jsx(a.Provider, { value: e, children: t })
  return e.options.Wrap ? dt.jsx(e.options.Wrap, { children: o }) : o
}
function vV({ router: e, ...t }) {
  return dt.jsx(mV, { router: e, ...t, children: dt.jsx(hV, {}) })
}
const gV = typeof window < 'u' ? w.useLayoutEffect : w.useEffect,
  VE = 'window',
  KR = '___'
let jE = new WeakSet()
const yV = typeof window < 'u' && window.sessionStorage,
  fa = yV
    ? (() => {
        const e = 'tsr-scroll-restoration-v2'
        return {
          state: JSON.parse(window.sessionStorage.getItem(e) || 'null') || { cached: {}, next: {} },
          set: r => {
            ;(fa.state = El(r, fa.state)), window.sessionStorage.setItem(e, JSON.stringify(fa.state))
          }
        }
      })()
    : void 0,
  bV = e => e.state.key || e.href
function EV(e) {
  const t = Ao()
  gV(() => {
    const r = (e == null ? void 0 : e.getKey) || bV,
      { history: a } = window
    a.scrollRestoration = 'manual'
    const o = d => {
      if (jE.has(d.target)) return
      jE.add(d.target)
      let h = ''
      if (d.target === document || d.target === window) h = VE
      else {
        const p = d.target.getAttribute('data-scroll-restoration-id')
        p ? (h = `[data-scroll-restoration-id="${p}"]`) : (h = SV(d.target))
      }
      fa.state.next[h] ||
        fa.set(p => ({ ...p, next: { ...p.next, [h]: { scrollX: NaN, scrollY: NaN } } }))
    }
    typeof document < 'u' && document.addEventListener('scroll', o, !0)
    const u = t.subscribe('onBeforeLoad', d => {
        if (d.pathChanged) {
          const h = r(d.fromLocation)
          for (const p in fa.state.next) {
            const v = fa.state.next[p]
            if (p === VE) (v.scrollX = window.scrollX || 0), (v.scrollY = window.scrollY || 0)
            else if (p) {
              const g = document.querySelector(p)
              ;(v.scrollX = (g == null ? void 0 : g.scrollLeft) || 0),
                (v.scrollY = (g == null ? void 0 : g.scrollTop) || 0)
            }
            fa.set(g => {
              const E = { ...g.next }
              return delete E[p], { ...g, next: E, cached: { ...g.cached, [[h, p].join(KR)]: v } }
            })
          }
        }
      }),
      l = t.subscribe('onResolved', d => {
        if (d.pathChanged) {
          if (!t.resetNextScroll) return
          t.resetNextScroll = !0
          const h = r(d.toLocation)
          let p = !1
          for (const v in fa.state.cached) {
            const g = fa.state.cached[v],
              [E, x] = v.split(KR)
            if (E === h) {
              if (x === VE) (p = !0), window.scrollTo(g.scrollX, g.scrollY)
              else if (x) {
                const C = document.querySelector(x)
                C && ((C.scrollLeft = g.scrollX), (C.scrollTop = g.scrollY))
              }
            }
          }
          p || window.scrollTo(0, 0), fa.set(v => ({ ...v, next: {} })), (jE = new WeakSet())
        }
      })
    return () => {
      document.removeEventListener('scroll', o), u(), l()
    }
  }, [e == null ? void 0 : e.getKey, t])
}
function xV(e) {
  return EV(e), null
}
function SV(e) {
  const t = []
  let r
  for (; (r = e.parentNode); )
    t.unshift(`${e.tagName}:nth-child(${[].indexOf.call(r.children, e) + 1})`), (e = r)
  return `${t.join(' > ')}`.toLowerCase()
}
const TV = 'modulepreload',
  CV = function (e) {
    return '/' + e
  },
  ZR = {},
  wV = function (t, r, a) {
    let o = Promise.resolve()
    if (r && r.length > 0) {
      document.getElementsByTagName('link')
      const u = document.querySelector('meta[property=csp-nonce]'),
        l = (u == null ? void 0 : u.nonce) || (u == null ? void 0 : u.getAttribute('nonce'))
      o = Promise.all(
        r.map(d => {
          if (((d = CV(d)), d in ZR)) return
          ZR[d] = !0
          const h = d.endsWith('.css'),
            p = h ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${d}"]${p}`)) return
          const v = document.createElement('link')
          if (
            ((v.rel = h ? 'stylesheet' : TV),
            h || (v.as = 'script'),
            (v.crossOrigin = ''),
            (v.href = d),
            l && v.setAttribute('nonce', l),
            document.head.appendChild(v),
            h)
          )
            return new Promise((g, E) => {
              v.addEventListener('load', g),
                v.addEventListener('error', () => E(new Error(`Unable to preload CSS for ${d}`)))
            })
        })
      )
    }
    return o
      .then(() => t())
      .catch(u => {
        const l = new Event('vite:preloadError', { cancelable: !0 })
        if (((l.payload = u), window.dispatchEvent(l), !l.defaultPrevented)) throw u
      })
  },
  pa = { BASE_URL: '/', DEV: !0, MODE: 'production', PROD: !1, SSR: !1 }
let RV = 0
function XR(e, t) {
  const r = `atom${++RV}`,
    a = {
      toString() {
        return (pa ? 'production' : void 0) !== 'production' && this.debugLabel
          ? r + ':' + this.debugLabel
          : r
      }
    }
  return (
    typeof e == 'function' ? (a.read = e) : ((a.init = e), (a.read = _V), (a.write = OV)),
    t && (a.write = t),
    a
  )
}
function _V(e) {
  return e(this)
}
function OV(e, t, r) {
  return t(this, typeof r == 'function' ? r(e(this)) : r)
}
const QR = (e, t) => (e.unstable_is ? e.unstable_is(t) : t === e),
  UE = e => 'init' in e,
  $E = e => !!e.write,
  Zd = Symbol((pa ? 'production' : void 0) !== 'production' ? 'CONTINUE_PROMISE' : ''),
  RS = 'pending',
  kV = 'fulfilled',
  AV = 'rejected',
  DV = e => typeof e == 'object' && e !== null && Zd in e,
  dv = new WeakMap(),
  NV = (e, t, r) => {
    if (!dv.has(e)) {
      let a
      const o = new Promise((u, l) => {
        let d = e
        const h = v => g => {
            d === v && ((o.status = kV), (o.value = g), u(g), r())
          },
          p = v => g => {
            d === v && ((o.status = AV), (o.reason = g), l(g), r())
          }
        e.then(h(e), p(e)),
          (a = (v, g) => {
            v && (dv.set(v, o), (d = v), v.then(h(v), p(v)), t(), (t = g))
          })
      })
      ;(o.status = RS), (o[Zd] = a), dv.set(e, o)
    }
    return dv.get(e)
  },
  MV = e => typeof (e == null ? void 0 : e.then) == 'function',
  JR = e => 'v' in e || 'e' in e,
  hv = e => {
    if ('e' in e) throw e.e
    if ((pa ? 'production' : void 0) !== 'production' && !('v' in e))
      throw new Error('[Bug] atom state is not initialized')
    return e.v
  },
  wv = e => {
    const t = e.v
    return DV(t) && t.status === RS ? t : null
  },
  fA = (e, t, r) => {
    r.p.has(e) ||
      (r.p.add(e),
      t.then(
        () => {
          r.p.delete(e)
        },
        () => {
          r.p.delete(e)
        }
      ))
  },
  e_ = (e, t, r, a, o) => {
    var u
    if ((pa ? 'production' : void 0) !== 'production' && a === t)
      throw new Error('[Bug] atom cannot depend on itself')
    r.d.set(a, o.n)
    const l = wv(r)
    l && fA(t, l, o), (u = o.m) == null || u.t.add(t), e && LV(e, a, t)
  },
  Wu = () => [new Map(), new Map(), new Set()],
  BE = (e, t, r) => {
    e[0].has(t) || e[0].set(t, new Set()), e[1].set(t, r)
  },
  LV = (e, t, r) => {
    const a = e[0].get(t)
    a && a.add(r)
  },
  PV = (e, t) => e[0].get(t),
  t_ = (e, t) => {
    e[2].add(t)
  },
  dl = e => {
    for (; e[1].size || e[2].size; ) {
      e[0].clear()
      const t = new Set(e[1].values())
      e[1].clear()
      const r = new Set(e[2])
      e[2].clear(),
        t.forEach(a => {
          var o
          return (o = a.m) == null ? void 0 : o.l.forEach(u => u())
        }),
        r.forEach(a => a())
    }
  },
  dA = e => {
    let t
    ;(pa ? 'production' : void 0) !== 'production' && (t = new Set())
    const r = (_, k, R, D = () => {}, A = () => {}) => {
        const L = 'v' in k,
          F = k.v,
          z = wv(k)
        if (MV(R))
          if (z) z !== R && (z[Zd](R, D), ++k.n)
          else {
            const H = NV(R, D, A)
            if (H.status === RS) for (const $ of k.d.keys()) fA(_, H, e($, k))
            ;(k.v = H), delete k.e
          }
        else z && z[Zd](Promise.resolve(R), D), (k.v = R), delete k.e
        ;(!L || !Object.is(F, k.v)) && ++k.n
      },
      a = (_, k, R, D) => {
        if (
          !(D != null && D(k)) &&
          JR(R) &&
          (R.m || Array.from(R.d).every(([$, Q]) => a(_, $, e($, R), D).n === Q))
        )
          return R
        R.d.clear()
        let A = !0
        const L = $ => {
          if (QR(k, $)) {
            const ue = e($, R)
            if (!JR(ue))
              if (UE($)) r($, ue, $.init)
              else throw new Error('no atom init')
            return hv(ue)
          }
          const Q = a(_, $, e($, R), D)
          if (A) e_(_, k, R, $, Q)
          else {
            const ue = Wu()
            e_(ue, k, R, $, Q), p(ue, k, R), dl(ue)
          }
          return hv(Q)
        }
        let F, z
        const H = {
          get signal() {
            return F || (F = new AbortController()), F.signal
          },
          get setSelf() {
            return (
              (pa ? 'production' : void 0) !== 'production' &&
                !$E(k) &&
                console.warn('setSelf function cannot be used with read-only atom'),
              !z &&
                $E(k) &&
                (z = (...$) => {
                  if (
                    ((pa ? 'production' : void 0) !== 'production' &&
                      A &&
                      console.warn('setSelf function cannot be called in sync'),
                    !A)
                  )
                    return h(k, ...$)
                }),
              z
            )
          }
        }
        try {
          const $ = k.read(L, H)
          return (
            r(
              k,
              R,
              $,
              () => (F == null ? void 0 : F.abort()),
              () => {
                if (R.m) {
                  const Q = Wu()
                  p(Q, k, R), dl(Q)
                }
              }
            ),
            R
          )
        } catch ($) {
          return delete R.v, (R.e = $), ++R.n, R
        } finally {
          A = !1
        }
      },
      o = _ => hv(a(void 0, _, e(_))),
      u = (_, k, R) => {
        var D, A
        const L = new Map()
        for (const F of ((D = R.m) == null ? void 0 : D.t) || []) L.set(F, e(F, R))
        for (const F of R.p) L.set(F, e(F, R))
        return (
          (A = PV(_, k)) == null ||
            A.forEach(F => {
              L.set(F, e(F, R))
            }),
          L
        )
      },
      l = (_, k, R) => {
        const D = [],
          A = new Set(),
          L = (H, $) => {
            if (!A.has(H)) {
              A.add(H)
              for (const [Q, ue] of u(_, H, $)) H !== Q && L(Q, ue)
              D.push([H, $, $.n])
            }
          }
        L(k, R)
        const F = new Set([k]),
          z = H => A.has(H)
        for (let H = D.length - 1; H >= 0; --H) {
          const [$, Q, ue] = D[H]
          let se = !1
          for (const we of Q.d.keys())
            if (we !== $ && F.has(we)) {
              se = !0
              break
            }
          se && (a(_, $, Q, z), p(_, $, Q), ue !== Q.n && (BE(_, $, Q), F.add($))), A.delete($)
        }
      },
      d = (_, k, R, ...D) => {
        const A = z => hv(a(_, z, e(z, R))),
          L = (z, ...H) => {
            const $ = e(z, R)
            let Q
            if (QR(k, z)) {
              if (!UE(z)) throw new Error('atom not writable')
              const ue = 'v' in $,
                se = $.v,
                we = H[0]
              r(z, $, we), p(_, z, $), (!ue || !Object.is(se, $.v)) && (BE(_, z, $), l(_, z, $))
            } else Q = d(_, z, $, ...H)
            return dl(_), Q
          }
        return k.write(A, L, ...D)
      },
      h = (_, ...k) => {
        const R = Wu(),
          D = d(R, _, e(_), ...k)
        return dl(R), D
      },
      p = (_, k, R) => {
        if (R.m && !wv(R)) {
          for (const D of R.d.keys()) R.m.d.has(D) || (v(_, D, e(D, R)).t.add(k), R.m.d.add(D))
          for (const D of R.m.d || [])
            if (!R.d.has(D)) {
              R.m.d.delete(D)
              const A = g(_, D, e(D, R))
              A == null || A.t.delete(k)
            }
        }
      },
      v = (_, k, R) => {
        if (!R.m) {
          a(_, k, R)
          for (const D of R.d.keys()) v(_, D, e(D, R)).t.add(k)
          if (
            ((R.m = { l: new Set(), d: new Set(R.d.keys()), t: new Set() }),
            (pa ? 'production' : void 0) !== 'production' && t.add(k),
            $E(k) && k.onMount)
          ) {
            const D = R.m,
              { onMount: A } = k
            t_(_, () => {
              const L = A((...F) => d(_, k, R, ...F))
              L && (D.u = L)
            })
          }
        }
        return R.m
      },
      g = (_, k, R) => {
        if (
          R.m &&
          !R.m.l.size &&
          !Array.from(R.m.t).some(D => {
            var A
            return (A = e(D, R).m) == null ? void 0 : A.d.has(k)
          })
        ) {
          const D = R.m.u
          D && t_(_, D), delete R.m, (pa ? 'production' : void 0) !== 'production' && t.delete(k)
          for (const L of R.d.keys()) {
            const F = g(_, L, e(L, R))
            F == null || F.t.delete(k)
          }
          const A = wv(R)
          A && A[Zd](void 0, () => {})
          return
        }
        return R.m
      },
      C = {
        get: o,
        set: h,
        sub: (_, k) => {
          const R = Wu(),
            D = e(_),
            A = v(R, _, D)
          dl(R)
          const L = A.l
          return (
            L.add(k),
            () => {
              L.delete(k)
              const F = Wu()
              g(F, _, D), dl(F)
            }
          )
        },
        unstable_derive: _ => dA(..._(e))
      }
    return (
      (pa ? 'production' : void 0) !== 'production' &&
        Object.assign(C, {
          dev4_get_internal_weak_map: () => ({
            get: k => {
              const R = e(k)
              if (R.n !== 0) return R
            }
          }),
          dev4_get_mounted_atoms: () => t,
          dev4_restore_atoms: k => {
            const R = Wu()
            for (const [D, A] of k)
              if (UE(D)) {
                const L = e(D),
                  F = 'v' in L,
                  z = L.v
                r(D, L, A), p(R, D, L), (!F || !Object.is(z, L.v)) && (BE(R, D, L), l(R, D, L))
              }
            dl(R)
          }
        }),
      C
    )
  },
  IV = () => {
    const e = new WeakMap()
    return dA(r => {
      let a = e.get(r)
      return a || ((a = { d: new Map(), p: new Set(), n: 0 }), e.set(r, a)), a
    })
  }
let Nd
const FV = () => (
    Nd ||
      ((Nd = IV()),
      (pa ? 'production' : void 0) !== 'production' &&
        (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = Nd),
        globalThis.__JOTAI_DEFAULT_STORE__ !== Nd &&
          console.warn(
            'Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044'
          ))),
    Nd
  ),
  VV = { BASE_URL: '/', DEV: !0, MODE: 'production', PROD: !1, SSR: !1 },
  jV = w.createContext(void 0),
  hA = e => w.useContext(jV) || FV(),
  UV = e => typeof (e == null ? void 0 : e.then) == 'function',
  $V =
    Gt.use ||
    (e => {
      if (e.status === 'pending') throw e
      if (e.status === 'fulfilled') return e.value
      throw e.status === 'rejected'
        ? e.reason
        : ((e.status = 'pending'),
          e.then(
            t => {
              ;(e.status = 'fulfilled'), (e.value = t)
            },
            t => {
              ;(e.status = 'rejected'), (e.reason = t)
            }
          ),
          e)
    })
function pA(e, t) {
  const r = hA(),
    [[a, o, u], l] = w.useReducer(
      p => {
        const v = r.get(e)
        return Object.is(p[0], v) && p[1] === r && p[2] === e ? p : [v, r, e]
      },
      void 0,
      () => [r.get(e), r, e]
    )
  let d = a
  return (
    (o !== r || u !== e) && (l(), (d = r.get(e))),
    w.useEffect(() => {
      const p = r.sub(e, () => {
        l()
      })
      return l(), p
    }, [r, e, void 0]),
    w.useDebugValue(d),
    UV(d) ? $V(d) : d
  )
}
function BV(e, t) {
  const r = hA()
  return w.useCallback(
    (...o) => {
      if ((VV ? 'production' : void 0) !== 'production' && !('write' in e))
        throw new Error('not writable atom')
      return r.set(e, ...o)
    },
    [r, e]
  )
}
function zV(e, t) {
  return [pA(e), BV(e)]
}
function HV() {
  return le.jsxDEV(
    'footer',
    {
      className: '  text-center p-4 dark:text-slate-600 text-slate-500',
      children: 'Made with  by Arif'
    },
    void 0,
    !1,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/footer/footer.tsx',
      lineNumber: 3,
      columnNumber: 5
    },
    this
  )
}
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const WV = e => e.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase(),
  mA = (...e) => e.filter((t, r, a) => !!t && a.indexOf(t) === r).join(' ')
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var YV = {
  xmlns: 'http://www.w3.org/2000/svg',
  width: 24,
  height: 24,
  viewBox: '0 0 24 24',
  fill: 'none',
  stroke: 'currentColor',
  strokeWidth: 2,
  strokeLinecap: 'round',
  strokeLinejoin: 'round'
}
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const qV = w.forwardRef(
  (
    {
      color: e = 'currentColor',
      size: t = 24,
      strokeWidth: r = 2,
      absoluteStrokeWidth: a,
      className: o = '',
      children: u,
      iconNode: l,
      ...d
    },
    h
  ) =>
    w.createElement(
      'svg',
      {
        ref: h,
        ...YV,
        width: t,
        height: t,
        stroke: e,
        strokeWidth: a ? (Number(r) * 24) / Number(t) : r,
        className: mA('lucide', o),
        ...d
      },
      [...l.map(([p, v]) => w.createElement(p, v)), ...(Array.isArray(u) ? u : [u])]
    )
)
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Di = (e, t) => {
  const r = w.forwardRef(({ className: a, ...o }, u) =>
    w.createElement(qV, { ref: u, iconNode: t, className: mA(`lucide-${WV(e)}`, a), ...o })
  )
  return (r.displayName = `${e}`), r
}
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Fx = Di('ArrowDownWideNarrow', [
  ['path', { d: 'm3 16 4 4 4-4', key: '1co6wj' }],
  ['path', { d: 'M7 20V4', key: '1yoxec' }],
  ['path', { d: 'M11 4h10', key: '1w87gc' }],
  ['path', { d: 'M11 8h7', key: 'djye34' }],
  ['path', { d: 'M11 12h4', key: 'q8tih4' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const n_ = Di('ArrowUpNarrowWide', [
  ['path', { d: 'm3 8 4-4 4 4', key: '11wl7u' }],
  ['path', { d: 'M7 4v16', key: '1glfcx' }],
  ['path', { d: 'M11 12h4', key: 'q8tih4' }],
  ['path', { d: 'M11 16h7', key: 'uosisv' }],
  ['path', { d: 'M11 20h10', key: 'jvxblo' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const GV = Di('ArrowUpRight', [
  ['path', { d: 'M7 7h10v10', key: '1tivn9' }],
  ['path', { d: 'M7 17 17 7', key: '1vkiza' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const KV = Di('ArrowUp', [
  ['path', { d: 'm5 12 7-7 7 7', key: 'hav0vg' }],
  ['path', { d: 'M12 19V5', key: 'x0mq9r' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const vA = Di('Check', [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZV = Di('ChevronDown', [['path', { d: 'm6 9 6 6 6-6', key: 'qrunsl' }]])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const XV = Di('ChevronLeft', [['path', { d: 'm15 18-6-6 6-6', key: '1wnfg3' }]])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const QV = Di('ChevronRight', [['path', { d: 'm9 18 6-6-6-6', key: 'mthhwq' }]])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JV = Di('Ellipsis', [
  ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],
  ['circle', { cx: '19', cy: '12', r: '1', key: '1wjl8i' }],
  ['circle', { cx: '5', cy: '12', r: '1', key: '1pcz8c' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const e8 = Di('Loader', [
  ['path', { d: 'M12 2v4', key: '3427ic' }],
  ['path', { d: 'm16.2 7.8 2.9-2.9', key: 'r700ao' }],
  ['path', { d: 'M18 12h4', key: 'wj9ykh' }],
  ['path', { d: 'm16.2 16.2 2.9 2.9', key: '1bxg5t' }],
  ['path', { d: 'M12 18v4', key: 'jadmvz' }],
  ['path', { d: 'm4.9 19.1 2.9-2.9', key: 'bwix9q' }],
  ['path', { d: 'M2 12h4', key: 'j09sii' }],
  ['path', { d: 'm4.9 4.9 2.9 2.9', key: 'giyufr' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const t8 = Di('MoonStar', [
  ['path', { d: 'M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9', key: '4ay0iu' }],
  ['path', { d: 'M20 3v4', key: '1olli1' }],
  ['path', { d: 'M22 5h-4', key: '1gvqau' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const n8 = Di('Search', [
  ['circle', { cx: '11', cy: '11', r: '8', key: '4ej97u' }],
  ['path', { d: 'm21 21-4.3-4.3', key: '1qie3q' }]
])
/**
 * @license lucide-react v0.436.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const r8 = Di('Sun', [
    ['circle', { cx: '12', cy: '12', r: '4', key: '4exip2' }],
    ['path', { d: 'M12 2v2', key: 'tus03m' }],
    ['path', { d: 'M12 20v2', key: '1lh1kg' }],
    ['path', { d: 'm4.93 4.93 1.41 1.41', key: '149t6j' }],
    ['path', { d: 'm17.66 17.66 1.41 1.41', key: 'ptbguv' }],
    ['path', { d: 'M2 12h2', key: '1t8f8n' }],
    ['path', { d: 'M20 12h2', key: '1q8mjw' }],
    ['path', { d: 'm6.34 17.66-1.41 1.41', key: '1m8zz5' }],
    ['path', { d: 'm19.07 4.93-1.41 1.41', key: '1shlcs' }]
  ]),
  i8 = '/assets/pokemon-logo-BueKHVBs.png'
var gA = { exports: {} }
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ ;(function (e) {
  ;(function () {
    var t = {}.hasOwnProperty
    function r() {
      for (var u = '', l = 0; l < arguments.length; l++) {
        var d = arguments[l]
        d && (u = o(u, a(d)))
      }
      return u
    }
    function a(u) {
      if (typeof u == 'string' || typeof u == 'number') return u
      if (typeof u != 'object') return ''
      if (Array.isArray(u)) return r.apply(null, u)
      if (u.toString !== Object.prototype.toString && !u.toString.toString().includes('[native code]'))
        return u.toString()
      var l = ''
      for (var d in u) t.call(u, d) && u[d] && (l = o(l, d))
      return l
    }
    function o(u, l) {
      return l ? (u ? u + ' ' + l : u + l) : u
    }
    e.exports ? ((r.default = r), (e.exports = r)) : (window.classNames = r)
  })()
})(gA)
var a8 = gA.exports
const Fl = kk(a8),
  Md = {
    focusVisible: 'outline-none focus:ring-2 ring-yellow-500',
    base: 'px-4 py-2 flex items-center h-11 min-w-11 justify-center',
    icon: 'size-11 flex justify-center items-center rounded-full',
    rounded: 'rounded-full',
    disabled: 'disabled:opacity-50 bg-slate-50',
    variants: {
      default:
        'bg-slate-50 hover:bg-slate-100 text-slate-900 border-slate-200 dark:bg-slate-900 dark:hover:bg-slate-800 dark:text-slate-100 border dark:border-slate-800 transition',
      primary: 'bg-yellow-500 text-black hover:bg-yellow-600 border-yellow-700'
    }
  },
  oc = w.forwardRef(
    (
      { className: e, icon: t = !1, variant: r = 'default', rounded: a = !1, type: o = 'button', ...u },
      l
    ) => {
      const d = t ? Md.icon : Md.base,
        h = Md.variants[r],
        p = a ? Md.rounded : ''
      return le.jsxDEV(
        'button',
        { type: o, className: Fl(d, Md.focusVisible, h, p, e), ref: l, ...u },
        void 0,
        !1,
        {
          fileName: '/Volumes/workspace/pokemon-frontend/src/components/ui/button/button.tsx',
          lineNumber: 34,
          columnNumber: 7
        },
        void 0
      )
    }
  )
oc.displayName = 'Button'
const _S = { BASE_URL: '/', DEV: !0, MODE: 'production', PROD: !1, SSR: !1 },
  o8 = Symbol((_S ? 'production' : void 0) !== 'production' ? 'RESET' : ''),
  s8 = e => typeof (e == null ? void 0 : e.then) == 'function'
function l8(
  e = () => {
    try {
      return window.localStorage
    } catch (r) {
      ;(_S ? 'production' : void 0) !== 'production' && typeof window < 'u' && console.warn(r)
      return
    }
  },
  t
) {
  var r
  let a, o
  const u = {
      getItem: (h, p) => {
        var v, g
        const E = C => {
            if (((C = C || ''), a !== C)) {
              try {
                o = JSON.parse(C, t == null ? void 0 : t.reviver)
              } catch {
                return p
              }
              a = C
            }
            return o
          },
          x = (g = (v = e()) == null ? void 0 : v.getItem(h)) != null ? g : null
        return s8(x) ? x.then(E) : E(x)
      },
      setItem: (h, p) => {
        var v
        return (v = e()) == null ? void 0 : v.setItem(h, JSON.stringify(p, void 0))
      },
      removeItem: h => {
        var p
        return (p = e()) == null ? void 0 : p.removeItem(h)
      }
    },
    l = h => (p, v, g) =>
      h(p, E => {
        let x
        try {
          x = JSON.parse(E || '')
        } catch {
          x = g
        }
        v(x)
      })
  let d
  try {
    d = (r = e()) == null ? void 0 : r.subscribe
  } catch {}
  return (
    !d &&
      typeof window < 'u' &&
      typeof window.addEventListener == 'function' &&
      window.Storage &&
      (d = (h, p) => {
        if (!(e() instanceof window.Storage)) return () => {}
        const v = g => {
          g.storageArea === e() && g.key === h && p(g.newValue)
        }
        return (
          window.addEventListener('storage', v),
          () => {
            window.removeEventListener('storage', v)
          }
        )
      }),
    d && (u.subscribe = l(d)),
    u
  )
}
const u8 = l8()
function c8(e, t, r = u8, a) {
  const o = XR(t)
  return (
    (_S ? 'production' : void 0) !== 'production' && (o.debugPrivate = !0),
    (o.onMount = l => {
      l(r.getItem(e, t))
      let d
      return r.subscribe && (d = r.subscribe(e, l, t)), d
    }),
    XR(
      l => l(o),
      (l, d, h) => {
        const p = typeof h == 'function' ? h(l(o)) : h
        return p === o8
          ? (d(o, t), r.removeItem(e))
          : p instanceof Promise
            ? p.then(v => (d(o, v), r.setItem(e, v)))
            : (d(o, p), r.setItem(e, p))
      }
    )
  )
}
const yA = c8('theme', 'dark')
function f8() {
  const [e, t] = zV(yA),
    r = e === 'dark',
    a = () => {
      t(r ? 'light' : 'dark')
    }
  return le.jsxDEV(
    'nav',
    {
      className:
        'container mx-auto sm:w-11/12 md:w-11/12 mt-3 inset-0 flex justify-between items-center border  border-slate-200 dark:border-slate-800 px-10 h-28 sm:h-16 md:h-16 rounded-3xl backdrop-blur-xl fixed z-50',
      children: [
        le.jsxDEV(
          'div',
          { className: 'w-1/3' },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
            lineNumber: 18,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          'div',
          {
            className: 'w-1/3 flex justify-center',
            children: le.jsxDEV(
              'img',
              { src: i8, alt: 'Pokemon logo', className: 'w-60 md:w-40', width: 240, height: 89 },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
                lineNumber: 21,
                columnNumber: 9
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
            lineNumber: 20,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          'div',
          {
            className: 'w-1/3 flex justify-end space-x-4',
            children: le.jsxDEV(
              oc,
              {
                className: 'bg-transparent dark:bg-transparent',
                icon: !0,
                onClick: a,
                rounded: !0,
                title: 'Toggle dark theme',
                children: r
                  ? le.jsxDEV(
                      t8,
                      { size: 18 },
                      void 0,
                      !1,
                      {
                        fileName:
                          '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
                        lineNumber: 32,
                        columnNumber: 21
                      },
                      this
                    )
                  : le.jsxDEV(
                      r8,
                      { size: 18 },
                      void 0,
                      !1,
                      {
                        fileName:
                          '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
                        lineNumber: 32,
                        columnNumber: 46
                      },
                      this
                    )
              },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
                lineNumber: 25,
                columnNumber: 9
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
            lineNumber: 24,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/nav-bar/nav-bar.tsx',
      lineNumber: 17,
      columnNumber: 5
    },
    this
  )
}
function d8(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
  e && e.addEventListener && e.addEventListener.apply(e, t)
}
function h8(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r]
  e && e.removeEventListener && e.removeEventListener.apply(e, t)
}
var p8 = typeof window < 'u'
function m8(e, t) {
  var r = w.useRef(!1),
    a = w.useRef(),
    o = w.useRef(e),
    u = w.useCallback(function () {
      return r.current
    }, []),
    l = w.useCallback(
      function () {
        ;(r.current = !1),
          a.current && clearTimeout(a.current),
          (a.current = setTimeout(function () {
            ;(r.current = !0), o.current()
          }, t))
      },
      [t]
    ),
    d = w.useCallback(function () {
      ;(r.current = null), a.current && clearTimeout(a.current)
    }, [])
  return (
    w.useEffect(
      function () {
        o.current = e
      },
      [e]
    ),
    w.useEffect(
      function () {
        return l(), d
      },
      [t]
    ),
    [u, d, l]
  )
}
function v8(e, t, r) {
  r === void 0 && (r = [])
  var a = m8(e, t),
    o = a[0],
    u = a[1],
    l = a[2]
  return w.useEffect(l, r), [o, u]
}
var g8 = p8 ? window : null,
  r_ = function (e) {
    return !!e.addEventListener
  },
  i_ = function (e) {
    return !!e.on
  },
  y8 = function (e, t, r, a) {
    r === void 0 && (r = g8),
      w.useEffect(
        function () {
          if (t && r)
            return (
              r_(r) ? d8(r, e, t, a) : i_(r) && r.on(e, t, a),
              function () {
                r_(r) ? h8(r, e, t, a) : i_(r) && r.off(e, t, a)
              }
            )
        },
        [e, t, r, JSON.stringify(a)]
      )
  }
function b8() {
  const [e, t] = w.useState(!1),
    r = () => {
      window.scrollY > 1100 ? t(!0) : t(!1)
    },
    a = () => {
      window.scrollTo({ top: 0, behavior: 'smooth' })
    }
  return (
    y8('scroll', r),
    le.jsxDEV(
      'div',
      {
        className: 'scroll-to-top',
        children:
          e &&
          le.jsxDEV(
            oc,
            {
              title: 'Scroll page to top',
              icon: !0,
              onClick: a,
              className: 'fixed right-3 bottom-3',
              children: le.jsxDEV(
                KV,
                {},
                void 0,
                !1,
                {
                  fileName:
                    '/Volumes/workspace/pokemon-frontend/src/components/scroll-to-top-button/scroll-to-top-button.tsx',
                  lineNumber: 32,
                  columnNumber: 11
                },
                this
              )
            },
            void 0,
            !1,
            {
              fileName:
                '/Volumes/workspace/pokemon-frontend/src/components/scroll-to-top-button/scroll-to-top-button.tsx',
              lineNumber: 31,
              columnNumber: 9
            },
            this
          )
      },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/scroll-to-top-button/scroll-to-top-button.tsx',
        lineNumber: 29,
        columnNumber: 5
      },
      this
    )
  )
}
const OS = nV({
  component: E8,
  notFoundComponent: () =>
    le.jsxDEV(
      'div',
      { children: 'Not Found' },
      void 0,
      !1,
      {
        fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
        lineNumber: 13,
        columnNumber: 28
      },
      void 0
    )
})
function E8() {
  const r = pA(yA) === 'dark' ? 'dark' : ''
  return le.jsxDEV(
    'div',
    {
      className: `flex flex-col items-center min-h-screen bg-image ${r} bg-slate-200 dark:bg-slate-950 transition-all`,
      children: [
        le.jsxDEV(
          xV,
          { getKey: a => a.pathname },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
            lineNumber: 25,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          f8,
          {},
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
            lineNumber: 26,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          'main',
          {
            className: 'flex-grow w-5/6',
            children: le.jsxDEV(
              cA,
              {},
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
                lineNumber: 29,
                columnNumber: 9
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
            lineNumber: 28,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          b8,
          {},
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
            lineNumber: 32,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          HV,
          {},
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
            lineNumber: 33,
            columnNumber: 7
          },
          this
        ),
        !1
      ]
    },
    void 0,
    !0,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/routes/__root.tsx',
      lineNumber: 22,
      columnNumber: 5
    },
    this
  )
}
const bA = [20, 50, 100]
function x8({ itemsPerPage: e, onItemsPerPageChange: t }) {
  const r = a => {
    t(Number(a.target.value))
  }
  return le.jsxDEV(
    'label',
    {
      className: 'flex items-center gap-3 text-slate-500',
      children: [
        le.jsxDEV(
          'span',
          { children: 'Showing' },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/items-per-page/items-per-page.tsx',
            lineNumber: 15,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          'select',
          {
            value: e,
            onChange: r,
            name: 'items-per-page',
            className:
              'p-2 rounded-full cursor-pointer border border-slate-200 bg-slate-50 text-slate-800 focus:outline-none focus-visible:ring-2 ring-yellow-500  dark:bg-slate-900 dark:text-slate-100 dark:border-slate-800',
            children: bA.map(a =>
              le.jsxDEV(
                'option',
                { value: a, children: a },
                a,
                !1,
                {
                  fileName:
                    '/Volumes/workspace/pokemon-frontend/src/components/items-per-page/items-per-page.tsx',
                  lineNumber: 23,
                  columnNumber: 11
                },
                this
              )
            )
          },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/items-per-page/items-per-page.tsx',
            lineNumber: 16,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          'span',
          { children: 'items per page' },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/items-per-page/items-per-page.tsx',
            lineNumber: 28,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/items-per-page/items-per-page.tsx',
      lineNumber: 14,
      columnNumber: 5
    },
    this
  )
}
const pv = (e, t) => Array.from({ length: t - e + 1 }, (r, a) => e + a)
function S8({ totalItems: e, itemsPerPage: t, offset: r, onOffsetChange: a }) {
  const o = Math.ceil(e / t),
    u = Math.floor(r / t) + 1,
    l = w.useMemo(() => {
      if (o <= 5) return pv(1, o)
      const h = u <= 3,
        p = u >= o - 2
      return h
        ? [...pv(1, 3), '...', o]
        : p
          ? [1, '...', ...pv(o - 2, o)]
          : [1, '...', ...pv(u - 1, u + 1), '...', o]
    }, [u, o]),
    d = h => {
      if (typeof h != 'number') return
      const p = (h - 1) * t
      a(p)
    }
  return le.jsxDEV(
    'div',
    {
      className: 'flex items-center justify-center space-x-2 sm:flex-wrap sm:gap-y-3',
      children: [
        le.jsxDEV(
          oc,
          {
            rounded: !0,
            onClick: () => a(Math.max(0, r - t)),
            disabled: r === 0,
            'aria-label': 'Previous page',
            children: [
              le.jsxDEV(
                XV,
                { size: 20 },
                void 0,
                !1,
                {
                  fileName:
                    '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
                  lineNumber: 53,
                  columnNumber: 9
                },
                this
              ),
              ' Prev'
            ]
          },
          void 0,
          !0,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
            lineNumber: 47,
            columnNumber: 7
          },
          this
        ),
        l.map((h, p) =>
          le.jsxDEV(
            w.Fragment,
            {
              children:
                h === '...'
                  ? le.jsxDEV(
                      'span',
                      {
                        title: 'More pages',
                        className: 'px-2 dark:text-slate-100',
                        children: le.jsxDEV(
                          JV,
                          {},
                          void 0,
                          !1,
                          {
                            fileName:
                              '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
                            lineNumber: 60,
                            columnNumber: 15
                          },
                          this
                        )
                      },
                      void 0,
                      !1,
                      {
                        fileName:
                          '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
                        lineNumber: 59,
                        columnNumber: 13
                      },
                      this
                    )
                  : le.jsxDEV(
                      oc,
                      {
                        onClick: () => d(h),
                        rounded: !0,
                        className: h === u ? 'font-semibold' : '',
                        variant: u === h ? 'primary' : 'default',
                        children: h
                      },
                      void 0,
                      !1,
                      {
                        fileName:
                          '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
                        lineNumber: 63,
                        columnNumber: 13
                      },
                      this
                    )
            },
            p,
            !1,
            {
              fileName: '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
              lineNumber: 57,
              columnNumber: 9
            },
            this
          )
        ),
        le.jsxDEV(
          oc,
          {
            rounded: !0,
            onClick: () => a(Math.min((o - 1) * t, r + t)),
            disabled: r + t >= e,
            'aria-label': 'Next page',
            children: [
              'Next ',
              le.jsxDEV(
                QV,
                { size: 20 },
                void 0,
                !1,
                {
                  fileName:
                    '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
                  lineNumber: 81,
                  columnNumber: 14
                },
                this
              )
            ]
          },
          void 0,
          !0,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
            lineNumber: 75,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/pagination/pagination.tsx',
      lineNumber: 46,
      columnNumber: 5
    },
    this
  )
}
const a_ = new Set()
function ug(e, t, r) {
  e || a_.has(t) || (console.warn(t), a_.add(t))
}
function T8(e) {
  if (typeof Proxy > 'u') return e
  const t = new Map(),
    r = (...a) => (ug(!1, 'motion() is deprecated. Use motion.create() instead.'), e(...a))
  return new Proxy(r, { get: (a, o) => (o === 'create' ? e : (t.has(o) || t.set(o, e(o)), t.get(o))) })
}
function oh(e) {
  return e !== null && typeof e == 'object' && typeof e.start == 'function'
}
const Vx = e => Array.isArray(e)
function EA(e, t) {
  if (!Array.isArray(t)) return !1
  const r = t.length
  if (r !== e.length) return !1
  for (let a = 0; a < r; a++) if (t[a] !== e[a]) return !1
  return !0
}
function sh(e) {
  return typeof e == 'string' || Array.isArray(e)
}
function o_(e) {
  const t = [{}, {}]
  return (
    e == null ||
      e.values.forEach((r, a) => {
        ;(t[0][a] = r.get()), (t[1][a] = r.getVelocity())
      }),
    t
  )
}
function kS(e, t, r, a) {
  if (typeof t == 'function') {
    const [o, u] = o_(a)
    t = t(r !== void 0 ? r : e.custom, o, u)
  }
  if ((typeof t == 'string' && (t = e.variants && e.variants[t]), typeof t == 'function')) {
    const [o, u] = o_(a)
    t = t(r !== void 0 ? r : e.custom, o, u)
  }
  return t
}
function cg(e, t, r) {
  const a = e.getProps()
  return kS(a, t, r !== void 0 ? r : a.custom, e)
}
const AS = ['animate', 'whileInView', 'whileFocus', 'whileHover', 'whileTap', 'whileDrag', 'exit'],
  DS = ['initial', ...AS],
  Ph = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY'
  ],
  Ns = new Set(Ph),
  $a = e => e * 1e3,
  To = e => e / 1e3,
  C8 = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  w8 = e => ({
    type: 'spring',
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  }),
  R8 = { type: 'keyframes', duration: 0.8 },
  _8 = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  O8 = (e, { keyframes: t }) =>
    t.length > 2 ? R8 : Ns.has(e) ? (e.startsWith('scale') ? w8(t[1]) : C8) : _8
function k8({
  when: e,
  delay: t,
  delayChildren: r,
  staggerChildren: a,
  staggerDirection: o,
  repeat: u,
  repeatType: l,
  repeatDelay: d,
  from: h,
  elapsed: p,
  ...v
}) {
  return !!Object.keys(v).length
}
function NS(e, t) {
  return e[t] || e.default || e
}
const A8 = { skipAnimations: !1, useManualTiming: !1 },
  D8 = e => e !== null
function fg(e, { repeat: t, repeatType: r = 'loop' }, a) {
  const o = e.filter(D8),
    u = t && r !== 'loop' && t % 2 === 1 ? 0 : o.length - 1
  return !u || a === void 0 ? o[u] : a
}
const Tr = e => e
function N8(e) {
  let t = new Set(),
    r = new Set(),
    a = !1,
    o = !1
  const u = new WeakSet()
  let l = { delta: 0, timestamp: 0, isProcessing: !1 }
  function d(p) {
    u.has(p) && (h.schedule(p), e()), p(l)
  }
  const h = {
    schedule: (p, v = !1, g = !1) => {
      const x = g && a ? t : r
      return v && u.add(p), x.has(p) || x.add(p), p
    },
    cancel: p => {
      r.delete(p), u.delete(p)
    },
    process: p => {
      if (((l = p), a)) {
        o = !0
        return
      }
      ;(a = !0), ([t, r] = [r, t]), r.clear(), t.forEach(d), (a = !1), o && ((o = !1), h.process(p))
    }
  }
  return h
}
const mv = ['read', 'resolveKeyframes', 'update', 'preRender', 'render', 'postRender'],
  M8 = 40
function xA(e, t) {
  let r = !1,
    a = !0
  const o = { delta: 0, timestamp: 0, isProcessing: !1 },
    u = () => (r = !0),
    l = mv.reduce((R, D) => ((R[D] = N8(u)), R), {}),
    { read: d, resolveKeyframes: h, update: p, preRender: v, render: g, postRender: E } = l,
    x = () => {
      const R = performance.now()
      ;(r = !1),
        (o.delta = a ? 1e3 / 60 : Math.max(Math.min(R - o.timestamp, M8), 1)),
        (o.timestamp = R),
        (o.isProcessing = !0),
        d.process(o),
        h.process(o),
        p.process(o),
        v.process(o),
        g.process(o),
        E.process(o),
        (o.isProcessing = !1),
        r && t && ((a = !1), e(x))
    },
    C = () => {
      ;(r = !0), (a = !0), o.isProcessing || e(x)
    }
  return {
    schedule: mv.reduce((R, D) => {
      const A = l[D]
      return (R[D] = (L, F = !1, z = !1) => (r || C(), A.schedule(L, F, z))), R
    }, {}),
    cancel: R => {
      for (let D = 0; D < mv.length; D++) l[mv[D]].cancel(R)
    },
    state: o,
    steps: l
  }
}
const {
    schedule: un,
    cancel: Oo,
    state: xr,
    steps: zE
  } = xA(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : Tr, !0),
  SA = e => /^0[^.\s]+$/u.test(e)
function L8(e) {
  return typeof e == 'number' ? e === 0 : e !== null ? e === 'none' || e === '0' || SA(e) : !0
}
let Pc = Tr,
  Ss = Tr
;(Pc = (e, t) => {
  !e && typeof console < 'u' && console.warn(t)
}),
  (Ss = (e, t) => {
    if (!e) throw new Error(t)
  })
const TA = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
  CA = e => t => typeof t == 'string' && t.startsWith(e),
  wA = CA('--'),
  P8 = CA('var(--'),
  MS = e => (P8(e) ? I8.test(e.split('/*')[0].trim()) : !1),
  I8 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  F8 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
function V8(e) {
  const t = F8.exec(e)
  if (!t) return [,]
  const [, r, a, o] = t
  return [`--${r ?? a}`, o]
}
const j8 = 4
function RA(e, t, r = 1) {
  Ss(
    r <= j8,
    `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`
  )
  const [a, o] = V8(e)
  if (!a) return
  const u = window.getComputedStyle(t).getPropertyValue(a)
  if (u) {
    const l = u.trim()
    return TA(l) ? parseFloat(l) : l
  }
  return MS(o) ? RA(o, t, r + 1) : o
}
const Ts = (e, t, r) => (r > t ? t : r < e ? e : r),
  Ic = { test: e => typeof e == 'number', parse: parseFloat, transform: e => e },
  Xd = { ...Ic, transform: e => Ts(0, 1, e) },
  vv = { ...Ic, default: 1 },
  Qd = e => Math.round(e * 1e5) / 1e5,
  LS = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
  U8 =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
  $8 =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
function Ih(e) {
  return typeof e == 'string'
}
function B8(e) {
  return e == null
}
const Fh = e => ({
    test: t => Ih(t) && t.endsWith(e) && t.split(' ').length === 1,
    parse: parseFloat,
    transform: t => `${t}${e}`
  }),
  fs = Fh('deg'),
  Ba = Fh('%'),
  it = Fh('px'),
  z8 = Fh('vh'),
  H8 = Fh('vw'),
  s_ = { ...Ba, parse: e => Ba.parse(e) / 100, transform: e => Ba.transform(e * 100) },
  W8 = new Set([
    'width',
    'height',
    'top',
    'left',
    'right',
    'bottom',
    'x',
    'y',
    'translateX',
    'translateY'
  ]),
  l_ = e => e === Ic || e === it,
  u_ = (e, t) => parseFloat(e.split(', ')[t]),
  c_ =
    (e, t) =>
    (r, { transform: a }) => {
      if (a === 'none' || !a) return 0
      const o = a.match(/^matrix3d\((.+)\)$/u)
      if (o) return u_(o[1], t)
      {
        const u = a.match(/^matrix\((.+)\)$/u)
        return u ? u_(u[1], e) : 0
      }
    },
  Y8 = new Set(['x', 'y', 'z']),
  q8 = Ph.filter(e => !Y8.has(e))
function G8(e) {
  const t = []
  return (
    q8.forEach(r => {
      const a = e.getValue(r)
      a !== void 0 && (t.push([r, a.get()]), a.set(r.startsWith('scale') ? 1 : 0))
    }),
    t
  )
}
const _c = {
  width: ({ x: e }, { paddingLeft: t = '0', paddingRight: r = '0' }) =>
    e.max - e.min - parseFloat(t) - parseFloat(r),
  height: ({ y: e }, { paddingTop: t = '0', paddingBottom: r = '0' }) =>
    e.max - e.min - parseFloat(t) - parseFloat(r),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  x: c_(4, 13),
  y: c_(5, 14)
}
_c.translateX = _c.x
_c.translateY = _c.y
const _A = e => t => t.test(e),
  K8 = { test: e => e === 'auto', parse: e => e },
  OA = [Ic, it, Ba, fs, H8, z8, K8],
  f_ = e => OA.find(_A(e)),
  Ml = new Set()
let jx = !1,
  Ux = !1
function kA() {
  if (Ux) {
    const e = Array.from(Ml).filter(a => a.needsMeasurement),
      t = new Set(e.map(a => a.element)),
      r = new Map()
    t.forEach(a => {
      const o = G8(a)
      o.length && (r.set(a, o), a.render())
    }),
      e.forEach(a => a.measureInitialState()),
      t.forEach(a => {
        a.render()
        const o = r.get(a)
        o &&
          o.forEach(([u, l]) => {
            var d
            ;(d = a.getValue(u)) === null || d === void 0 || d.set(l)
          })
      }),
      e.forEach(a => a.measureEndState()),
      e.forEach(a => {
        a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY)
      })
  }
  ;(Ux = !1), (jx = !1), Ml.forEach(e => e.complete()), Ml.clear()
}
function AA() {
  Ml.forEach(e => {
    e.readKeyframes(), e.needsMeasurement && (Ux = !0)
  })
}
function Z8() {
  AA(), kA()
}
class PS {
  constructor(t, r, a, o, u, l = !1) {
    ;(this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...t]),
      (this.onComplete = r),
      (this.name = a),
      (this.motionValue = o),
      (this.element = u),
      (this.isAsync = l)
  }
  scheduleResolve() {
    ;(this.isScheduled = !0),
      this.isAsync
        ? (Ml.add(this), jx || ((jx = !0), un.read(AA), un.resolveKeyframes(kA)))
        : (this.readKeyframes(), this.complete())
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: r, element: a, motionValue: o } = this
    for (let u = 0; u < t.length; u++)
      if (t[u] === null)
        if (u === 0) {
          const l = o == null ? void 0 : o.get(),
            d = t[t.length - 1]
          if (l !== void 0) t[0] = l
          else if (a && r) {
            const h = a.readValue(r, d)
            h != null && (t[0] = h)
          }
          t[0] === void 0 && (t[0] = d), o && l === void 0 && o.set(t[0])
        } else t[u] = t[u - 1]
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    ;(this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      Ml.delete(this)
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), Ml.delete(this))
  }
  resume() {
    this.isComplete || this.scheduleResolve()
  }
}
const IS = (e, t) => r =>
    !!(
      (Ih(r) && $8.test(r) && r.startsWith(e)) ||
      (t && !B8(r) && Object.prototype.hasOwnProperty.call(r, t))
    ),
  DA = (e, t, r) => a => {
    if (!Ih(a)) return a
    const [o, u, l, d] = a.match(LS)
    return {
      [e]: parseFloat(o),
      [t]: parseFloat(u),
      [r]: parseFloat(l),
      alpha: d !== void 0 ? parseFloat(d) : 1
    }
  },
  X8 = e => Ts(0, 255, e),
  HE = { ...Ic, transform: e => Math.round(X8(e)) },
  Sl = {
    test: IS('rgb', 'red'),
    parse: DA('red', 'green', 'blue'),
    transform: ({ red: e, green: t, blue: r, alpha: a = 1 }) =>
      'rgba(' +
      HE.transform(e) +
      ', ' +
      HE.transform(t) +
      ', ' +
      HE.transform(r) +
      ', ' +
      Qd(Xd.transform(a)) +
      ')'
  }
function Q8(e) {
  let t = '',
    r = '',
    a = '',
    o = ''
  return (
    e.length > 5
      ? ((t = e.substring(1, 3)),
        (r = e.substring(3, 5)),
        (a = e.substring(5, 7)),
        (o = e.substring(7, 9)))
      : ((t = e.substring(1, 2)),
        (r = e.substring(2, 3)),
        (a = e.substring(3, 4)),
        (o = e.substring(4, 5)),
        (t += t),
        (r += r),
        (a += a),
        (o += o)),
    {
      red: parseInt(t, 16),
      green: parseInt(r, 16),
      blue: parseInt(a, 16),
      alpha: o ? parseInt(o, 16) / 255 : 1
    }
  )
}
const $x = { test: IS('#'), parse: Q8, transform: Sl.transform },
  Qu = {
    test: IS('hsl', 'hue'),
    parse: DA('hue', 'saturation', 'lightness'),
    transform: ({ hue: e, saturation: t, lightness: r, alpha: a = 1 }) =>
      'hsla(' +
      Math.round(e) +
      ', ' +
      Ba.transform(Qd(t)) +
      ', ' +
      Ba.transform(Qd(r)) +
      ', ' +
      Qd(Xd.transform(a)) +
      ')'
  },
  Lr = {
    test: e => Sl.test(e) || $x.test(e) || Qu.test(e),
    parse: e => (Sl.test(e) ? Sl.parse(e) : Qu.test(e) ? Qu.parse(e) : $x.parse(e)),
    transform: e => (Ih(e) ? e : e.hasOwnProperty('red') ? Sl.transform(e) : Qu.transform(e))
  }
function J8(e) {
  var t, r
  return (
    isNaN(e) &&
    Ih(e) &&
    (((t = e.match(LS)) === null || t === void 0 ? void 0 : t.length) || 0) +
      (((r = e.match(U8)) === null || r === void 0 ? void 0 : r.length) || 0) >
      0
  )
}
const NA = 'number',
  MA = 'color',
  ej = 'var',
  tj = 'var(',
  d_ = '${}',
  nj =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu
function lh(e) {
  const t = e.toString(),
    r = [],
    a = { color: [], number: [], var: [] },
    o = []
  let u = 0
  const d = t
    .replace(
      nj,
      h => (
        Lr.test(h)
          ? (a.color.push(u), o.push(MA), r.push(Lr.parse(h)))
          : h.startsWith(tj)
            ? (a.var.push(u), o.push(ej), r.push(h))
            : (a.number.push(u), o.push(NA), r.push(parseFloat(h))),
        ++u,
        d_
      )
    )
    .split(d_)
  return { values: r, split: d, indexes: a, types: o }
}
function LA(e) {
  return lh(e).values
}
function PA(e) {
  const { split: t, types: r } = lh(e),
    a = t.length
  return o => {
    let u = ''
    for (let l = 0; l < a; l++)
      if (((u += t[l]), o[l] !== void 0)) {
        const d = r[l]
        d === NA ? (u += Qd(o[l])) : d === MA ? (u += Lr.transform(o[l])) : (u += o[l])
      }
    return u
  }
}
const rj = e => (typeof e == 'number' ? 0 : e)
function ij(e) {
  const t = LA(e)
  return PA(e)(t.map(rj))
}
const Cs = { test: J8, parse: LA, createTransformer: PA, getAnimatableNone: ij },
  aj = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function oj(e) {
  const [t, r] = e.slice(0, -1).split('(')
  if (t === 'drop-shadow') return e
  const [a] = r.match(LS) || []
  if (!a) return e
  const o = r.replace(a, '')
  let u = aj.has(t) ? 1 : 0
  return a !== r && (u *= 100), t + '(' + u + o + ')'
}
const sj = /\b([a-z-]*)\(.*?\)/gu,
  Bx = {
    ...Cs,
    getAnimatableNone: e => {
      const t = e.match(sj)
      return t ? t.map(oj).join(' ') : e
    }
  },
  h_ = { ...Ic, transform: Math.round },
  FS = {
    borderWidth: it,
    borderTopWidth: it,
    borderRightWidth: it,
    borderBottomWidth: it,
    borderLeftWidth: it,
    borderRadius: it,
    radius: it,
    borderTopLeftRadius: it,
    borderTopRightRadius: it,
    borderBottomRightRadius: it,
    borderBottomLeftRadius: it,
    width: it,
    maxWidth: it,
    height: it,
    maxHeight: it,
    size: it,
    top: it,
    right: it,
    bottom: it,
    left: it,
    padding: it,
    paddingTop: it,
    paddingRight: it,
    paddingBottom: it,
    paddingLeft: it,
    margin: it,
    marginTop: it,
    marginRight: it,
    marginBottom: it,
    marginLeft: it,
    rotate: fs,
    rotateX: fs,
    rotateY: fs,
    rotateZ: fs,
    scale: vv,
    scaleX: vv,
    scaleY: vv,
    scaleZ: vv,
    skew: fs,
    skewX: fs,
    skewY: fs,
    distance: it,
    translateX: it,
    translateY: it,
    translateZ: it,
    x: it,
    y: it,
    z: it,
    perspective: it,
    transformPerspective: it,
    opacity: Xd,
    originX: s_,
    originY: s_,
    originZ: it,
    zIndex: h_,
    backgroundPositionX: it,
    backgroundPositionY: it,
    fillOpacity: Xd,
    strokeOpacity: Xd,
    numOctaves: h_
  },
  lj = {
    ...FS,
    color: Lr,
    backgroundColor: Lr,
    outlineColor: Lr,
    fill: Lr,
    stroke: Lr,
    borderColor: Lr,
    borderTopColor: Lr,
    borderRightColor: Lr,
    borderBottomColor: Lr,
    borderLeftColor: Lr,
    filter: Bx,
    WebkitFilter: Bx
  },
  VS = e => lj[e]
function IA(e, t) {
  let r = VS(e)
  return r !== Bx && (r = Cs), r.getAnimatableNone ? r.getAnimatableNone(t) : void 0
}
const uj = new Set(['auto', 'none', '0'])
function cj(e, t, r) {
  let a = 0,
    o
  for (; a < e.length && !o; ) {
    const u = e[a]
    typeof u == 'string' && !uj.has(u) && lh(u).values.length && (o = e[a]), a++
  }
  if (o && r) for (const u of t) e[u] = IA(r, o)
}
class FA extends PS {
  constructor(t, r, a, o, u) {
    super(t, r, a, o, u, !0)
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: r, name: a } = this
    if (!r || !r.current) return
    super.readKeyframes()
    for (let h = 0; h < t.length; h++) {
      let p = t[h]
      if (typeof p == 'string' && ((p = p.trim()), MS(p))) {
        const v = RA(p, r.current)
        v !== void 0 && (t[h] = v), h === t.length - 1 && (this.finalKeyframe = p)
      }
    }
    if ((this.resolveNoneKeyframes(), !W8.has(a) || t.length !== 2)) return
    const [o, u] = t,
      l = f_(o),
      d = f_(u)
    if (l !== d)
      if (l_(l) && l_(d))
        for (let h = 0; h < t.length; h++) {
          const p = t[h]
          typeof p == 'string' && (t[h] = parseFloat(p))
        }
      else this.needsMeasurement = !0
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: r } = this,
      a = []
    for (let o = 0; o < t.length; o++) L8(t[o]) && a.push(o)
    a.length && cj(t, a, r)
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: r, name: a } = this
    if (!t || !t.current) return
    a === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = _c[a](t.measureViewportBox(), window.getComputedStyle(t.current))),
      (r[0] = this.measuredOrigin)
    const o = r[r.length - 1]
    o !== void 0 && t.getValue(a, o).jump(o, !1)
  }
  measureEndState() {
    var t
    const { element: r, name: a, unresolvedKeyframes: o } = this
    if (!r || !r.current) return
    const u = r.getValue(a)
    u && u.jump(this.measuredOrigin, !1)
    const l = o.length - 1,
      d = o[l]
    ;(o[l] = _c[a](r.measureViewportBox(), window.getComputedStyle(r.current))),
      d !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = d),
      !((t = this.removedTransforms) === null || t === void 0) &&
        t.length &&
        this.removedTransforms.forEach(([h, p]) => {
          r.getValue(h).set(p)
        }),
      this.resolveNoneKeyframes()
  }
}
function VA(e) {
  let t
  return () => (t === void 0 && (t = e()), t)
}
let Rv
function fj() {
  Rv = void 0
}
const Co = {
    now: () => (
      Rv === void 0 && Co.set(xr.isProcessing || A8.useManualTiming ? xr.timestamp : performance.now()),
      Rv
    ),
    set: e => {
      ;(Rv = e), queueMicrotask(fj)
    }
  },
  p_ = (e, t) =>
    t === 'zIndex'
      ? !1
      : !!(
          typeof e == 'number' ||
          Array.isArray(e) ||
          (typeof e == 'string' && (Cs.test(e) || e === '0') && !e.startsWith('url('))
        )
function dj(e) {
  const t = e[0]
  if (e.length === 1) return !0
  for (let r = 0; r < e.length; r++) if (e[r] !== t) return !0
}
function hj(e, t, r, a) {
  const o = e[0]
  if (o === null) return !1
  if (t === 'display' || t === 'visibility') return !0
  const u = e[e.length - 1],
    l = p_(o, t),
    d = p_(u, t)
  return (
    Pc(
      l === d,
      `You are trying to animate ${t} from "${o}" to "${u}". ${o} is not an animatable value - to enable this animation set ${o} to a value animatable to ${u} via the \`style\` property.`
    ),
    !l || !d ? !1 : dj(e) || (r === 'spring' && a)
  )
}
const pj = 40
class jA {
  constructor({
    autoplay: t = !0,
    delay: r = 0,
    type: a = 'keyframes',
    repeat: o = 0,
    repeatDelay: u = 0,
    repeatType: l = 'loop',
    ...d
  }) {
    ;(this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = Co.now()),
      (this.options = {
        autoplay: t,
        delay: r,
        type: a,
        repeat: o,
        repeatDelay: u,
        repeatType: l,
        ...d
      }),
      this.updateFinishedPromise()
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > pj
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt
  }
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && Z8(), this._resolved
  }
  onKeyframesResolved(t, r) {
    ;(this.resolvedAt = Co.now()), (this.hasAttemptedResolve = !0)
    const {
      name: a,
      type: o,
      velocity: u,
      delay: l,
      onComplete: d,
      onUpdate: h,
      isGenerator: p
    } = this.options
    if (!p && !hj(t, a, o, u))
      if (l) this.options.duration = 0
      else {
        h == null || h(fg(t, this.options, r)), d == null || d(), this.resolveFinishedPromise()
        return
      }
    const v = this.initPlayback(t, r)
    v !== !1 && ((this._resolved = { keyframes: t, finalKeyframe: r, ...v }), this.onPostResolved())
  }
  onPostResolved() {}
  then(t, r) {
    return this.currentFinishedPromise.then(t, r)
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise(t => {
      this.resolveFinishedPromise = t
    })
  }
}
function UA(e, t) {
  return t ? e * (1e3 / t) : 0
}
const mj = 5
function $A(e, t, r) {
  const a = Math.max(t - mj, 0)
  return UA(r - e(a), t - a)
}
const WE = 0.001,
  vj = 0.01,
  m_ = 10,
  gj = 0.05,
  yj = 1
function bj({ duration: e = 800, bounce: t = 0.25, velocity: r = 0, mass: a = 1 }) {
  let o, u
  Pc(e <= $a(m_), 'Spring duration must be 10 seconds or less')
  let l = 1 - t
  ;(l = Ts(gj, yj, l)),
    (e = Ts(vj, m_, To(e))),
    l < 1
      ? ((o = p => {
          const v = p * l,
            g = v * e,
            E = v - r,
            x = zx(p, l),
            C = Math.exp(-g)
          return WE - (E / x) * C
        }),
        (u = p => {
          const g = p * l * e,
            E = g * r + r,
            x = Math.pow(l, 2) * Math.pow(p, 2) * e,
            C = Math.exp(-g),
            _ = zx(Math.pow(p, 2), l)
          return ((-o(p) + WE > 0 ? -1 : 1) * ((E - x) * C)) / _
        }))
      : ((o = p => {
          const v = Math.exp(-p * e),
            g = (p - r) * e + 1
          return -WE + v * g
        }),
        (u = p => {
          const v = Math.exp(-p * e),
            g = (r - p) * (e * e)
          return v * g
        }))
  const d = 5 / e,
    h = xj(o, u, d)
  if (((e = $a(e)), isNaN(h))) return { stiffness: 100, damping: 10, duration: e }
  {
    const p = Math.pow(h, 2) * a
    return { stiffness: p, damping: l * 2 * Math.sqrt(a * p), duration: e }
  }
}
const Ej = 12
function xj(e, t, r) {
  let a = r
  for (let o = 1; o < Ej; o++) a = a - e(a) / t(a)
  return a
}
function zx(e, t) {
  return e * Math.sqrt(1 - t * t)
}
const Sj = ['duration', 'bounce'],
  Tj = ['stiffness', 'damping', 'mass']
function v_(e, t) {
  return t.some(r => e[r] !== void 0)
}
function Cj(e) {
  let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }
  if (!v_(e, Tj) && v_(e, Sj)) {
    const r = bj(e)
    ;(t = { ...t, ...r, mass: 1 }), (t.isResolvedFromDuration = !0)
  }
  return t
}
function BA({ keyframes: e, restDelta: t, restSpeed: r, ...a }) {
  const o = e[0],
    u = e[e.length - 1],
    l = { done: !1, value: o },
    {
      stiffness: d,
      damping: h,
      mass: p,
      duration: v,
      velocity: g,
      isResolvedFromDuration: E
    } = Cj({ ...a, velocity: -To(a.velocity || 0) }),
    x = g || 0,
    C = h / (2 * Math.sqrt(d * p)),
    _ = u - o,
    k = To(Math.sqrt(d / p)),
    R = Math.abs(_) < 5
  r || (r = R ? 0.01 : 2), t || (t = R ? 0.005 : 0.5)
  let D
  if (C < 1) {
    const A = zx(k, C)
    D = L => {
      const F = Math.exp(-C * k * L)
      return u - F * (((x + C * k * _) / A) * Math.sin(A * L) + _ * Math.cos(A * L))
    }
  } else if (C === 1) D = A => u - Math.exp(-k * A) * (_ + (x + k * _) * A)
  else {
    const A = k * Math.sqrt(C * C - 1)
    D = L => {
      const F = Math.exp(-C * k * L),
        z = Math.min(A * L, 300)
      return u - (F * ((x + C * k * _) * Math.sinh(z) + A * _ * Math.cosh(z))) / A
    }
  }
  return {
    calculatedDuration: (E && v) || null,
    next: A => {
      const L = D(A)
      if (E) l.done = A >= v
      else {
        let F = 0
        C < 1 && (F = A === 0 ? $a(x) : $A(D, A, L))
        const z = Math.abs(F) <= r,
          H = Math.abs(u - L) <= t
        l.done = z && H
      }
      return (l.value = l.done ? u : L), l
    }
  }
}
function g_({
  keyframes: e,
  velocity: t = 0,
  power: r = 0.8,
  timeConstant: a = 325,
  bounceDamping: o = 10,
  bounceStiffness: u = 500,
  modifyTarget: l,
  min: d,
  max: h,
  restDelta: p = 0.5,
  restSpeed: v
}) {
  const g = e[0],
    E = { done: !1, value: g },
    x = $ => (d !== void 0 && $ < d) || (h !== void 0 && $ > h),
    C = $ => (d === void 0 ? h : h === void 0 || Math.abs(d - $) < Math.abs(h - $) ? d : h)
  let _ = r * t
  const k = g + _,
    R = l === void 0 ? k : l(k)
  R !== k && (_ = R - g)
  const D = $ => -_ * Math.exp(-$ / a),
    A = $ => R + D($),
    L = $ => {
      const Q = D($),
        ue = A($)
      ;(E.done = Math.abs(Q) <= p), (E.value = E.done ? R : ue)
    }
  let F, z
  const H = $ => {
    x(E.value) &&
      ((F = $),
      (z = BA({
        keyframes: [E.value, C(E.value)],
        velocity: $A(A, $, E.value),
        damping: o,
        stiffness: u,
        restDelta: p,
        restSpeed: v
      })))
  }
  return (
    H(0),
    {
      calculatedDuration: null,
      next: $ => {
        let Q = !1
        return (
          !z && F === void 0 && ((Q = !0), L($), H($)),
          F !== void 0 && $ >= F ? z.next($ - F) : (!Q && L($), E)
        )
      }
    }
  )
}
const zA = (e, t, r) => (((1 - 3 * r + 3 * t) * e + (3 * r - 6 * t)) * e + 3 * t) * e,
  wj = 1e-7,
  Rj = 12
function _j(e, t, r, a, o) {
  let u,
    l,
    d = 0
  do (l = t + (r - t) / 2), (u = zA(l, a, o) - e), u > 0 ? (r = l) : (t = l)
  while (Math.abs(u) > wj && ++d < Rj)
  return l
}
function Vh(e, t, r, a) {
  if (e === t && r === a) return Tr
  const o = u => _j(u, 0, 1, e, r)
  return u => (u === 0 || u === 1 ? u : zA(o(u), t, a))
}
const Oj = Vh(0.42, 0, 1, 1),
  kj = Vh(0, 0, 0.58, 1),
  HA = Vh(0.42, 0, 0.58, 1),
  Aj = e => Array.isArray(e) && typeof e[0] != 'number',
  WA = e => t => (t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2),
  YA = e => t => 1 - e(1 - t),
  jS = e => 1 - Math.sin(Math.acos(e)),
  qA = YA(jS),
  Dj = WA(jS),
  GA = Vh(0.33, 1.53, 0.69, 0.99),
  US = YA(GA),
  Nj = WA(US),
  Mj = e => ((e *= 2) < 1 ? 0.5 * US(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1)))),
  y_ = {
    linear: Tr,
    easeIn: Oj,
    easeInOut: HA,
    easeOut: kj,
    circIn: jS,
    circInOut: Dj,
    circOut: qA,
    backIn: US,
    backInOut: Nj,
    backOut: GA,
    anticipate: Mj
  },
  b_ = e => {
    if (Array.isArray(e)) {
      Ss(e.length === 4, 'Cubic bezier arrays must contain four numerical values.')
      const [t, r, a, o] = e
      return Vh(t, r, a, o)
    } else if (typeof e == 'string') return Ss(y_[e] !== void 0, `Invalid easing type '${e}'`), y_[e]
    return e
  },
  Lj = (e, t) => r => t(e(r)),
  wo = (...e) => e.reduce(Lj),
  uh = (e, t, r) => {
    const a = t - e
    return a === 0 ? 1 : (r - e) / a
  },
  kn = (e, t, r) => e + (t - e) * r
function YE(e, t, r) {
  return (
    r < 0 && (r += 1),
    r > 1 && (r -= 1),
    r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
  )
}
function Pj({ hue: e, saturation: t, lightness: r, alpha: a }) {
  ;(e /= 360), (t /= 100), (r /= 100)
  let o = 0,
    u = 0,
    l = 0
  if (!t) o = u = l = r
  else {
    const d = r < 0.5 ? r * (1 + t) : r + t - r * t,
      h = 2 * r - d
    ;(o = YE(h, d, e + 1 / 3)), (u = YE(h, d, e)), (l = YE(h, d, e - 1 / 3))
  }
  return { red: Math.round(o * 255), green: Math.round(u * 255), blue: Math.round(l * 255), alpha: a }
}
function Uv(e, t) {
  return r => (r > 0 ? t : e)
}
const qE = (e, t, r) => {
    const a = e * e,
      o = r * (t * t - a) + a
    return o < 0 ? 0 : Math.sqrt(o)
  },
  Ij = [$x, Sl, Qu],
  Fj = e => Ij.find(t => t.test(e))
function E_(e) {
  const t = Fj(e)
  if ((Pc(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t))
    return !1
  let r = t.parse(e)
  return t === Qu && (r = Pj(r)), r
}
const x_ = (e, t) => {
    const r = E_(e),
      a = E_(t)
    if (!r || !a) return Uv(e, t)
    const o = { ...r }
    return u => (
      (o.red = qE(r.red, a.red, u)),
      (o.green = qE(r.green, a.green, u)),
      (o.blue = qE(r.blue, a.blue, u)),
      (o.alpha = kn(r.alpha, a.alpha, u)),
      Sl.transform(o)
    )
  },
  Hx = new Set(['none', 'hidden'])
function Vj(e, t) {
  return Hx.has(e) ? r => (r <= 0 ? e : t) : r => (r >= 1 ? t : e)
}
function jj(e, t) {
  return r => kn(e, t, r)
}
function $S(e) {
  return typeof e == 'number'
    ? jj
    : typeof e == 'string'
      ? MS(e)
        ? Uv
        : Lr.test(e)
          ? x_
          : Bj
      : Array.isArray(e)
        ? KA
        : typeof e == 'object'
          ? Lr.test(e)
            ? x_
            : Uj
          : Uv
}
function KA(e, t) {
  const r = [...e],
    a = r.length,
    o = e.map((u, l) => $S(u)(u, t[l]))
  return u => {
    for (let l = 0; l < a; l++) r[l] = o[l](u)
    return r
  }
}
function Uj(e, t) {
  const r = { ...e, ...t },
    a = {}
  for (const o in r) e[o] !== void 0 && t[o] !== void 0 && (a[o] = $S(e[o])(e[o], t[o]))
  return o => {
    for (const u in a) r[u] = a[u](o)
    return r
  }
}
function $j(e, t) {
  var r
  const a = [],
    o = { color: 0, var: 0, number: 0 }
  for (let u = 0; u < t.values.length; u++) {
    const l = t.types[u],
      d = e.indexes[l][o[l]],
      h = (r = e.values[d]) !== null && r !== void 0 ? r : 0
    ;(a[u] = h), o[l]++
  }
  return a
}
const Bj = (e, t) => {
  const r = Cs.createTransformer(t),
    a = lh(e),
    o = lh(t)
  return a.indexes.var.length === o.indexes.var.length &&
    a.indexes.color.length === o.indexes.color.length &&
    a.indexes.number.length >= o.indexes.number.length
    ? (Hx.has(e) && !o.values.length) || (Hx.has(t) && !a.values.length)
      ? Vj(e, t)
      : wo(KA($j(a, o), o.values), r)
    : (Pc(
        !0,
        `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
      ),
      Uv(e, t))
}
function ZA(e, t, r) {
  return typeof e == 'number' && typeof t == 'number' && typeof r == 'number' ? kn(e, t, r) : $S(e)(e, t)
}
function zj(e, t, r) {
  const a = [],
    o = r || ZA,
    u = e.length - 1
  for (let l = 0; l < u; l++) {
    let d = o(e[l], e[l + 1])
    if (t) {
      const h = Array.isArray(t) ? t[l] || Tr : t
      d = wo(h, d)
    }
    a.push(d)
  }
  return a
}
function Hj(e, t, { clamp: r = !0, ease: a, mixer: o } = {}) {
  const u = e.length
  if ((Ss(u === t.length, 'Both input and output ranges must be the same length'), u === 1))
    return () => t[0]
  if (u === 2 && e[0] === e[1]) return () => t[1]
  e[0] > e[u - 1] && ((e = [...e].reverse()), (t = [...t].reverse()))
  const l = zj(t, a, o),
    d = l.length,
    h = p => {
      let v = 0
      if (d > 1) for (; v < e.length - 2 && !(p < e[v + 1]); v++);
      const g = uh(e[v], e[v + 1], p)
      return l[v](g)
    }
  return r ? p => h(Ts(e[0], e[u - 1], p)) : h
}
function Wj(e, t) {
  const r = e[e.length - 1]
  for (let a = 1; a <= t; a++) {
    const o = uh(0, t, a)
    e.push(kn(r, 1, o))
  }
}
function Yj(e) {
  const t = [0]
  return Wj(t, e.length - 1), t
}
function qj(e, t) {
  return e.map(r => r * t)
}
function Gj(e, t) {
  return e.map(() => t || HA).splice(0, e.length - 1)
}
function $v({ duration: e = 300, keyframes: t, times: r, ease: a = 'easeInOut' }) {
  const o = Aj(a) ? a.map(b_) : b_(a),
    u = { done: !1, value: t[0] },
    l = qj(r && r.length === t.length ? r : Yj(t), e),
    d = Hj(l, t, { ease: Array.isArray(o) ? o : Gj(t, o) })
  return { calculatedDuration: e, next: h => ((u.value = d(h)), (u.done = h >= e), u) }
}
const S_ = 2e4
function Kj(e) {
  let t = 0
  const r = 50
  let a = e.next(t)
  for (; !a.done && t < S_; ) (t += r), (a = e.next(t))
  return t >= S_ ? 1 / 0 : t
}
const Zj = e => {
    const t = ({ timestamp: r }) => e(r)
    return {
      start: () => un.update(t, !0),
      stop: () => Oo(t),
      now: () => (xr.isProcessing ? xr.timestamp : Co.now())
    }
  },
  Xj = { decay: g_, inertia: g_, tween: $v, keyframes: $v, spring: BA },
  Qj = e => e / 100
class BS extends jA {
  constructor(t) {
    super(t),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = 'running'),
      (this.startTime = null),
      (this.state = 'idle'),
      (this.stop = () => {
        if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
        this.teardown()
        const { onStop: h } = this.options
        h && h()
      })
    const { name: r, motionValue: a, element: o, keyframes: u } = this.options,
      l = (o == null ? void 0 : o.KeyframeResolver) || PS,
      d = (h, p) => this.onKeyframesResolved(h, p)
    ;(this.resolver = new l(u, d, r, a, o)), this.resolver.scheduleResolve()
  }
  initPlayback(t) {
    const {
        type: r = 'keyframes',
        repeat: a = 0,
        repeatDelay: o = 0,
        repeatType: u,
        velocity: l = 0
      } = this.options,
      d = Xj[r] || $v
    let h, p
    d !== $v &&
      typeof t[0] != 'number' &&
      (Ss(
        t.length === 2,
        `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${t}`
      ),
      (h = wo(Qj, ZA(t[0], t[1]))),
      (t = [0, 100]))
    const v = d({ ...this.options, keyframes: t })
    u === 'mirror' && (p = d({ ...this.options, keyframes: [...t].reverse(), velocity: -l })),
      v.calculatedDuration === null && (v.calculatedDuration = Kj(v))
    const { calculatedDuration: g } = v,
      E = g + o,
      x = E * (a + 1) - o
    return {
      generator: v,
      mirroredGenerator: p,
      mapPercentToKeyframes: h,
      calculatedDuration: g,
      resolvedDuration: E,
      totalDuration: x
    }
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options
    this.play(),
      this.pendingPlayState === 'paused' || !t ? this.pause() : (this.state = this.pendingPlayState)
  }
  tick(t, r = !1) {
    const { resolved: a } = this
    if (!a) {
      const { keyframes: $ } = this.options
      return { done: !0, value: $[$.length - 1] }
    }
    const {
      finalKeyframe: o,
      generator: u,
      mirroredGenerator: l,
      mapPercentToKeyframes: d,
      keyframes: h,
      calculatedDuration: p,
      totalDuration: v,
      resolvedDuration: g
    } = a
    if (this.startTime === null) return u.next(0)
    const { delay: E, repeat: x, repeatType: C, repeatDelay: _, onUpdate: k } = this.options
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, t))
      : this.speed < 0 && (this.startTime = Math.min(t - v / this.speed, this.startTime)),
      r
        ? (this.currentTime = t)
        : this.holdTime !== null
          ? (this.currentTime = this.holdTime)
          : (this.currentTime = Math.round(t - this.startTime) * this.speed)
    const R = this.currentTime - E * (this.speed >= 0 ? 1 : -1),
      D = this.speed >= 0 ? R < 0 : R > v
    ;(this.currentTime = Math.max(R, 0)),
      this.state === 'finished' && this.holdTime === null && (this.currentTime = v)
    let A = this.currentTime,
      L = u
    if (x) {
      const $ = Math.min(this.currentTime, v) / g
      let Q = Math.floor($),
        ue = $ % 1
      !ue && $ >= 1 && (ue = 1),
        ue === 1 && Q--,
        (Q = Math.min(Q, x + 1)),
        !!(Q % 2) && (C === 'reverse' ? ((ue = 1 - ue), _ && (ue -= _ / g)) : C === 'mirror' && (L = l)),
        (A = Ts(0, 1, ue) * g)
    }
    const F = D ? { done: !1, value: h[0] } : L.next(A)
    d && (F.value = d(F.value))
    let { done: z } = F
    !D && p !== null && (z = this.speed >= 0 ? this.currentTime >= v : this.currentTime <= 0)
    const H = this.holdTime === null && (this.state === 'finished' || (this.state === 'running' && z))
    return (
      H && o !== void 0 && (F.value = fg(h, this.options, o)), k && k(F.value), H && this.finish(), F
    )
  }
  get duration() {
    const { resolved: t } = this
    return t ? To(t.calculatedDuration) : 0
  }
  get time() {
    return To(this.currentTime)
  }
  set time(t) {
    ;(t = $a(t)),
      (this.currentTime = t),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = t)
        : this.driver && (this.startTime = this.driver.now() - t / this.speed)
  }
  get speed() {
    return this.playbackSpeed
  }
  set speed(t) {
    const r = this.playbackSpeed !== t
    ;(this.playbackSpeed = t), r && (this.time = To(this.currentTime))
  }
  play() {
    if ((this.resolver.isScheduled || this.resolver.resume(), !this._resolved)) {
      this.pendingPlayState = 'running'
      return
    }
    if (this.isStopped) return
    const { driver: t = Zj, onPlay: r, startTime: a } = this.options
    this.driver || (this.driver = t(u => this.tick(u))), r && r()
    const o = this.driver.now()
    this.holdTime !== null
      ? (this.startTime = o - this.holdTime)
      : this.startTime
        ? this.state === 'finished' && (this.startTime = o)
        : (this.startTime = a ?? this.calcStartTime()),
      this.state === 'finished' && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start()
  }
  pause() {
    var t
    if (!this._resolved) {
      this.pendingPlayState = 'paused'
      return
    }
    ;(this.state = 'paused'), (this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0)
  }
  complete() {
    this.state !== 'running' && this.play(),
      (this.pendingPlayState = this.state = 'finished'),
      (this.holdTime = null)
  }
  finish() {
    this.teardown(), (this.state = 'finished')
    const { onComplete: t } = this.options
    t && t()
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
  }
  teardown() {
    ;(this.state = 'idle'),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel()
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0))
  }
  sample(t) {
    return (this.startTime = 0), this.tick(t, !0)
  }
}
const XA = new Set(['opacity', 'clipPath', 'filter', 'transform']),
  QA = e => Array.isArray(e) && typeof e[0] == 'number'
function JA(e) {
  return !!(!e || (typeof e == 'string' && e in zS) || QA(e) || (Array.isArray(e) && e.every(JA)))
}
const Bd = ([e, t, r, a]) => `cubic-bezier(${e}, ${t}, ${r}, ${a})`,
  zS = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: Bd([0, 0.65, 0.55, 1]),
    circOut: Bd([0.55, 0, 1, 0.45]),
    backIn: Bd([0.31, 0.01, 0.66, -0.59]),
    backOut: Bd([0.33, 1.53, 0.69, 0.99])
  }
function Jj(e) {
  return eD(e) || zS.easeOut
}
function eD(e) {
  if (e) return QA(e) ? Bd(e) : Array.isArray(e) ? e.map(Jj) : zS[e]
}
function eU(
  e,
  t,
  r,
  { delay: a = 0, duration: o = 300, repeat: u = 0, repeatType: l = 'loop', ease: d, times: h } = {}
) {
  const p = { [t]: r }
  h && (p.offset = h)
  const v = eD(d)
  return (
    Array.isArray(v) && (p.easing = v),
    e.animate(p, {
      delay: a,
      duration: o,
      easing: Array.isArray(v) ? 'linear' : v,
      fill: 'both',
      iterations: u + 1,
      direction: l === 'reverse' ? 'alternate' : 'normal'
    })
  )
}
const tU = VA(() => Object.hasOwnProperty.call(Element.prototype, 'animate')),
  Bv = 10,
  nU = 2e4
function rU(e) {
  return e.type === 'spring' || !JA(e.ease)
}
function iU(e, t) {
  const r = new BS({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 })
  let a = { done: !1, value: e[0] }
  const o = []
  let u = 0
  for (; !a.done && u < nU; ) (a = r.sample(u)), o.push(a.value), (u += Bv)
  return { times: void 0, keyframes: o, duration: u - Bv, ease: 'linear' }
}
class T_ extends jA {
  constructor(t) {
    super(t)
    const { name: r, motionValue: a, element: o, keyframes: u } = this.options
    ;(this.resolver = new FA(u, (l, d) => this.onKeyframesResolved(l, d), r, a, o)),
      this.resolver.scheduleResolve()
  }
  initPlayback(t, r) {
    var a
    let {
      duration: o = 300,
      times: u,
      ease: l,
      type: d,
      motionValue: h,
      name: p,
      startTime: v
    } = this.options
    if (!(!((a = h.owner) === null || a === void 0) && a.current)) return !1
    if (rU(this.options)) {
      const { onComplete: E, onUpdate: x, motionValue: C, element: _, ...k } = this.options,
        R = iU(t, k)
      ;(t = R.keyframes),
        t.length === 1 && (t[1] = t[0]),
        (o = R.duration),
        (u = R.times),
        (l = R.ease),
        (d = 'keyframes')
    }
    const g = eU(h.owner.current, p, t, { ...this.options, duration: o, times: u, ease: l })
    return (
      (g.startTime = v ?? this.calcStartTime()),
      this.pendingTimeline
        ? ((g.timeline = this.pendingTimeline), (this.pendingTimeline = void 0))
        : (g.onfinish = () => {
            const { onComplete: E } = this.options
            h.set(fg(t, this.options, r)), E && E(), this.cancel(), this.resolveFinishedPromise()
          }),
      { animation: g, duration: o, times: u, type: d, ease: l, keyframes: t }
    )
  }
  get duration() {
    const { resolved: t } = this
    if (!t) return 0
    const { duration: r } = t
    return To(r)
  }
  get time() {
    const { resolved: t } = this
    if (!t) return 0
    const { animation: r } = t
    return To(r.currentTime || 0)
  }
  set time(t) {
    const { resolved: r } = this
    if (!r) return
    const { animation: a } = r
    a.currentTime = $a(t)
  }
  get speed() {
    const { resolved: t } = this
    if (!t) return 1
    const { animation: r } = t
    return r.playbackRate
  }
  set speed(t) {
    const { resolved: r } = this
    if (!r) return
    const { animation: a } = r
    a.playbackRate = t
  }
  get state() {
    const { resolved: t } = this
    if (!t) return 'idle'
    const { animation: r } = t
    return r.playState
  }
  get startTime() {
    const { resolved: t } = this
    if (!t) return null
    const { animation: r } = t
    return r.startTime
  }
  attachTimeline(t) {
    if (!this._resolved) this.pendingTimeline = t
    else {
      const { resolved: r } = this
      if (!r) return Tr
      const { animation: a } = r
      ;(a.timeline = t), (a.onfinish = null)
    }
    return Tr
  }
  play() {
    if (this.isStopped) return
    const { resolved: t } = this
    if (!t) return
    const { animation: r } = t
    r.playState === 'finished' && this.updateFinishedPromise(), r.play()
  }
  pause() {
    const { resolved: t } = this
    if (!t) return
    const { animation: r } = t
    r.pause()
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === 'idle')) return
    this.resolveFinishedPromise(), this.updateFinishedPromise()
    const { resolved: t } = this
    if (!t) return
    const { animation: r, keyframes: a, duration: o, type: u, ease: l, times: d } = t
    if (r.playState === 'idle' || r.playState === 'finished') return
    if (this.time) {
      const { motionValue: p, onUpdate: v, onComplete: g, element: E, ...x } = this.options,
        C = new BS({ ...x, keyframes: a, duration: o, type: u, ease: l, times: d, isGenerator: !0 }),
        _ = $a(this.time)
      p.setWithVelocity(C.sample(_ - Bv).value, C.sample(_).value, Bv)
    }
    const { onStop: h } = this.options
    h && h(), this.cancel()
  }
  complete() {
    const { resolved: t } = this
    t && t.animation.finish()
  }
  cancel() {
    const { resolved: t } = this
    t && t.animation.cancel()
  }
  static supports(t) {
    const { motionValue: r, name: a, repeatDelay: o, repeatType: u, damping: l, type: d } = t
    return (
      tU() &&
      a &&
      XA.has(a) &&
      r &&
      r.owner &&
      r.owner.current instanceof HTMLElement &&
      !r.owner.getProps().onUpdate &&
      !o &&
      u !== 'mirror' &&
      l !== 0 &&
      d !== 'inertia'
    )
  }
}
function aU(e, t) {
  let r
  const a = () => {
    const { currentTime: o } = t,
      l = (o === null ? 0 : o.value) / 100
    r !== l && e(l), (r = l)
  }
  return un.update(a, !0), () => Oo(a)
}
const oU = VA(() => window.ScrollTimeline !== void 0)
class sU {
  constructor(t) {
    ;(this.stop = () => this.runAll('stop')), (this.animations = t.filter(Boolean))
  }
  then(t, r) {
    return Promise.all(this.animations).then(t).catch(r)
  }
  getAll(t) {
    return this.animations[0][t]
  }
  setAll(t, r) {
    for (let a = 0; a < this.animations.length; a++) this.animations[a][t] = r
  }
  attachTimeline(t) {
    const r = this.animations.map(a => {
      if (oU() && a.attachTimeline) a.attachTimeline(t)
      else
        return (
          a.pause(),
          aU(o => {
            a.time = a.duration * o
          }, t)
        )
    })
    return () => {
      r.forEach((a, o) => {
        a && a(), this.animations[o].stop()
      })
    }
  }
  get time() {
    return this.getAll('time')
  }
  set time(t) {
    this.setAll('time', t)
  }
  get speed() {
    return this.getAll('speed')
  }
  set speed(t) {
    this.setAll('speed', t)
  }
  get startTime() {
    return this.getAll('startTime')
  }
  get duration() {
    let t = 0
    for (let r = 0; r < this.animations.length; r++) t = Math.max(t, this.animations[r].duration)
    return t
  }
  runAll(t) {
    this.animations.forEach(r => r[t]())
  }
  play() {
    this.runAll('play')
  }
  pause() {
    this.runAll('pause')
  }
  cancel() {
    this.runAll('cancel')
  }
  complete() {
    this.runAll('complete')
  }
}
const HS =
    (e, t, r, a = {}, o, u, l) =>
    d => {
      const h = NS(a, e) || {},
        p = h.delay || a.delay || 0
      let { elapsed: v = 0 } = a
      v = v - $a(p)
      let g = {
        keyframes: Array.isArray(r) ? r : [null, r],
        ease: 'easeOut',
        velocity: t.getVelocity(),
        ...h,
        delay: -v,
        onUpdate: x => {
          t.set(x), h.onUpdate && h.onUpdate(x)
        },
        onComplete: () => {
          d(), h.onComplete && h.onComplete(), l && l()
        },
        onStop: l,
        name: e,
        motionValue: t,
        element: u ? void 0 : o
      }
      k8(h) || (g = { ...g, ...O8(e, g) }),
        g.duration && (g.duration = $a(g.duration)),
        g.repeatDelay && (g.repeatDelay = $a(g.repeatDelay)),
        g.from !== void 0 && (g.keyframes[0] = g.from)
      let E = !1
      if (
        ((g.type === !1 || (g.duration === 0 && !g.repeatDelay)) &&
          ((g.duration = 0), g.delay === 0 && (E = !0)),
        E && !u && t.get() !== void 0)
      ) {
        const x = fg(g.keyframes, h)
        if (x !== void 0)
          return (
            un.update(() => {
              g.onUpdate(x), g.onComplete()
            }),
            new sU([])
          )
      }
      return !u && T_.supports(g) ? new T_(g) : new BS(g)
    },
  lU = e => !!(e && typeof e == 'object' && e.mix && e.toValue),
  uU = e => (Vx(e) ? e[e.length - 1] || 0 : e)
function dg(e, t) {
  e.indexOf(t) === -1 && e.push(t)
}
function hg(e, t) {
  const r = e.indexOf(t)
  r > -1 && e.splice(r, 1)
}
class WS {
  constructor() {
    this.subscriptions = []
  }
  add(t) {
    return dg(this.subscriptions, t), () => hg(this.subscriptions, t)
  }
  notify(t, r, a) {
    const o = this.subscriptions.length
    if (o)
      if (o === 1) this.subscriptions[0](t, r, a)
      else
        for (let u = 0; u < o; u++) {
          const l = this.subscriptions[u]
          l && l(t, r, a)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
const C_ = 30,
  cU = e => !isNaN(parseFloat(e))
class tD {
  constructor(t, r = {}) {
    ;(this.version = '11.5.4'),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (a, o = !0) => {
        const u = Co.now()
        this.updatedAt !== u && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(a),
          this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
          o && this.events.renderRequest && this.events.renderRequest.notify(this.current)
      }),
      (this.hasAnimated = !1),
      this.setCurrent(t),
      (this.owner = r.owner)
  }
  setCurrent(t) {
    ;(this.current = t),
      (this.updatedAt = Co.now()),
      this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = cU(this.current))
  }
  setPrevFrameValue(t = this.current) {
    ;(this.prevFrameValue = t), (this.prevUpdatedAt = this.updatedAt)
  }
  onChange(t) {
    return (
      ug(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'),
      this.on('change', t)
    )
  }
  on(t, r) {
    this.events[t] || (this.events[t] = new WS())
    const a = this.events[t].add(r)
    return t === 'change'
      ? () => {
          a(),
            un.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : a
  }
  clearListeners() {
    for (const t in this.events) this.events[t].clear()
  }
  attach(t, r) {
    ;(this.passiveEffect = t), (this.stopPassiveEffect = r)
  }
  set(t, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(t, r) : this.passiveEffect(t, this.updateAndNotify)
  }
  setWithVelocity(t, r, a) {
    this.set(r),
      (this.prev = void 0),
      (this.prevFrameValue = t),
      (this.prevUpdatedAt = this.updatedAt - a)
  }
  jump(t, r = !0) {
    this.updateAndNotify(t),
      (this.prev = t),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      r && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    const t = Co.now()
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > C_) return 0
    const r = Math.min(this.updatedAt - this.prevUpdatedAt, C_)
    return UA(parseFloat(this.current) - parseFloat(this.prevFrameValue), r)
  }
  start(t) {
    return (
      this.stop(),
      new Promise(r => {
        ;(this.hasAnimated = !0),
          (this.animation = t(r)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function ch(e, t) {
  return new tD(e, t)
}
function fU(e, t, r) {
  e.hasValue(t) ? e.getValue(t).set(r) : e.addValue(t, ch(r))
}
function dU(e, t) {
  const r = cg(e, t)
  let { transitionEnd: a = {}, transition: o = {}, ...u } = r || {}
  u = { ...u, ...a }
  for (const l in u) {
    const d = uU(u[l])
    fU(e, l, d)
  }
}
const pg = e => e.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  hU = 'framerAppearId',
  nD = 'data-' + pg(hU)
function rD(e) {
  return e.props[nD]
}
function iD(e) {
  if (Ns.has(e)) return 'transform'
  if (XA.has(e)) return pg(e)
}
class pU extends tD {
  constructor() {
    super(...arguments), (this.output = []), (this.counts = new Map())
  }
  add(t) {
    const r = iD(t)
    if (!r) return
    const a = this.counts.get(r) || 0
    this.counts.set(r, a + 1), a === 0 && (this.output.push(r), this.update())
    let o = !1
    return () => {
      if (o) return
      o = !0
      const u = this.counts.get(r) - 1
      this.counts.set(r, u), u === 0 && (hg(this.output, r), this.update())
    }
  }
  update() {
    this.set(this.output.length ? this.output.join(', ') : 'auto')
  }
}
const Ir = e => !!(e && e.getVelocity)
function mU(e) {
  return !!(Ir(e) && e.add)
}
function Wx(e, t) {
  var r
  if (!e.applyWillChange) return
  let a = e.getValue('willChange')
  if (
    (!a &&
      !(!((r = e.props.style) === null || r === void 0) && r.willChange) &&
      ((a = new pU('auto')), e.addValue('willChange', a)),
    mU(a))
  )
    return a.add(t)
}
function vU({ protectedKeys: e, needsAnimating: t }, r) {
  const a = e.hasOwnProperty(r) && t[r] !== !0
  return (t[r] = !1), a
}
function aD(e, t, { delay: r = 0, transitionOverride: a, type: o } = {}) {
  var u
  let { transition: l = e.getDefaultTransition(), transitionEnd: d, ...h } = t
  a && (l = a)
  const p = [],
    v = o && e.animationState && e.animationState.getState()[o]
  for (const g in h) {
    const E = e.getValue(g, (u = e.latestValues[g]) !== null && u !== void 0 ? u : null),
      x = h[g]
    if (x === void 0 || (v && vU(v, g))) continue
    const C = { delay: r, ...NS(l || {}, g) }
    let _ = !1
    if (window.MotionHandoffAnimation) {
      const R = rD(e)
      if (R) {
        const D = window.MotionHandoffAnimation(R, g, un)
        D !== null && ((C.startTime = D), (_ = !0))
      }
    }
    E.start(HS(g, E, x, e.shouldReduceMotion && Ns.has(g) ? { type: !1 } : C, e, _, Wx(e, g)))
    const k = E.animation
    k && p.push(k)
  }
  return (
    d &&
      Promise.all(p).then(() => {
        un.update(() => {
          d && dU(e, d)
        })
      }),
    p
  )
}
function Yx(e, t, r = {}) {
  var a
  const o = cg(
    e,
    t,
    r.type === 'exit' ? ((a = e.presenceContext) === null || a === void 0 ? void 0 : a.custom) : void 0
  )
  let { transition: u = e.getDefaultTransition() || {} } = o || {}
  r.transitionOverride && (u = r.transitionOverride)
  const l = o ? () => Promise.all(aD(e, o, r)) : () => Promise.resolve(),
    d =
      e.variantChildren && e.variantChildren.size
        ? (p = 0) => {
            const { delayChildren: v = 0, staggerChildren: g, staggerDirection: E } = u
            return gU(e, t, v + p, g, E, r)
          }
        : () => Promise.resolve(),
    { when: h } = u
  if (h) {
    const [p, v] = h === 'beforeChildren' ? [l, d] : [d, l]
    return p().then(() => v())
  } else return Promise.all([l(), d(r.delay)])
}
function gU(e, t, r = 0, a = 0, o = 1, u) {
  const l = [],
    d = (e.variantChildren.size - 1) * a,
    h = o === 1 ? (p = 0) => p * a : (p = 0) => d - p * a
  return (
    Array.from(e.variantChildren)
      .sort(yU)
      .forEach((p, v) => {
        p.notify('AnimationStart', t),
          l.push(Yx(p, t, { ...u, delay: r + h(v) }).then(() => p.notify('AnimationComplete', t)))
      }),
    Promise.all(l)
  )
}
function yU(e, t) {
  return e.sortNodePosition(t)
}
function bU(e, t, r = {}) {
  e.notify('AnimationStart', t)
  let a
  if (Array.isArray(t)) {
    const o = t.map(u => Yx(e, u, r))
    a = Promise.all(o)
  } else if (typeof t == 'string') a = Yx(e, t, r)
  else {
    const o = typeof t == 'function' ? cg(e, t, r.custom) : t
    a = Promise.all(aD(e, o, r))
  }
  return a.then(() => {
    e.notify('AnimationComplete', t)
  })
}
const EU = [...AS].reverse(),
  xU = AS.length
function SU(e) {
  return t => Promise.all(t.map(({ animation: r, options: a }) => bU(e, r, a)))
}
function TU(e) {
  let t = SU(e),
    r = w_(),
    a = !0
  const o = h => (p, v) => {
    var g
    const E = cg(
      e,
      v,
      h === 'exit' ? ((g = e.presenceContext) === null || g === void 0 ? void 0 : g.custom) : void 0
    )
    if (E) {
      const { transition: x, transitionEnd: C, ..._ } = E
      p = { ...p, ..._, ...C }
    }
    return p
  }
  function u(h) {
    t = h(e)
  }
  function l(h) {
    const p = e.getProps(),
      v = e.getVariantContext(!0) || {},
      g = [],
      E = new Set()
    let x = {},
      C = 1 / 0
    for (let k = 0; k < xU; k++) {
      const R = EU[k],
        D = r[R],
        A = p[R] !== void 0 ? p[R] : v[R],
        L = sh(A),
        F = R === h ? D.isActive : null
      F === !1 && (C = k)
      let z = A === v[R] && A !== p[R] && L
      if (
        (z && a && e.manuallyAnimateOnMount && (z = !1),
        (D.protectedKeys = { ...x }),
        (!D.isActive && F === null) || (!A && !D.prevProp) || oh(A) || typeof A == 'boolean')
      )
        continue
      let $ = CU(D.prevProp, A) || (R === h && D.isActive && !z && L) || (k > C && L),
        Q = !1
      const ue = Array.isArray(A) ? A : [A]
      let se = ue.reduce(o(R), {})
      F === !1 && (se = {})
      const { prevResolvedValues: we = {} } = D,
        he = { ...we, ...se },
        G = ge => {
          ;($ = !0), E.has(ge) && ((Q = !0), E.delete(ge)), (D.needsAnimating[ge] = !0)
          const De = e.getValue(ge)
          De && (De.liveStyle = !1)
        }
      for (const ge in he) {
        const De = se[ge],
          de = we[ge]
        if (x.hasOwnProperty(ge)) continue
        let ve = !1
        Vx(De) && Vx(de) ? (ve = !EA(De, de)) : (ve = De !== de),
          ve
            ? De != null
              ? G(ge)
              : E.add(ge)
            : De !== void 0 && E.has(ge)
              ? G(ge)
              : (D.protectedKeys[ge] = !0)
      }
      ;(D.prevProp = A),
        (D.prevResolvedValues = se),
        D.isActive && (x = { ...x, ...se }),
        a && e.blockInitialAnimation && ($ = !1),
        $ && (!z || Q) && g.push(...ue.map(ge => ({ animation: ge, options: { type: R } })))
    }
    if (E.size) {
      const k = {}
      E.forEach(R => {
        const D = e.getBaseTarget(R),
          A = e.getValue(R)
        A && (A.liveStyle = !0), (k[R] = D ?? null)
      }),
        g.push({ animation: k })
    }
    let _ = !!g.length
    return (
      a && (p.initial === !1 || p.initial === p.animate) && !e.manuallyAnimateOnMount && (_ = !1),
      (a = !1),
      _ ? t(g) : Promise.resolve()
    )
  }
  function d(h, p) {
    var v
    if (r[h].isActive === p) return Promise.resolve()
    ;(v = e.variantChildren) === null ||
      v === void 0 ||
      v.forEach(E => {
        var x
        return (x = E.animationState) === null || x === void 0 ? void 0 : x.setActive(h, p)
      }),
      (r[h].isActive = p)
    const g = l(h)
    for (const E in r) r[E].protectedKeys = {}
    return g
  }
  return {
    animateChanges: l,
    setActive: d,
    setAnimateFunction: u,
    getState: () => r,
    reset: () => {
      ;(r = w_()), (a = !0)
    }
  }
}
function CU(e, t) {
  return typeof t == 'string' ? t !== e : Array.isArray(t) ? !EA(t, e) : !1
}
function hl(e = !1) {
  return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} }
}
function w_() {
  return {
    animate: hl(!0),
    whileInView: hl(),
    whileHover: hl(),
    whileTap: hl(),
    whileDrag: hl(),
    whileFocus: hl(),
    exit: hl()
  }
}
class Ms {
  constructor(t) {
    ;(this.isMounted = !1), (this.node = t)
  }
  update() {}
}
class wU extends Ms {
  constructor(t) {
    super(t), t.animationState || (t.animationState = TU(t))
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps()
    oh(t) && (this.unmountControls = t.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: t } = this.node.getProps(),
      { animate: r } = this.node.prevProps || {}
    t !== r && this.updateAnimationControlsSubscription()
  }
  unmount() {
    var t
    this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this)
  }
}
let RU = 0
class _U extends Ms {
  constructor() {
    super(...arguments), (this.id = RU++)
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: t, onExitComplete: r } = this.node.presenceContext,
      { isPresent: a } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || t === a) return
    const o = this.node.animationState.setActive('exit', !t)
    r && !t && o.then(() => r(this.id))
  }
  mount() {
    const { register: t } = this.node.presenceContext || {}
    t && (this.unmount = t(this.id))
  }
  unmount() {}
}
const OU = { animation: { Feature: wU }, exit: { Feature: _U } },
  oD = e =>
    e.pointerType === 'mouse' ? typeof e.button != 'number' || e.button <= 0 : e.isPrimary !== !1
function mg(e, t = 'page') {
  return { point: { x: e[`${t}X`], y: e[`${t}Y`] } }
}
const kU = e => t => oD(t) && e(t, mg(t))
function So(e, t, r, a = { passive: !0 }) {
  return e.addEventListener(t, r, a), () => e.removeEventListener(t, r)
}
function Ro(e, t, r, a) {
  return So(e, t, kU(r), a)
}
const R_ = (e, t) => Math.abs(e - t)
function AU(e, t) {
  const r = R_(e.x, t.x),
    a = R_(e.y, t.y)
  return Math.sqrt(r ** 2 + a ** 2)
}
class sD {
  constructor(t, r, { transformPagePoint: a, contextWindow: o, dragSnapToOrigin: u = !1 } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const g = KE(this.lastMoveEventInfo, this.history),
          E = this.startEvent !== null,
          x = AU(g.offset, { x: 0, y: 0 }) >= 3
        if (!E && !x) return
        const { point: C } = g,
          { timestamp: _ } = xr
        this.history.push({ ...C, timestamp: _ })
        const { onStart: k, onMove: R } = this.handlers
        E || (k && k(this.lastMoveEvent, g), (this.startEvent = this.lastMoveEvent)),
          R && R(this.lastMoveEvent, g)
      }),
      (this.handlePointerMove = (g, E) => {
        ;(this.lastMoveEvent = g),
          (this.lastMoveEventInfo = GE(E, this.transformPagePoint)),
          un.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (g, E) => {
        this.end()
        const { onEnd: x, onSessionEnd: C, resumeAnimation: _ } = this.handlers
        if ((this.dragSnapToOrigin && _ && _(), !(this.lastMoveEvent && this.lastMoveEventInfo))) return
        const k = KE(
          g.type === 'pointercancel' ? this.lastMoveEventInfo : GE(E, this.transformPagePoint),
          this.history
        )
        this.startEvent && x && x(g, k), C && C(g, k)
      }),
      !oD(t))
    )
      return
    ;(this.dragSnapToOrigin = u),
      (this.handlers = r),
      (this.transformPagePoint = a),
      (this.contextWindow = o || window)
    const l = mg(t),
      d = GE(l, this.transformPagePoint),
      { point: h } = d,
      { timestamp: p } = xr
    this.history = [{ ...h, timestamp: p }]
    const { onSessionStart: v } = r
    v && v(t, KE(d, this.history)),
      (this.removeListeners = wo(
        Ro(this.contextWindow, 'pointermove', this.handlePointerMove),
        Ro(this.contextWindow, 'pointerup', this.handlePointerUp),
        Ro(this.contextWindow, 'pointercancel', this.handlePointerUp)
      ))
  }
  updateHandlers(t) {
    this.handlers = t
  }
  end() {
    this.removeListeners && this.removeListeners(), Oo(this.updatePoint)
  }
}
function GE(e, t) {
  return t ? { point: t(e.point) } : e
}
function __(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function KE({ point: e }, t) {
  return { point: e, delta: __(e, lD(t)), offset: __(e, DU(t)), velocity: NU(t, 0.1) }
}
function DU(e) {
  return e[0]
}
function lD(e) {
  return e[e.length - 1]
}
function NU(e, t) {
  if (e.length < 2) return { x: 0, y: 0 }
  let r = e.length - 1,
    a = null
  const o = lD(e)
  for (; r >= 0 && ((a = e[r]), !(o.timestamp - a.timestamp > $a(t))); ) r--
  if (!a) return { x: 0, y: 0 }
  const u = To(o.timestamp - a.timestamp)
  if (u === 0) return { x: 0, y: 0 }
  const l = { x: (o.x - a.x) / u, y: (o.y - a.y) / u }
  return l.x === 1 / 0 && (l.x = 0), l.y === 1 / 0 && (l.y = 0), l
}
function uD(e) {
  let t = null
  return () => {
    const r = () => {
      t = null
    }
    return t === null ? ((t = e), r) : !1
  }
}
const O_ = uD('dragHorizontal'),
  k_ = uD('dragVertical')
function cD(e) {
  let t = !1
  if (e === 'y') t = k_()
  else if (e === 'x') t = O_()
  else {
    const r = O_(),
      a = k_()
    r && a
      ? (t = () => {
          r(), a()
        })
      : (r && r(), a && a())
  }
  return t
}
function fD() {
  const e = cD(!0)
  return e ? (e(), !1) : !0
}
function Ju(e) {
  return e && typeof e == 'object' && Object.prototype.hasOwnProperty.call(e, 'current')
}
const dD = 1e-4,
  MU = 1 - dD,
  LU = 1 + dD,
  hD = 0.01,
  PU = 0 - hD,
  IU = 0 + hD
function ki(e) {
  return e.max - e.min
}
function FU(e, t, r) {
  return Math.abs(e - t) <= r
}
function A_(e, t, r, a = 0.5) {
  ;(e.origin = a),
    (e.originPoint = kn(t.min, t.max, e.origin)),
    (e.scale = ki(r) / ki(t)),
    (e.translate = kn(r.min, r.max, e.origin) - e.originPoint),
    ((e.scale >= MU && e.scale <= LU) || isNaN(e.scale)) && (e.scale = 1),
    ((e.translate >= PU && e.translate <= IU) || isNaN(e.translate)) && (e.translate = 0)
}
function Jd(e, t, r, a) {
  A_(e.x, t.x, r.x, a ? a.originX : void 0), A_(e.y, t.y, r.y, a ? a.originY : void 0)
}
function D_(e, t, r) {
  ;(e.min = r.min + t.min), (e.max = e.min + ki(t))
}
function VU(e, t, r) {
  D_(e.x, t.x, r.x), D_(e.y, t.y, r.y)
}
function N_(e, t, r) {
  ;(e.min = t.min - r.min), (e.max = e.min + ki(t))
}
function eh(e, t, r) {
  N_(e.x, t.x, r.x), N_(e.y, t.y, r.y)
}
function jU(e, { min: t, max: r }, a) {
  return (
    t !== void 0 && e < t
      ? (e = a ? kn(t, e, a.min) : Math.max(e, t))
      : r !== void 0 && e > r && (e = a ? kn(r, e, a.max) : Math.min(e, r)),
    e
  )
}
function M_(e, t, r) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: r !== void 0 ? e.max + r - (e.max - e.min) : void 0
  }
}
function UU(e, { top: t, left: r, bottom: a, right: o }) {
  return { x: M_(e.x, r, o), y: M_(e.y, t, a) }
}
function L_(e, t) {
  let r = t.min - e.min,
    a = t.max - e.max
  return t.max - t.min < e.max - e.min && ([r, a] = [a, r]), { min: r, max: a }
}
function $U(e, t) {
  return { x: L_(e.x, t.x), y: L_(e.y, t.y) }
}
function BU(e, t) {
  let r = 0.5
  const a = ki(e),
    o = ki(t)
  return (
    o > a ? (r = uh(t.min, t.max - a, e.min)) : a > o && (r = uh(e.min, e.max - o, t.min)), Ts(0, 1, r)
  )
}
function zU(e, t) {
  const r = {}
  return t.min !== void 0 && (r.min = t.min - e.min), t.max !== void 0 && (r.max = t.max - e.min), r
}
const qx = 0.35
function HU(e = qx) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = qx), { x: P_(e, 'left', 'right'), y: P_(e, 'top', 'bottom') }
  )
}
function P_(e, t, r) {
  return { min: I_(e, t), max: I_(e, r) }
}
function I_(e, t) {
  return typeof e == 'number' ? e : e[t] || 0
}
const F_ = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  ec = () => ({ x: F_(), y: F_() }),
  V_ = () => ({ min: 0, max: 0 }),
  jn = () => ({ x: V_(), y: V_() })
function zi(e) {
  return [e('x'), e('y')]
}
function pD({ top: e, left: t, right: r, bottom: a }) {
  return { x: { min: t, max: r }, y: { min: e, max: a } }
}
function WU({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min }
}
function YU(e, t) {
  if (!t) return e
  const r = t({ x: e.left, y: e.top }),
    a = t({ x: e.right, y: e.bottom })
  return { top: r.y, left: r.x, bottom: a.y, right: a.x }
}
function ZE(e) {
  return e === void 0 || e === 1
}
function Gx({ scale: e, scaleX: t, scaleY: r }) {
  return !ZE(e) || !ZE(t) || !ZE(r)
}
function ml(e) {
  return Gx(e) || mD(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function mD(e) {
  return j_(e.x) || j_(e.y)
}
function j_(e) {
  return e && e !== '0%'
}
function zv(e, t, r) {
  const a = e - r,
    o = t * a
  return r + o
}
function U_(e, t, r, a, o) {
  return o !== void 0 && (e = zv(e, o, a)), zv(e, r, a) + t
}
function Kx(e, t = 0, r = 1, a, o) {
  ;(e.min = U_(e.min, t, r, a, o)), (e.max = U_(e.max, t, r, a, o))
}
function vD(e, { x: t, y: r }) {
  Kx(e.x, t.translate, t.scale, t.originPoint), Kx(e.y, r.translate, r.scale, r.originPoint)
}
const $_ = 0.999999999999,
  B_ = 1.0000000000001
function qU(e, t, r, a = !1) {
  const o = r.length
  if (!o) return
  t.x = t.y = 1
  let u, l
  for (let d = 0; d < o; d++) {
    ;(u = r[d]), (l = u.projectionDelta)
    const { visualElement: h } = u.options
    ;(h && h.props.style && h.props.style.display === 'contents') ||
      (a &&
        u.options.layoutScroll &&
        u.scroll &&
        u !== u.root &&
        nc(e, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }),
      l && ((t.x *= l.x.scale), (t.y *= l.y.scale), vD(e, l)),
      a && ml(u.latestValues) && nc(e, u.latestValues))
  }
  t.x < B_ && t.x > $_ && (t.x = 1), t.y < B_ && t.y > $_ && (t.y = 1)
}
function tc(e, t) {
  ;(e.min = e.min + t), (e.max = e.max + t)
}
function z_(e, t, r, a, o = 0.5) {
  const u = kn(e.min, e.max, o)
  Kx(e, t, r, u, a)
}
function nc(e, t) {
  z_(e.x, t.x, t.scaleX, t.scale, t.originX), z_(e.y, t.y, t.scaleY, t.scale, t.originY)
}
function gD(e, t) {
  return pD(YU(e.getBoundingClientRect(), t))
}
function GU(e, t, r) {
  const a = gD(e, r),
    { scroll: o } = t
  return o && (tc(a.x, o.offset.x), tc(a.y, o.offset.y)), a
}
const yD = ({ current: e }) => (e ? e.ownerDocument.defaultView : null),
  KU = new WeakMap()
class ZU {
  constructor(t) {
    ;(this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = jn()),
      (this.visualElement = t)
  }
  start(t, { snapToCursor: r = !1 } = {}) {
    const { presenceContext: a } = this.visualElement
    if (a && a.isPresent === !1) return
    const o = v => {
        const { dragSnapToOrigin: g } = this.getProps()
        g ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(mg(v, 'page').point)
      },
      u = (v, g) => {
        var E
        const { drag: x, dragPropagation: C, onDragStart: _ } = this.getProps()
        if (
          x &&
          !C &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = cD(x)),
          !this.openGlobalLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          zi(R => {
            let D = this.getAxisMotionValue(R).get() || 0
            if (Ba.test(D)) {
              const { projection: A } = this.visualElement
              if (A && A.layout) {
                const L = A.layout.layoutBox[R]
                L && (D = ki(L) * (parseFloat(D) / 100))
              }
            }
            this.originPoint[R] = D
          }),
          _ && un.postRender(() => _(v, g)),
          (E = this.removeWillChange) === null || E === void 0 || E.call(this),
          (this.removeWillChange = Wx(this.visualElement, 'transform'))
        const { animationState: k } = this.visualElement
        k && k.setActive('whileDrag', !0)
      },
      l = (v, g) => {
        const {
          dragPropagation: E,
          dragDirectionLock: x,
          onDirectionLock: C,
          onDrag: _
        } = this.getProps()
        if (!E && !this.openGlobalLock) return
        const { offset: k } = g
        if (x && this.currentDirection === null) {
          ;(this.currentDirection = XU(k)),
            this.currentDirection !== null && C && C(this.currentDirection)
          return
        }
        this.updateAxis('x', g.point, k),
          this.updateAxis('y', g.point, k),
          this.visualElement.render(),
          _ && _(v, g)
      },
      d = (v, g) => this.stop(v, g),
      h = () =>
        zi(v => {
          var g
          return (
            this.getAnimationState(v) === 'paused' &&
            ((g = this.getAxisMotionValue(v).animation) === null || g === void 0 ? void 0 : g.play())
          )
        }),
      { dragSnapToOrigin: p } = this.getProps()
    this.panSession = new sD(
      t,
      { onSessionStart: o, onStart: u, onMove: l, onSessionEnd: d, resumeAnimation: h },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: p,
        contextWindow: yD(this.visualElement)
      }
    )
  }
  stop(t, r) {
    var a
    ;(a = this.removeWillChange) === null || a === void 0 || a.call(this)
    const o = this.isDragging
    if ((this.cancel(), !o)) return
    const { velocity: u } = r
    this.startAnimation(u)
    const { onDragEnd: l } = this.getProps()
    l && un.postRender(() => l(t, r))
  }
  cancel() {
    this.isDragging = !1
    const { projection: t, animationState: r } = this.visualElement
    t && (t.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: a } = this.getProps()
    !a && this.openGlobalLock && (this.openGlobalLock(), (this.openGlobalLock = null)),
      r && r.setActive('whileDrag', !1)
  }
  updateAxis(t, r, a) {
    const { drag: o } = this.getProps()
    if (!a || !gv(t, o, this.currentDirection)) return
    const u = this.getAxisMotionValue(t)
    let l = this.originPoint[t] + a[t]
    this.constraints && this.constraints[t] && (l = jU(l, this.constraints[t], this.elastic[t])),
      u.set(l)
  }
  resolveConstraints() {
    var t
    const { dragConstraints: r, dragElastic: a } = this.getProps(),
      o =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (t = this.visualElement.projection) === null || t === void 0
            ? void 0
            : t.layout,
      u = this.constraints
    r && Ju(r)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : r && o
        ? (this.constraints = UU(o.layoutBox, r))
        : (this.constraints = !1),
      (this.elastic = HU(a)),
      u !== this.constraints &&
        o &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        zi(l => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(l) &&
            (this.constraints[l] = zU(o.layoutBox[l], this.constraints[l]))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: r } = this.getProps()
    if (!t || !Ju(t)) return !1
    const a = t.current
    Ss(
      a !== null,
      "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
    )
    const { projection: o } = this.visualElement
    if (!o || !o.layout) return !1
    const u = GU(a, o.root, this.visualElement.getTransformPagePoint())
    let l = $U(o.layout.layoutBox, u)
    if (r) {
      const d = r(WU(l))
      ;(this.hasMutatedConstraints = !!d), d && (l = pD(d))
    }
    return l
  }
  startAnimation(t) {
    const {
        drag: r,
        dragMomentum: a,
        dragElastic: o,
        dragTransition: u,
        dragSnapToOrigin: l,
        onDragTransitionEnd: d
      } = this.getProps(),
      h = this.constraints || {},
      p = zi(v => {
        if (!gv(v, r, this.currentDirection)) return
        let g = (h && h[v]) || {}
        l && (g = { min: 0, max: 0 })
        const E = o ? 200 : 1e6,
          x = o ? 40 : 1e7,
          C = {
            type: 'inertia',
            velocity: a ? t[v] : 0,
            bounceStiffness: E,
            bounceDamping: x,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...u,
            ...g
          }
        return this.startAxisValueAnimation(v, C)
      })
    return Promise.all(p).then(d)
  }
  startAxisValueAnimation(t, r) {
    const a = this.getAxisMotionValue(t)
    return a.start(HS(t, a, 0, r, this.visualElement, !1, Wx(this.visualElement, t)))
  }
  stopAnimation() {
    zi(t => this.getAxisMotionValue(t).stop())
  }
  pauseAnimation() {
    zi(t => {
      var r
      return (r = this.getAxisMotionValue(t).animation) === null || r === void 0 ? void 0 : r.pause()
    })
  }
  getAnimationState(t) {
    var r
    return (r = this.getAxisMotionValue(t).animation) === null || r === void 0 ? void 0 : r.state
  }
  getAxisMotionValue(t) {
    const r = `_drag${t.toUpperCase()}`,
      a = this.visualElement.getProps(),
      o = a[r]
    return o || this.visualElement.getValue(t, (a.initial ? a.initial[t] : void 0) || 0)
  }
  snapToCursor(t) {
    zi(r => {
      const { drag: a } = this.getProps()
      if (!gv(r, a, this.currentDirection)) return
      const { projection: o } = this.visualElement,
        u = this.getAxisMotionValue(r)
      if (o && o.layout) {
        const { min: l, max: d } = o.layout.layoutBox[r]
        u.set(t[r] - kn(l, d, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: t, dragConstraints: r } = this.getProps(),
      { projection: a } = this.visualElement
    if (!Ju(r) || !a || !this.constraints) return
    this.stopAnimation()
    const o = { x: 0, y: 0 }
    zi(l => {
      const d = this.getAxisMotionValue(l)
      if (d && this.constraints !== !1) {
        const h = d.get()
        o[l] = BU({ min: h, max: h }, this.constraints[l])
      }
    })
    const { transformTemplate: u } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = u ? u({}, '') : 'none'),
      a.root && a.root.updateScroll(),
      a.updateLayout(),
      this.resolveConstraints(),
      zi(l => {
        if (!gv(l, t, null)) return
        const d = this.getAxisMotionValue(l),
          { min: h, max: p } = this.constraints[l]
        d.set(kn(h, p, o[l]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    KU.set(this.visualElement, this)
    const t = this.visualElement.current,
      r = Ro(t, 'pointerdown', h => {
        const { drag: p, dragListener: v = !0 } = this.getProps()
        p && v && this.start(h)
      }),
      a = () => {
        const { dragConstraints: h } = this.getProps()
        Ju(h) && h.current && (this.constraints = this.resolveRefConstraints())
      },
      { projection: o } = this.visualElement,
      u = o.addEventListener('measure', a)
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), un.read(a)
    const l = So(window, 'resize', () => this.scalePositionWithinConstraints()),
      d = o.addEventListener('didUpdate', ({ delta: h, hasLayoutChanged: p }) => {
        this.isDragging &&
          p &&
          (zi(v => {
            const g = this.getAxisMotionValue(v)
            g && ((this.originPoint[v] += h[v].translate), g.set(g.get() + h[v].translate))
          }),
          this.visualElement.render())
      })
    return () => {
      l(), r(), u(), d && d()
    }
  }
  getProps() {
    const t = this.visualElement.getProps(),
      {
        drag: r = !1,
        dragDirectionLock: a = !1,
        dragPropagation: o = !1,
        dragConstraints: u = !1,
        dragElastic: l = qx,
        dragMomentum: d = !0
      } = t
    return {
      ...t,
      drag: r,
      dragDirectionLock: a,
      dragPropagation: o,
      dragConstraints: u,
      dragElastic: l,
      dragMomentum: d
    }
  }
}
function gv(e, t, r) {
  return (t === !0 || t === e) && (r === null || r === e)
}
function XU(e, t = 10) {
  let r = null
  return Math.abs(e.y) > t ? (r = 'y') : Math.abs(e.x) > t && (r = 'x'), r
}
class QU extends Ms {
  constructor(t) {
    super(t), (this.removeGroupControls = Tr), (this.removeListeners = Tr), (this.controls = new ZU(t))
  }
  mount() {
    const { dragControls: t } = this.node.getProps()
    t && (this.removeGroupControls = t.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Tr)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const H_ = e => (t, r) => {
  e && un.postRender(() => e(t, r))
}
class JU extends Ms {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Tr)
  }
  onPointerDown(t) {
    this.session = new sD(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: yD(this.node)
    })
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: r, onPan: a, onPanEnd: o } = this.node.getProps()
    return {
      onSessionStart: H_(t),
      onStart: H_(r),
      onMove: a,
      onEnd: (u, l) => {
        delete this.session, o && un.postRender(() => o(u, l))
      }
    }
  }
  mount() {
    this.removePointerDownListener = Ro(this.node.current, 'pointerdown', t => this.onPointerDown(t))
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
const YS = w.createContext(null)
function e$() {
  const e = w.useContext(YS)
  if (e === null) return [!0, null]
  const { isPresent: t, onExitComplete: r, register: a } = e,
    o = w.useId()
  w.useEffect(() => a(o), [])
  const u = w.useCallback(() => r && r(o), [o, r])
  return !t && r ? [!1, u] : [!0]
}
const Hv = w.createContext({}),
  bD = w.createContext({}),
  _v = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function W_(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100
}
const Ld = {
    correct: (e, t) => {
      if (!t.target) return e
      if (typeof e == 'string')
        if (it.test(e)) e = parseFloat(e)
        else return e
      const r = W_(e, t.target.x),
        a = W_(e, t.target.y)
      return `${r}% ${a}%`
    }
  },
  t$ = {
    correct: (e, { treeScale: t, projectionDelta: r }) => {
      const a = e,
        o = Cs.parse(e)
      if (o.length > 5) return a
      const u = Cs.createTransformer(e),
        l = typeof o[0] != 'number' ? 1 : 0,
        d = r.x.scale * t.x,
        h = r.y.scale * t.y
      ;(o[0 + l] /= d), (o[1 + l] /= h)
      const p = kn(d, h, 0.5)
      return (
        typeof o[2 + l] == 'number' && (o[2 + l] /= p),
        typeof o[3 + l] == 'number' && (o[3 + l] /= p),
        u(o)
      )
    }
  },
  Wv = {}
function n$(e) {
  Object.assign(Wv, e)
}
const { schedule: qS, cancel: gZ } = xA(queueMicrotask, !1)
class r$ extends w.Component {
  componentDidMount() {
    const { visualElement: t, layoutGroup: r, switchLayoutGroup: a, layoutId: o } = this.props,
      { projection: u } = t
    n$(i$),
      u &&
        (r.group && r.group.add(u),
        a && a.register && o && a.register(u),
        u.root.didUpdate(),
        u.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        u.setOptions({ ...u.options, onExitComplete: () => this.safeToRemove() })),
      (_v.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: r, visualElement: a, drag: o, isPresent: u } = this.props,
      l = a.projection
    return (
      l &&
        ((l.isPresent = u),
        o || t.layoutDependency !== r || r === void 0 ? l.willUpdate() : this.safeToRemove(),
        t.isPresent !== u &&
          (u
            ? l.promote()
            : l.relegate() ||
              un.postRender(() => {
                const d = l.getStack()
                ;(!d || !d.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement
    t &&
      (t.root.didUpdate(),
      qS.postRender(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: r, switchLayoutGroup: a } = this.props,
      { projection: o } = t
    o &&
      (o.scheduleCheckAfterUnmount(),
      r && r.group && r.group.remove(o),
      a && a.deregister && a.deregister(o))
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props
    t && t()
  }
  render() {
    return null
  }
}
function ED(e) {
  const [t, r] = e$(),
    a = w.useContext(Hv)
  return dt.jsx(r$, {
    ...e,
    layoutGroup: a,
    switchLayoutGroup: w.useContext(bD),
    isPresent: t,
    safeToRemove: r
  })
}
const i$ = {
    borderRadius: {
      ...Ld,
      applyTo: [
        'borderTopLeftRadius',
        'borderTopRightRadius',
        'borderBottomLeftRadius',
        'borderBottomRightRadius'
      ]
    },
    borderTopLeftRadius: Ld,
    borderTopRightRadius: Ld,
    borderBottomLeftRadius: Ld,
    borderBottomRightRadius: Ld,
    boxShadow: t$
  },
  xD = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  a$ = xD.length,
  Y_ = e => (typeof e == 'string' ? parseFloat(e) : e),
  q_ = e => typeof e == 'number' || it.test(e)
function o$(e, t, r, a, o, u) {
  o
    ? ((e.opacity = kn(0, r.opacity !== void 0 ? r.opacity : 1, s$(a))),
      (e.opacityExit = kn(t.opacity !== void 0 ? t.opacity : 1, 0, l$(a))))
    : u &&
      (e.opacity = kn(t.opacity !== void 0 ? t.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, a))
  for (let l = 0; l < a$; l++) {
    const d = `border${xD[l]}Radius`
    let h = G_(t, d),
      p = G_(r, d)
    if (h === void 0 && p === void 0) continue
    h || (h = 0),
      p || (p = 0),
      h === 0 || p === 0 || q_(h) === q_(p)
        ? ((e[d] = Math.max(kn(Y_(h), Y_(p), a), 0)), (Ba.test(p) || Ba.test(h)) && (e[d] += '%'))
        : (e[d] = p)
  }
  ;(t.rotate || r.rotate) && (e.rotate = kn(t.rotate || 0, r.rotate || 0, a))
}
function G_(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius
}
const s$ = SD(0, 0.5, qA),
  l$ = SD(0.5, 0.95, Tr)
function SD(e, t, r) {
  return a => (a < e ? 0 : a > t ? 1 : r(uh(e, t, a)))
}
function K_(e, t) {
  ;(e.min = t.min), (e.max = t.max)
}
function Bi(e, t) {
  K_(e.x, t.x), K_(e.y, t.y)
}
function Z_(e, t) {
  ;(e.translate = t.translate),
    (e.scale = t.scale),
    (e.originPoint = t.originPoint),
    (e.origin = t.origin)
}
function X_(e, t, r, a, o) {
  return (e -= t), (e = zv(e, 1 / r, a)), o !== void 0 && (e = zv(e, 1 / o, a)), e
}
function u$(e, t = 0, r = 1, a = 0.5, o, u = e, l = e) {
  if (
    (Ba.test(t) && ((t = parseFloat(t)), (t = kn(l.min, l.max, t / 100) - l.min)), typeof t != 'number')
  )
    return
  let d = kn(u.min, u.max, a)
  e === u && (d -= t), (e.min = X_(e.min, t, r, d, o)), (e.max = X_(e.max, t, r, d, o))
}
function Q_(e, t, [r, a, o], u, l) {
  u$(e, t[r], t[a], t[o], t.scale, u, l)
}
const c$ = ['x', 'scaleX', 'originX'],
  f$ = ['y', 'scaleY', 'originY']
function J_(e, t, r, a) {
  Q_(e.x, t, c$, r ? r.x : void 0, a ? a.x : void 0), Q_(e.y, t, f$, r ? r.y : void 0, a ? a.y : void 0)
}
function eO(e) {
  return e.translate === 0 && e.scale === 1
}
function TD(e) {
  return eO(e.x) && eO(e.y)
}
function tO(e, t) {
  return e.min === t.min && e.max === t.max
}
function d$(e, t) {
  return tO(e.x, t.x) && tO(e.y, t.y)
}
function nO(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function CD(e, t) {
  return nO(e.x, t.x) && nO(e.y, t.y)
}
function rO(e) {
  return ki(e.x) / ki(e.y)
}
function iO(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class h$ {
  constructor() {
    this.members = []
  }
  add(t) {
    dg(this.members, t), t.scheduleRender()
  }
  remove(t) {
    if ((hg(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead)) {
      const r = this.members[this.members.length - 1]
      r && this.promote(r)
    }
  }
  relegate(t) {
    const r = this.members.findIndex(o => t === o)
    if (r === 0) return !1
    let a
    for (let o = r; o >= 0; o--) {
      const u = this.members[o]
      if (u.isPresent !== !1) {
        a = u
        break
      }
    }
    return a ? (this.promote(a), !0) : !1
  }
  promote(t, r) {
    const a = this.lead
    if (t !== a && ((this.prevLead = a), (this.lead = t), t.show(), a)) {
      a.instance && a.scheduleRender(),
        t.scheduleRender(),
        (t.resumeFrom = a),
        r && (t.resumeFrom.preserveOpacity = !0),
        a.snapshot &&
          ((t.snapshot = a.snapshot), (t.snapshot.latestValues = a.animationValues || a.latestValues)),
        t.root && t.root.isUpdating && (t.isLayoutDirty = !0)
      const { crossfade: o } = t.options
      o === !1 && a.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach(t => {
      const { options: r, resumingFrom: a } = t
      r.onExitComplete && r.onExitComplete(), a && a.options.onExitComplete && a.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach(t => {
      t.instance && t.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function p$(e, t, r) {
  let a = ''
  const o = e.x.translate / t.x,
    u = e.y.translate / t.y,
    l = (r == null ? void 0 : r.z) || 0
  if (
    ((o || u || l) && (a = `translate3d(${o}px, ${u}px, ${l}px) `),
    (t.x !== 1 || t.y !== 1) && (a += `scale(${1 / t.x}, ${1 / t.y}) `),
    r)
  ) {
    const { transformPerspective: p, rotate: v, rotateX: g, rotateY: E, skewX: x, skewY: C } = r
    p && (a = `perspective(${p}px) ${a}`),
      v && (a += `rotate(${v}deg) `),
      g && (a += `rotateX(${g}deg) `),
      E && (a += `rotateY(${E}deg) `),
      x && (a += `skewX(${x}deg) `),
      C && (a += `skewY(${C}deg) `)
  }
  const d = e.x.scale * t.x,
    h = e.y.scale * t.y
  return (d !== 1 || h !== 1) && (a += `scale(${d}, ${h})`), a || 'none'
}
const m$ = (e, t) => e.depth - t.depth
class v$ {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(t) {
    dg(this.children, t), (this.isDirty = !0)
  }
  remove(t) {
    hg(this.children, t), (this.isDirty = !0)
  }
  forEach(t) {
    this.isDirty && this.children.sort(m$), (this.isDirty = !1), this.children.forEach(t)
  }
}
function Ov(e) {
  const t = Ir(e) ? e.get() : e
  return lU(t) ? t.toValue() : t
}
function g$(e, t) {
  const r = Co.now(),
    a = ({ timestamp: o }) => {
      const u = o - r
      u >= t && (Oo(a), e(u - t))
    }
  return un.read(a, !0), () => Oo(a)
}
function y$(e) {
  return e instanceof SVGElement && e.tagName !== 'svg'
}
function b$(e, t, r) {
  const a = Ir(e) ? e : ch(e)
  return a.start(HS('', a, t, r)), a.animation
}
const vl = {
    type: 'projectionFrame',
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
  },
  zd = typeof window < 'u' && window.MotionDebug !== void 0,
  XE = ['', 'X', 'Y', 'Z'],
  E$ = { visibility: 'hidden' },
  aO = 1e3
let x$ = 0
function QE(e, t, r, a) {
  const { latestValues: o } = t
  o[e] && ((r[e] = o[e]), t.setStaticValue(e, 0), a && (a[e] = 0))
}
function wD(e) {
  if (((e.hasCheckedOptimisedAppear = !0), e.root === e)) return
  const { visualElement: t } = e.options
  if (!t) return
  const r = rD(t)
  if (window.MotionHasOptimisedAnimation(r, 'transform')) {
    const { layout: o, layoutId: u } = e.options
    window.MotionCancelOptimisedAnimation(r, 'transform', un, !(o || u))
  }
  const { parent: a } = e
  a && !a.hasCheckedOptimisedAppear && wD(a)
}
function RD({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: r,
  checkIsScrollRoot: a,
  resetTransform: o
}) {
  return class {
    constructor(l = {}, d = t == null ? void 0 : t()) {
      ;(this.id = x$++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(this.projectionUpdateScheduled = !1),
            zd && (vl.totalNodes = vl.resolvedTargetDeltas = vl.recalculatedProjection = 0),
            this.nodes.forEach(C$),
            this.nodes.forEach(k$),
            this.nodes.forEach(A$),
            this.nodes.forEach(w$),
            zd && window.MotionDebug.record(vl)
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = l),
        (this.root = d ? d.root || d : this),
        (this.path = d ? [...d.path, d] : []),
        (this.parent = d),
        (this.depth = d ? d.depth + 1 : 0)
      for (let h = 0; h < this.path.length; h++) this.path[h].shouldResetTransform = !0
      this.root === this && (this.nodes = new v$())
    }
    addEventListener(l, d) {
      return (
        this.eventHandlers.has(l) || this.eventHandlers.set(l, new WS()),
        this.eventHandlers.get(l).add(d)
      )
    }
    notifyListeners(l, ...d) {
      const h = this.eventHandlers.get(l)
      h && h.notify(...d)
    }
    hasListeners(l) {
      return this.eventHandlers.has(l)
    }
    mount(l, d = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;(this.isSVG = y$(l)), (this.instance = l)
      const { layoutId: h, layout: p, visualElement: v } = this.options
      if (
        (v && !v.current && v.mount(l),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        d && (p || h) && (this.isLayoutDirty = !0),
        e)
      ) {
        let g
        const E = () => (this.root.updateBlockedByResize = !1)
        e(l, () => {
          ;(this.root.updateBlockedByResize = !0),
            g && g(),
            (g = g$(E, 250)),
            _v.hasAnimatedSinceResize && ((_v.hasAnimatedSinceResize = !1), this.nodes.forEach(sO))
        })
      }
      h && this.root.registerSharedNode(h, this),
        this.options.animate !== !1 &&
          v &&
          (h || p) &&
          this.addEventListener(
            'didUpdate',
            ({ delta: g, hasLayoutChanged: E, hasRelativeTargetChanged: x, layout: C }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const _ = this.options.transition || v.getDefaultTransition() || P$,
                { onLayoutAnimationStart: k, onLayoutAnimationComplete: R } = v.getProps(),
                D = !this.targetLayout || !CD(this.targetLayout, C) || x,
                A = !E && x
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                A ||
                (E && (D || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom), (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(g, A)
                const L = { ...NS(_, 'layout'), onPlay: k, onComplete: R }
                ;(v.shouldReduceMotion || this.options.layoutRoot) && ((L.delay = 0), (L.type = !1)),
                  this.startAnimation(L)
              } else
                E || sO(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete()
              this.targetLayout = C
            }
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const l = this.getStack()
      l && l.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Oo(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(D$), this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: l } = this.options
      return l && l.getProps().transformTemplate
    }
    willUpdate(l = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && wD(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let v = 0; v < this.path.length; v++) {
        const g = this.path[v]
        ;(g.shouldResetTransform = !0),
          g.updateScroll('snapshot'),
          g.options.layoutRoot && g.willUpdate(!1)
      }
      const { layoutId: d, layout: h } = this.options
      if (d === void 0 && !h) return
      const p = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = p ? p(this.latestValues, '') : void 0),
        this.updateSnapshot(),
        l && this.notifyListeners('willUpdate')
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(oO)
        return
      }
      this.isUpdating || this.nodes.forEach(_$),
        (this.isUpdating = !1),
        this.nodes.forEach(O$),
        this.nodes.forEach(S$),
        this.nodes.forEach(T$),
        this.clearAllSnapshots()
      const d = Co.now()
      ;(xr.delta = Ts(0, 1e3 / 60, d - xr.timestamp)),
        (xr.timestamp = d),
        (xr.isProcessing = !0),
        zE.update.process(xr),
        zE.preRender.process(xr),
        zE.render.process(xr),
        (xr.isProcessing = !1)
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), qS.read(this.scheduleUpdate))
    }
    clearAllSnapshots() {
      this.nodes.forEach(R$), this.sharedNodes.forEach(N$)
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), un.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      un.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll()
      const l = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = jn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox)
      const { visualElement: d } = this.options
      d && d.notify('LayoutMeasure', this.layout.layoutBox, l ? l.layoutBox : void 0)
    }
    updateScroll(l = 'measure') {
      let d = !!(this.options.layoutScroll && this.instance)
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === l &&
          (d = !1),
        d)
      ) {
        const h = a(this.instance)
        this.scroll = {
          animationId: this.root.animationId,
          phase: l,
          isRoot: h,
          offset: r(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : h
        }
      }
    }
    resetTransform() {
      if (!o) return
      const l = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        d = this.projectionDelta && !TD(this.projectionDelta),
        h = this.getTransformTemplate(),
        p = h ? h(this.latestValues, '') : void 0,
        v = p !== this.prevTransformTemplateValue
      l &&
        (d || ml(this.latestValues) || v) &&
        (o(this.instance, p), (this.shouldResetTransform = !1), this.scheduleRender())
    }
    measure(l = !0) {
      const d = this.measurePageBox()
      let h = this.removeElementScroll(d)
      return (
        l && (h = this.removeTransform(h)),
        I$(h),
        {
          animationId: this.root.animationId,
          measuredBox: d,
          layoutBox: h,
          latestValues: {},
          source: this.id
        }
      )
    }
    measurePageBox() {
      var l
      const { visualElement: d } = this.options
      if (!d) return jn()
      const h = d.measureViewportBox()
      if (!(((l = this.scroll) === null || l === void 0 ? void 0 : l.wasRoot) || this.path.some(F$))) {
        const { scroll: v } = this.root
        v && (tc(h.x, v.offset.x), tc(h.y, v.offset.y))
      }
      return h
    }
    removeElementScroll(l) {
      var d
      const h = jn()
      if ((Bi(h, l), !((d = this.scroll) === null || d === void 0) && d.wasRoot)) return h
      for (let p = 0; p < this.path.length; p++) {
        const v = this.path[p],
          { scroll: g, options: E } = v
        v !== this.root &&
          g &&
          E.layoutScroll &&
          (g.wasRoot && Bi(h, l), tc(h.x, g.offset.x), tc(h.y, g.offset.y))
      }
      return h
    }
    applyTransform(l, d = !1) {
      const h = jn()
      Bi(h, l)
      for (let p = 0; p < this.path.length; p++) {
        const v = this.path[p]
        !d &&
          v.options.layoutScroll &&
          v.scroll &&
          v !== v.root &&
          nc(h, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }),
          ml(v.latestValues) && nc(h, v.latestValues)
      }
      return ml(this.latestValues) && nc(h, this.latestValues), h
    }
    removeTransform(l) {
      const d = jn()
      Bi(d, l)
      for (let h = 0; h < this.path.length; h++) {
        const p = this.path[h]
        if (!p.instance || !ml(p.latestValues)) continue
        Gx(p.latestValues) && p.updateSnapshot()
        const v = jn(),
          g = p.measurePageBox()
        Bi(v, g), J_(d, p.latestValues, p.snapshot ? p.snapshot.layoutBox : void 0, v)
      }
      return ml(this.latestValues) && J_(d, this.latestValues), d
    }
    setTargetDelta(l) {
      ;(this.targetDelta = l), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0)
    }
    setOptions(l) {
      this.options = { ...this.options, ...l, crossfade: l.crossfade !== void 0 ? l.crossfade : !0 }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== xr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(l = !1) {
      var d
      const h = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty)
      const p = !!this.resumingFrom || this !== h
      if (
        !(
          l ||
          (p && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((d = this.parent) === null || d === void 0) && d.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return
      const { layout: g, layoutId: E } = this.options
      if (!(!this.layout || !(g || E))) {
        if (
          ((this.resolvedRelativeTargetAt = xr.timestamp), !this.targetDelta && !this.relativeTarget)
        ) {
          const x = this.getClosestProjectingParent()
          x && x.layout && this.animationProgress !== 1
            ? ((this.relativeParent = x),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = jn()),
              (this.relativeTargetOrigin = jn()),
              eh(this.relativeTargetOrigin, this.layout.layoutBox, x.layout.layoutBox),
              Bi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target || ((this.target = jn()), (this.targetWithTransforms = jn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                VU(this.target, this.relativeTarget, this.relativeParent.target))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : Bi(this.target, this.layout.layoutBox),
                  vD(this.target, this.targetDelta))
                : Bi(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const x = this.getClosestProjectingParent()
            x &&
            !!x.resumingFrom == !!this.resumingFrom &&
            !x.options.layoutScroll &&
            x.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = x),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = jn()),
                (this.relativeTargetOrigin = jn()),
                eh(this.relativeTargetOrigin, this.target, x.target),
                Bi(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          zd && vl.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Gx(this.parent.latestValues) || mD(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
    }
    calcProjection() {
      var l
      const d = this.getLead(),
        h = !!this.resumingFrom || this !== d
      let p = !0
      if (
        ((this.isProjectionDirty ||
          (!((l = this.parent) === null || l === void 0) && l.isProjectionDirty)) &&
          (p = !1),
        h && (this.isSharedProjectionDirty || this.isTransformDirty) && (p = !1),
        this.resolvedRelativeTargetAt === xr.timestamp && (p = !1),
        p)
      )
        return
      const { layout: v, layoutId: g } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(v || g))
      )
        return
      Bi(this.layoutCorrected, this.layout.layoutBox)
      const E = this.treeScale.x,
        x = this.treeScale.y
      qU(this.layoutCorrected, this.treeScale, this.path, h),
        d.layout &&
          !d.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((d.target = d.layout.layoutBox), (d.targetWithTransforms = jn()))
      const { target: C } = d
      if (!C) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender())
        return
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Z_(this.prevProjectionDelta.x, this.projectionDelta.x),
          Z_(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Jd(this.projectionDelta, this.layoutCorrected, C, this.latestValues),
        (this.treeScale.x !== E ||
          this.treeScale.y !== x ||
          !iO(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !iO(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0), this.scheduleRender(), this.notifyListeners('projectionUpdate', C)),
        zd && vl.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(l = !0) {
      var d
      if (((d = this.options.visualElement) === null || d === void 0 || d.scheduleRender(), l)) {
        const h = this.getStack()
        h && h.scheduleRender()
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
    }
    createProjectionDeltas() {
      ;(this.prevProjectionDelta = ec()),
        (this.projectionDelta = ec()),
        (this.projectionDeltaWithTransform = ec())
    }
    setAnimationOrigin(l, d = !1) {
      const h = this.snapshot,
        p = h ? h.latestValues : {},
        v = { ...this.latestValues },
        g = ec()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !d)
      const E = jn(),
        x = h ? h.source : void 0,
        C = this.layout ? this.layout.source : void 0,
        _ = x !== C,
        k = this.getStack(),
        R = !k || k.members.length <= 1,
        D = !!(_ && !R && this.options.crossfade === !0 && !this.path.some(L$))
      this.animationProgress = 0
      let A
      ;(this.mixTargetDelta = L => {
        const F = L / 1e3
        lO(g.x, l.x, F),
          lO(g.y, l.y, F),
          this.setTargetDelta(g),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (eh(E, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            M$(this.relativeTarget, this.relativeTargetOrigin, E, F),
            A && d$(this.relativeTarget, A) && (this.isProjectionDirty = !1),
            A || (A = jn()),
            Bi(A, this.relativeTarget)),
          _ && ((this.animationValues = v), o$(v, p, this.latestValues, F, D, R)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = F)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(l) {
      this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation && (Oo(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = un.update(() => {
          ;(_v.hasAnimatedSinceResize = !0),
            (this.currentAnimation = b$(0, aO, {
              ...l,
              onUpdate: d => {
                this.mixTargetDelta(d), l.onUpdate && l.onUpdate(d)
              },
              onComplete: () => {
                l.onComplete && l.onComplete(), this.completeAnimation()
              }
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0), (this.resumingFrom.preserveOpacity = void 0))
      const l = this.getStack()
      l && l.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners('animationComplete')
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(aO), this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const l = this.getLead()
      let { targetWithTransforms: d, target: h, layout: p, latestValues: v } = l
      if (!(!d || !h || !p)) {
        if (
          this !== l &&
          this.layout &&
          p &&
          _D(this.options.animationType, this.layout.layoutBox, p.layoutBox)
        ) {
          h = this.target || jn()
          const g = ki(this.layout.layoutBox.x)
          ;(h.x.min = l.target.x.min), (h.x.max = h.x.min + g)
          const E = ki(this.layout.layoutBox.y)
          ;(h.y.min = l.target.y.min), (h.y.max = h.y.min + E)
        }
        Bi(d, h), nc(d, v), Jd(this.projectionDeltaWithTransform, this.layoutCorrected, d, v)
      }
    }
    registerSharedNode(l, d) {
      this.sharedNodes.has(l) || this.sharedNodes.set(l, new h$()), this.sharedNodes.get(l).add(d)
      const p = d.options.initialPromotionConfig
      d.promote({
        transition: p ? p.transition : void 0,
        preserveFollowOpacity:
          p && p.shouldPreserveFollowOpacity ? p.shouldPreserveFollowOpacity(d) : void 0
      })
    }
    isLead() {
      const l = this.getStack()
      return l ? l.lead === this : !0
    }
    getLead() {
      var l
      const { layoutId: d } = this.options
      return d ? ((l = this.getStack()) === null || l === void 0 ? void 0 : l.lead) || this : this
    }
    getPrevLead() {
      var l
      const { layoutId: d } = this.options
      return d ? ((l = this.getStack()) === null || l === void 0 ? void 0 : l.prevLead) : void 0
    }
    getStack() {
      const { layoutId: l } = this.options
      if (l) return this.root.sharedNodes.get(l)
    }
    promote({ needsReset: l, transition: d, preserveFollowOpacity: h } = {}) {
      const p = this.getStack()
      p && p.promote(this, h),
        l && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        d && this.setOptions({ transition: d })
    }
    relegate() {
      const l = this.getStack()
      return l ? l.relegate(this) : !1
    }
    resetSkewAndRotation() {
      const { visualElement: l } = this.options
      if (!l) return
      let d = !1
      const { latestValues: h } = l
      if (
        ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (d = !0), !d)
      )
        return
      const p = {}
      h.z && QE('z', l, p, this.animationValues)
      for (let v = 0; v < XE.length; v++)
        QE(`rotate${XE[v]}`, l, p, this.animationValues), QE(`skew${XE[v]}`, l, p, this.animationValues)
      l.render()
      for (const v in p)
        l.setStaticValue(v, p[v]), this.animationValues && (this.animationValues[v] = p[v])
      l.scheduleRender()
    }
    getProjectionStyles(l) {
      var d, h
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return E$
      const p = { visibility: '' },
        v = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (p.opacity = ''),
          (p.pointerEvents = Ov(l == null ? void 0 : l.pointerEvents) || ''),
          (p.transform = v ? v(this.latestValues, '') : 'none'),
          p
        )
      const g = this.getLead()
      if (!this.projectionDelta || !this.layout || !g.target) {
        const _ = {}
        return (
          this.options.layoutId &&
            ((_.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
            (_.pointerEvents = Ov(l == null ? void 0 : l.pointerEvents) || '')),
          this.hasProjected &&
            !ml(this.latestValues) &&
            ((_.transform = v ? v({}, '') : 'none'), (this.hasProjected = !1)),
          _
        )
      }
      const E = g.animationValues || g.latestValues
      this.applyTransformsToTarget(),
        (p.transform = p$(this.projectionDeltaWithTransform, this.treeScale, E)),
        v && (p.transform = v(E, p.transform))
      const { x, y: C } = this.projectionDelta
      ;(p.transformOrigin = `${x.origin * 100}% ${C.origin * 100}% 0`),
        g.animationValues
          ? (p.opacity =
              g === this
                ? (h = (d = E.opacity) !== null && d !== void 0 ? d : this.latestValues.opacity) !==
                    null && h !== void 0
                  ? h
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : E.opacityExit)
          : (p.opacity =
              g === this
                ? E.opacity !== void 0
                  ? E.opacity
                  : ''
                : E.opacityExit !== void 0
                  ? E.opacityExit
                  : 0)
      for (const _ in Wv) {
        if (E[_] === void 0) continue
        const { correct: k, applyTo: R } = Wv[_],
          D = p.transform === 'none' ? E[_] : k(E[_], g)
        if (R) {
          const A = R.length
          for (let L = 0; L < A; L++) p[R[L]] = D
        } else p[_] = D
      }
      return (
        this.options.layoutId &&
          (p.pointerEvents = g === this ? Ov(l == null ? void 0 : l.pointerEvents) || '' : 'none'),
        p
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach(l => {
        var d
        return (d = l.currentAnimation) === null || d === void 0 ? void 0 : d.stop()
      }),
        this.root.nodes.forEach(oO),
        this.root.sharedNodes.clear()
    }
  }
}
function S$(e) {
  e.updateLayout()
}
function T$(e) {
  var t
  const r = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot
  if (e.isLead() && e.layout && r && e.hasListeners('didUpdate')) {
    const { layoutBox: a, measuredBox: o } = e.layout,
      { animationType: u } = e.options,
      l = r.source !== e.layout.source
    u === 'size'
      ? zi(g => {
          const E = l ? r.measuredBox[g] : r.layoutBox[g],
            x = ki(E)
          ;(E.min = a[g].min), (E.max = E.min + x)
        })
      : _D(u, r.layoutBox, a) &&
        zi(g => {
          const E = l ? r.measuredBox[g] : r.layoutBox[g],
            x = ki(a[g])
          ;(E.max = E.min + x),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0), (e.relativeTarget[g].max = e.relativeTarget[g].min + x))
        })
    const d = ec()
    Jd(d, a, r.layoutBox)
    const h = ec()
    l ? Jd(h, e.applyTransform(o, !0), r.measuredBox) : Jd(h, a, r.layoutBox)
    const p = !TD(d)
    let v = !1
    if (!e.resumeFrom) {
      const g = e.getClosestProjectingParent()
      if (g && !g.resumeFrom) {
        const { snapshot: E, layout: x } = g
        if (E && x) {
          const C = jn()
          eh(C, r.layoutBox, E.layoutBox)
          const _ = jn()
          eh(_, a, x.layoutBox),
            CD(C, _) || (v = !0),
            g.options.layoutRoot &&
              ((e.relativeTarget = _), (e.relativeTargetOrigin = C), (e.relativeParent = g))
        }
      }
    }
    e.notifyListeners('didUpdate', {
      layout: a,
      snapshot: r,
      delta: h,
      layoutDelta: d,
      hasLayoutChanged: p,
      hasRelativeTargetChanged: v
    })
  } else if (e.isLead()) {
    const { onExitComplete: a } = e.options
    a && a()
  }
  e.options.transition = void 0
}
function C$(e) {
  zd && vl.totalNodes++,
    e.parent &&
      (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
      e.isSharedProjectionDirty ||
        (e.isSharedProjectionDirty = !!(
          e.isProjectionDirty ||
          e.parent.isProjectionDirty ||
          e.parent.isSharedProjectionDirty
        )),
      e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function w$(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function R$(e) {
  e.clearSnapshot()
}
function oO(e) {
  e.clearMeasurements()
}
function _$(e) {
  e.isLayoutDirty = !1
}
function O$(e) {
  const { visualElement: t } = e.options
  t && t.getProps().onBeforeLayoutMeasure && t.notify('BeforeLayoutMeasure'), e.resetTransform()
}
function sO(e) {
  e.finishAnimation(), (e.targetDelta = e.relativeTarget = e.target = void 0), (e.isProjectionDirty = !0)
}
function k$(e) {
  e.resolveTargetDelta()
}
function A$(e) {
  e.calcProjection()
}
function D$(e) {
  e.resetSkewAndRotation()
}
function N$(e) {
  e.removeLeadSnapshot()
}
function lO(e, t, r) {
  ;(e.translate = kn(t.translate, 0, r)),
    (e.scale = kn(t.scale, 1, r)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint)
}
function uO(e, t, r, a) {
  ;(e.min = kn(t.min, r.min, a)), (e.max = kn(t.max, r.max, a))
}
function M$(e, t, r, a) {
  uO(e.x, t.x, r.x, a), uO(e.y, t.y, r.y, a)
}
function L$(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0
}
const P$ = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  cO = e =>
    typeof navigator < 'u' && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
  fO = cO('applewebkit/') && !cO('chrome/') ? Math.round : Tr
function dO(e) {
  ;(e.min = fO(e.min)), (e.max = fO(e.max))
}
function I$(e) {
  dO(e.x), dO(e.y)
}
function _D(e, t, r) {
  return e === 'position' || (e === 'preserve-aspect' && !FU(rO(t), rO(r), 0.2))
}
function F$(e) {
  var t
  return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
const V$ = RD({
    attachResizeListener: (e, t) => So(e, 'resize', t),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
  }),
  JE = { current: void 0 },
  OD = RD({
    measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }),
    defaultParent: () => {
      if (!JE.current) {
        const e = new V$({})
        e.mount(window), e.setOptions({ layoutScroll: !0 }), (JE.current = e)
      }
      return JE.current
    },
    resetTransform: (e, t) => {
      e.style.transform = t !== void 0 ? t : 'none'
    },
    checkIsScrollRoot: e => window.getComputedStyle(e).position === 'fixed'
  }),
  j$ = { pan: { Feature: JU }, drag: { Feature: QU, ProjectionNode: OD, MeasureLayout: ED } }
function hO(e, t) {
  const r = t ? 'pointerenter' : 'pointerleave',
    a = t ? 'onHoverStart' : 'onHoverEnd',
    o = (u, l) => {
      if (u.pointerType === 'touch' || fD()) return
      const d = e.getProps()
      e.animationState && d.whileHover && e.animationState.setActive('whileHover', t)
      const h = d[a]
      h && un.postRender(() => h(u, l))
    }
  return Ro(e.current, r, o, { passive: !e.getProps()[a] })
}
class U$ extends Ms {
  mount() {
    this.unmount = wo(hO(this.node, !0), hO(this.node, !1))
  }
  unmount() {}
}
class $$ extends Ms {
  constructor() {
    super(...arguments), (this.isActive = !1)
  }
  onFocus() {
    let t = !1
    try {
      t = this.node.current.matches(':focus-visible')
    } catch {
      t = !0
    }
    !t ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0), (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1), (this.isActive = !1))
  }
  mount() {
    this.unmount = wo(
      So(this.node.current, 'focus', () => this.onFocus()),
      So(this.node.current, 'blur', () => this.onBlur())
    )
  }
  unmount() {}
}
const kD = (e, t) => (t ? (e === t ? !0 : kD(e, t.parentElement)) : !1)
function ex(e, t) {
  if (!t) return
  const r = new PointerEvent('pointer' + e)
  t(r, mg(r))
}
class B$ extends Ms {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = Tr),
      (this.removeEndListeners = Tr),
      (this.removeAccessibleListeners = Tr),
      (this.startPointerPress = (t, r) => {
        if (this.isPressing) return
        this.removeEndListeners()
        const a = this.node.getProps(),
          u = Ro(
            window,
            'pointerup',
            (d, h) => {
              if (!this.checkPressEnd()) return
              const { onTap: p, onTapCancel: v, globalTapTarget: g } = this.node.getProps(),
                E = !g && !kD(this.node.current, d.target) ? v : p
              E && un.update(() => E(d, h))
            },
            { passive: !(a.onTap || a.onPointerUp) }
          ),
          l = Ro(window, 'pointercancel', (d, h) => this.cancelPress(d, h), {
            passive: !(a.onTapCancel || a.onPointerCancel)
          })
        ;(this.removeEndListeners = wo(u, l)), this.startPress(t, r)
      }),
      (this.startAccessiblePress = () => {
        const t = u => {
            if (u.key !== 'Enter' || this.isPressing) return
            const l = d => {
              d.key !== 'Enter' ||
                !this.checkPressEnd() ||
                ex('up', (h, p) => {
                  const { onTap: v } = this.node.getProps()
                  v && un.postRender(() => v(h, p))
                })
            }
            this.removeEndListeners(),
              (this.removeEndListeners = So(this.node.current, 'keyup', l)),
              ex('down', (d, h) => {
                this.startPress(d, h)
              })
          },
          r = So(this.node.current, 'keydown', t),
          a = () => {
            this.isPressing && ex('cancel', (u, l) => this.cancelPress(u, l))
          },
          o = So(this.node.current, 'blur', a)
        this.removeAccessibleListeners = wo(r, o)
      })
  }
  startPress(t, r) {
    this.isPressing = !0
    const { onTapStart: a, whileTap: o } = this.node.getProps()
    o && this.node.animationState && this.node.animationState.setActive('whileTap', !0),
      a && un.postRender(() => a(t, r))
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive('whileTap', !1),
      !fD()
    )
  }
  cancelPress(t, r) {
    if (!this.checkPressEnd()) return
    const { onTapCancel: a } = this.node.getProps()
    a && un.postRender(() => a(t, r))
  }
  mount() {
    const t = this.node.getProps(),
      r = Ro(t.globalTapTarget ? window : this.node.current, 'pointerdown', this.startPointerPress, {
        passive: !(t.onTapStart || t.onPointerStart)
      }),
      a = So(this.node.current, 'focus', this.startAccessiblePress)
    this.removeStartListeners = wo(r, a)
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
  }
}
const Zx = new WeakMap(),
  tx = new WeakMap(),
  z$ = e => {
    const t = Zx.get(e.target)
    t && t(e)
  },
  H$ = e => {
    e.forEach(z$)
  }
function W$({ root: e, ...t }) {
  const r = e || document
  tx.has(r) || tx.set(r, {})
  const a = tx.get(r),
    o = JSON.stringify(t)
  return a[o] || (a[o] = new IntersectionObserver(H$, { root: e, ...t })), a[o]
}
function Y$(e, t, r) {
  const a = W$(t)
  return (
    Zx.set(e, r),
    a.observe(e),
    () => {
      Zx.delete(e), a.unobserve(e)
    }
  )
}
const q$ = { some: 0, all: 1 }
class G$ extends Ms {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: t = {} } = this.node.getProps(),
      { root: r, margin: a, amount: o = 'some', once: u } = t,
      l = { root: r ? r.current : void 0, rootMargin: a, threshold: typeof o == 'number' ? o : q$[o] },
      d = h => {
        const { isIntersecting: p } = h
        if (this.isInView === p || ((this.isInView = p), u && !p && this.hasEnteredView)) return
        p && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive('whileInView', p)
        const { onViewportEnter: v, onViewportLeave: g } = this.node.getProps(),
          E = p ? v : g
        E && E(h)
      }
    return Y$(this.node.current, l, d)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: t, prevProps: r } = this.node
    ;['amount', 'margin', 'root'].some(K$(t, r)) && this.startObserver()
  }
  unmount() {}
}
function K$({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return r => e[r] !== t[r]
}
const Z$ = {
    inView: { Feature: G$ },
    tap: { Feature: B$ },
    focus: { Feature: $$ },
    hover: { Feature: U$ }
  },
  X$ = { layout: { ProjectionNode: OD, MeasureLayout: ED } },
  AD = w.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: 'never' }),
  vg = w.createContext({}),
  GS = typeof window < 'u',
  DD = GS ? w.useLayoutEffect : w.useEffect,
  ND = w.createContext({ strict: !1 })
let pO = !1
function Q$(e, t, r, a, o) {
  var u
  const { visualElement: l } = w.useContext(vg),
    d = w.useContext(ND),
    h = w.useContext(YS),
    p = w.useContext(AD).reducedMotion,
    v = w.useRef()
  ;(a = a || d.renderer),
    !v.current &&
      a &&
      (v.current = a(e, {
        visualState: t,
        parent: l,
        props: r,
        presenceContext: h,
        blockInitialAnimation: h ? h.initial === !1 : !1,
        reducedMotionConfig: p
      }))
  const g = v.current,
    E = w.useContext(bD)
  g && !g.projection && o && (g.type === 'html' || g.type === 'svg') && eB(v.current, r, o, E),
    w.useInsertionEffect(() => {
      g && g.update(r, h)
    })
  const x = r[nD],
    C = w.useRef(
      !!x &&
        !window.MotionHandoffIsComplete &&
        ((u = window.MotionHasOptimisedAnimation) === null || u === void 0 ? void 0 : u.call(window, x))
    )
  return (
    DD(() => {
      g &&
        (g.updateFeatures(),
        qS.render(g.render),
        C.current && g.animationState && g.animationState.animateChanges())
    }),
    w.useEffect(() => {
      g &&
        (!C.current && g.animationState && g.animationState.animateChanges(),
        (C.current = !1),
        pO || ((pO = !0), queueMicrotask(J$)))
    }),
    g
  )
}
function J$() {
  window.MotionHandoffIsComplete = !0
}
function eB(e, t, r, a) {
  const { layoutId: o, layout: u, drag: l, dragConstraints: d, layoutScroll: h, layoutRoot: p } = t
  ;(e.projection = new r(e.latestValues, t['data-framer-portal-id'] ? void 0 : MD(e.parent))),
    e.projection.setOptions({
      layoutId: o,
      layout: u,
      alwaysMeasureLayout: !!l || (d && Ju(d)),
      visualElement: e,
      animationType: typeof u == 'string' ? u : 'both',
      initialPromotionConfig: a,
      layoutScroll: h,
      layoutRoot: p
    })
}
function MD(e) {
  if (e) return e.options.allowProjection !== !1 ? e.projection : MD(e.parent)
}
function tB(e, t, r) {
  return w.useCallback(
    a => {
      a && e.mount && e.mount(a),
        t && (a ? t.mount(a) : t.unmount()),
        r && (typeof r == 'function' ? r(a) : Ju(r) && (r.current = a))
    },
    [t]
  )
}
function gg(e) {
  return oh(e.animate) || DS.some(t => sh(e[t]))
}
function LD(e) {
  return !!(gg(e) || e.variants)
}
function nB(e, t) {
  if (gg(e)) {
    const { initial: r, animate: a } = e
    return { initial: r === !1 || sh(r) ? r : void 0, animate: sh(a) ? a : void 0 }
  }
  return e.inherit !== !1 ? t : {}
}
function rB(e) {
  const { initial: t, animate: r } = nB(e, w.useContext(vg))
  return w.useMemo(() => ({ initial: t, animate: r }), [mO(t), mO(r)])
}
function mO(e) {
  return Array.isArray(e) ? e.join(' ') : e
}
const vO = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag'
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId']
  },
  Oc = {}
for (const e in vO) Oc[e] = { isEnabled: t => vO[e].some(r => !!t[r]) }
function iB(e) {
  for (const t in e) Oc[t] = { ...Oc[t], ...e[t] }
}
const aB = Symbol.for('motionComponentSymbol')
function oB({
  preloadedFeatures: e,
  createVisualElement: t,
  useRender: r,
  useVisualState: a,
  Component: o
}) {
  e && iB(e)
  function u(d, h) {
    let p
    const v = { ...w.useContext(AD), ...d, layoutId: sB(d) },
      { isStatic: g } = v,
      E = rB(d),
      x = a(d, g)
    if (!g && GS) {
      lB(v, e)
      const C = uB(v)
      ;(p = C.MeasureLayout), (E.visualElement = Q$(o, x, v, t, C.ProjectionNode))
    }
    return dt.jsxs(vg.Provider, {
      value: E,
      children: [
        p && E.visualElement ? dt.jsx(p, { visualElement: E.visualElement, ...v }) : null,
        r(o, d, tB(x, E.visualElement, h), x, g, E.visualElement)
      ]
    })
  }
  const l = w.forwardRef(u)
  return (l[aB] = o), l
}
function sB({ layoutId: e }) {
  const t = w.useContext(Hv).id
  return t && e !== void 0 ? t + '-' + e : e
}
function lB(e, t) {
  const r = w.useContext(ND).strict
  if (t && r) {
    const a =
      'You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.'
    e.ignoreStrict ? Pc(!1, a) : Ss(!1, a)
  }
}
function uB(e) {
  const { drag: t, layout: r } = Oc
  if (!t && !r) return {}
  const a = { ...t, ...r }
  return {
    MeasureLayout:
      (t != null && t.isEnabled(e)) || (r != null && r.isEnabled(e)) ? a.MeasureLayout : void 0,
    ProjectionNode: a.ProjectionNode
  }
}
const cB = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view'
]
function KS(e) {
  return typeof e != 'string' || e.includes('-') ? !1 : !!(cB.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function PD(e, { style: t, vars: r }, a, o) {
  Object.assign(e.style, t, o && o.getProjectionStyles(a))
  for (const u in r) e.style.setProperty(u, r[u])
}
const ID = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust'
])
function FD(e, t, r, a) {
  PD(e, t, void 0, a)
  for (const o in t.attrs) e.setAttribute(ID.has(o) ? o : pg(o), t.attrs[o])
}
function VD(e, { layout: t, layoutId: r }) {
  return Ns.has(e) || e.startsWith('origin') || ((t || r !== void 0) && (!!Wv[e] || e === 'opacity'))
}
function ZS(e, t, r) {
  var a
  const { style: o } = e,
    u = {}
  for (const l in o)
    (Ir(o[l]) ||
      (t.style && Ir(t.style[l])) ||
      VD(l, e) ||
      ((a = r == null ? void 0 : r.getValue(l)) === null || a === void 0 ? void 0 : a.liveStyle) !==
        void 0) &&
      (u[l] = o[l])
  return r && o && typeof o.willChange == 'string' && (r.applyWillChange = !1), u
}
function jD(e, t, r) {
  const a = ZS(e, t, r)
  for (const o in e)
    if (Ir(e[o]) || Ir(t[o])) {
      const u = Ph.indexOf(o) !== -1 ? 'attr' + o.charAt(0).toUpperCase() + o.substring(1) : o
      a[u] = e[o]
    }
  return a
}
function fB(e) {
  const t = w.useRef(null)
  return t.current === null && (t.current = e()), t.current
}
function dB(
  { applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: r, onMount: a },
  o,
  u,
  l,
  d
) {
  const h = { latestValues: pB(o, u, l, d ? !1 : e, t), renderState: r() }
  return a && (h.mount = p => a(o, p, h)), h
}
const UD = e => (t, r) => {
  const a = w.useContext(vg),
    o = w.useContext(YS),
    u = () => dB(e, t, a, o, r)
  return r ? u() : fB(u)
}
function hB(e, t) {
  const r = iD(t)
  r && dg(e, r)
}
function gO(e, t, r) {
  const a = Array.isArray(t) ? t : [t]
  for (let o = 0; o < a.length; o++) {
    const u = kS(e, a[o])
    if (u) {
      const { transitionEnd: l, transition: d, ...h } = u
      r(h, l)
    }
  }
}
function pB(e, t, r, a, o) {
  var u
  const l = {},
    d = [],
    h = a && ((u = e.style) === null || u === void 0 ? void 0 : u.willChange) === void 0,
    p = o(e, {})
  for (const k in p) l[k] = Ov(p[k])
  let { initial: v, animate: g } = e
  const E = gg(e),
    x = LD(e)
  t && x && !E && e.inherit !== !1 && (v === void 0 && (v = t.initial), g === void 0 && (g = t.animate))
  let C = r ? r.initial === !1 : !1
  C = C || v === !1
  const _ = C ? g : v
  return (
    _ &&
      typeof _ != 'boolean' &&
      !oh(_) &&
      gO(e, _, (k, R) => {
        for (const D in k) {
          let A = k[D]
          if (Array.isArray(A)) {
            const L = C ? A.length - 1 : 0
            A = A[L]
          }
          A !== null && (l[D] = A)
        }
        for (const D in R) l[D] = R[D]
      }),
    h &&
      (g &&
        v !== !1 &&
        !oh(g) &&
        gO(e, g, k => {
          for (const R in k) hB(d, R)
        }),
      d.length && (l.willChange = d.join(','))),
    l
  )
}
const XS = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }),
  $D = () => ({ ...XS(), attrs: {} }),
  BD = (e, t) => (t && typeof e == 'number' ? t.transform(e) : e),
  mB = { x: 'translateX', y: 'translateY', z: 'translateZ', transformPerspective: 'perspective' },
  vB = Ph.length
function gB(e, t, r) {
  let a = '',
    o = !0
  for (let u = 0; u < vB; u++) {
    const l = Ph[u],
      d = e[l]
    if (d === void 0) continue
    let h = !0
    if (
      (typeof d == 'number' ? (h = d === (l.startsWith('scale') ? 1 : 0)) : (h = parseFloat(d) === 0),
      !h || r)
    ) {
      const p = BD(d, FS[l])
      if (!h) {
        o = !1
        const v = mB[l] || l
        a += `${v}(${p}) `
      }
      r && (t[l] = p)
    }
  }
  return (a = a.trim()), r ? (a = r(t, o ? '' : a)) : o && (a = 'none'), a
}
function QS(e, t, r) {
  const { style: a, vars: o, transformOrigin: u } = e
  let l = !1,
    d = !1
  for (const h in t) {
    const p = t[h]
    if (Ns.has(h)) {
      l = !0
      continue
    } else if (wA(h)) {
      o[h] = p
      continue
    } else {
      const v = BD(p, FS[h])
      h.startsWith('origin') ? ((d = !0), (u[h] = v)) : (a[h] = v)
    }
  }
  if (
    (t.transform ||
      (l || r ? (a.transform = gB(t, e.transform, r)) : a.transform && (a.transform = 'none')),
    d)
  ) {
    const { originX: h = '50%', originY: p = '50%', originZ: v = 0 } = u
    a.transformOrigin = `${h} ${p} ${v}`
  }
}
function yO(e, t, r) {
  return typeof e == 'string' ? e : it.transform(t + r * e)
}
function yB(e, t, r) {
  const a = yO(t, e.x, e.width),
    o = yO(r, e.y, e.height)
  return `${a} ${o}`
}
const bB = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  EB = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function xB(e, t, r = 1, a = 0, o = !0) {
  e.pathLength = 1
  const u = o ? bB : EB
  e[u.offset] = it.transform(-a)
  const l = it.transform(t),
    d = it.transform(r)
  e[u.array] = `${l} ${d}`
}
function JS(
  e,
  {
    attrX: t,
    attrY: r,
    attrScale: a,
    originX: o,
    originY: u,
    pathLength: l,
    pathSpacing: d = 1,
    pathOffset: h = 0,
    ...p
  },
  v,
  g
) {
  if ((QS(e, p, g), v)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)
    return
  }
  ;(e.attrs = e.style), (e.style = {})
  const { attrs: E, style: x, dimensions: C } = e
  E.transform && (C && (x.transform = E.transform), delete E.transform),
    C &&
      (o !== void 0 || u !== void 0 || x.transform) &&
      (x.transformOrigin = yB(C, o !== void 0 ? o : 0.5, u !== void 0 ? u : 0.5)),
    t !== void 0 && (E.x = t),
    r !== void 0 && (E.y = r),
    a !== void 0 && (E.scale = a),
    l !== void 0 && xB(E, l, d, h, !1)
}
const e1 = e => typeof e == 'string' && e.toLowerCase() === 'svg',
  SB = {
    useVisualState: UD({
      scrapeMotionValuesFromProps: jD,
      createRenderState: $D,
      onMount: (e, t, { renderState: r, latestValues: a }) => {
        un.read(() => {
          try {
            r.dimensions = typeof t.getBBox == 'function' ? t.getBBox() : t.getBoundingClientRect()
          } catch {
            r.dimensions = { x: 0, y: 0, width: 0, height: 0 }
          }
        }),
          un.render(() => {
            JS(r, a, e1(t.tagName), e.transformTemplate), FD(t, r)
          })
      }
    })
  },
  TB = {
    useVisualState: UD({ applyWillChange: !0, scrapeMotionValuesFromProps: ZS, createRenderState: XS })
  }
function zD(e, t, r) {
  for (const a in t) !Ir(t[a]) && !VD(a, r) && (e[a] = t[a])
}
function CB({ transformTemplate: e }, t) {
  return w.useMemo(() => {
    const r = XS()
    return QS(r, t, e), Object.assign({}, r.vars, r.style)
  }, [t])
}
function wB(e, t) {
  const r = e.style || {},
    a = {}
  return zD(a, r, e), Object.assign(a, CB(e, t)), a
}
function RB(e, t) {
  const r = {},
    a = wB(e, t)
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((r.draggable = !1),
      (a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = 'none'),
      (a.touchAction = e.drag === !0 ? 'none' : `pan-${e.drag === 'x' ? 'y' : 'x'}`)),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0),
    (r.style = a),
    r
  )
}
const _B = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport'
])
function Yv(e) {
  return (
    e.startsWith('while') ||
    (e.startsWith('drag') && e !== 'draggable') ||
    e.startsWith('layout') ||
    e.startsWith('onTap') ||
    e.startsWith('onPan') ||
    e.startsWith('onLayout') ||
    _B.has(e)
  )
}
let HD = e => !Yv(e)
function OB(e) {
  e && (HD = t => (t.startsWith('on') ? !Yv(t) : e(t)))
}
try {
  OB(require('@emotion/is-prop-valid').default)
} catch {}
function kB(e, t, r) {
  const a = {}
  for (const o in e)
    (o === 'values' && typeof e.values == 'object') ||
      ((HD(o) || (r === !0 && Yv(o)) || (!t && !Yv(o)) || (e.draggable && o.startsWith('onDrag'))) &&
        (a[o] = e[o]))
  return a
}
function AB(e, t, r, a) {
  const o = w.useMemo(() => {
    const u = $D()
    return JS(u, t, e1(a), e.transformTemplate), { ...u.attrs, style: { ...u.style } }
  }, [t])
  if (e.style) {
    const u = {}
    zD(u, e.style, e), (o.style = { ...u, ...o.style })
  }
  return o
}
function DB(e = !1) {
  return (r, a, o, { latestValues: u }, l) => {
    const h = (KS(r) ? AB : RB)(a, u, l, r),
      p = kB(a, typeof r == 'string', e),
      v = r !== w.Fragment ? { ...p, ...h, ref: o } : {},
      { children: g } = a,
      E = w.useMemo(() => (Ir(g) ? g.get() : g), [g])
    return w.createElement(r, { ...v, children: E })
  }
}
function NB(e, t) {
  return function (a, { forwardMotionProps: o } = { forwardMotionProps: !1 }) {
    const l = {
      ...(KS(a) ? SB : TB),
      preloadedFeatures: e,
      useRender: DB(o),
      createVisualElement: t,
      Component: a
    }
    return oB(l)
  }
}
const Xx = { current: null },
  WD = { current: !1 }
function MB() {
  if (((WD.current = !0), !!GS))
    if (window.matchMedia) {
      const e = window.matchMedia('(prefers-reduced-motion)'),
        t = () => (Xx.current = e.matches)
      e.addListener(t), t()
    } else Xx.current = !1
}
function LB(e, t, r) {
  for (const a in t) {
    const o = t[a],
      u = r[a]
    if (Ir(o))
      e.addValue(a, o),
        ug(
          o.version === '11.5.4',
          `Attempting to mix Framer Motion versions ${o.version} with 11.5.4 may not work as expected.`
        )
    else if (Ir(u)) e.addValue(a, ch(o, { owner: e }))
    else if (u !== o)
      if (e.hasValue(a)) {
        const l = e.getValue(a)
        l.liveStyle === !0 ? l.jump(o) : l.hasAnimated || l.set(o)
      } else {
        const l = e.getStaticValue(a)
        e.addValue(a, ch(l !== void 0 ? l : o, { owner: e }))
      }
  }
  for (const a in r) t[a] === void 0 && e.removeValue(a)
  return t
}
const bO = new WeakMap(),
  PB = [...OA, Lr, Cs],
  IB = e => PB.find(_A(e)),
  EO = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete'
  ],
  FB = DS.length
class VB {
  scrapeMotionValuesFromProps(t, r, a) {
    return {}
  }
  constructor(
    {
      parent: t,
      props: r,
      presenceContext: a,
      reducedMotionConfig: o,
      blockInitialAnimation: u,
      visualState: l
    },
    d = {}
  ) {
    ;(this.applyWillChange = !1),
      (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = PS),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        ;(this.isRenderScheduled = !1),
          this.current &&
            (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }),
      (this.isRenderScheduled = !1),
      (this.scheduleRender = () => {
        this.isRenderScheduled || ((this.isRenderScheduled = !0), un.render(this.render, !1, !0))
      })
    const { latestValues: h, renderState: p } = l
    ;(this.latestValues = h),
      (this.baseTarget = { ...h }),
      (this.initialValues = r.initial ? { ...h } : {}),
      (this.renderState = p),
      (this.parent = t),
      (this.props = r),
      (this.presenceContext = a),
      (this.depth = t ? t.depth + 1 : 0),
      (this.reducedMotionConfig = o),
      (this.options = d),
      (this.blockInitialAnimation = !!u),
      (this.isControllingVariants = gg(r)),
      (this.isVariantNode = LD(r)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(t && t.current))
    const { willChange: v, ...g } = this.scrapeMotionValuesFromProps(r, {}, this)
    for (const E in g) {
      const x = g[E]
      h[E] !== void 0 && Ir(x) && x.set(h[E], !1)
    }
  }
  mount(t) {
    ;(this.current = t),
      bO.set(t, this),
      this.projection && !this.projection.instance && this.projection.mount(t),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((r, a) => this.bindToMotionValue(a, r)),
      WD.current || MB(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
            ? !0
            : Xx.current),
      ug(
        this.shouldReduceMotion !== !0,
        'You have Reduced Motion enabled on your device. Animations may not appear as expected.'
      ),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext)
  }
  unmount() {
    bO.delete(this.current),
      this.projection && this.projection.unmount(),
      Oo(this.notifyUpdate),
      Oo(this.render),
      this.valueSubscriptions.forEach(t => t()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this)
    for (const t in this.events) this.events[t].clear()
    for (const t in this.features) {
      const r = this.features[t]
      r && (r.unmount(), (r.isMounted = !1))
    }
    this.current = null
  }
  bindToMotionValue(t, r) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)()
    const a = Ns.has(t),
      o = r.on('change', d => {
        ;(this.latestValues[t] = d),
          this.props.onUpdate && un.preRender(this.notifyUpdate),
          a && this.projection && (this.projection.isTransformDirty = !0)
      }),
      u = r.on('renderRequest', this.scheduleRender)
    let l
    window.MotionCheckAppearSync && (l = window.MotionCheckAppearSync(this, t, r)),
      this.valueSubscriptions.set(t, () => {
        o(), u(), l && l(), r.owner && r.stop()
      })
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type
      ? 0
      : this.sortInstanceNodePosition(this.current, t.current)
  }
  updateFeatures() {
    let t = 'animation'
    for (t in Oc) {
      const r = Oc[t]
      if (!r) continue
      const { isEnabled: a, Feature: o } = r
      if (
        (!this.features[t] && o && a(this.props) && (this.features[t] = new o(this)), this.features[t])
      ) {
        const u = this.features[t]
        u.isMounted ? u.update() : (u.mount(), (u.isMounted = !0))
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : jn()
  }
  getStaticValue(t) {
    return this.latestValues[t]
  }
  setStaticValue(t, r) {
    this.latestValues[t] = r
  }
  update(t, r) {
    ;(t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = t),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = r)
    for (let a = 0; a < EO.length; a++) {
      const o = EO[a]
      this.propEventSubscriptions[o] &&
        (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o])
      const u = 'on' + o,
        l = t[u]
      l && (this.propEventSubscriptions[o] = this.on(o, l))
    }
    ;(this.prevMotionValues = LB(
      this,
      this.scrapeMotionValuesFromProps(t, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
    return this.props
  }
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  getVariantContext(t = !1) {
    if (t) return this.parent ? this.parent.getVariantContext() : void 0
    if (!this.isControllingVariants) {
      const a = this.parent ? this.parent.getVariantContext() || {} : {}
      return this.props.initial !== void 0 && (a.initial = this.props.initial), a
    }
    const r = {}
    for (let a = 0; a < FB; a++) {
      const o = DS[a],
        u = this.props[o]
      ;(sh(u) || u === !1) && (r[o] = u)
    }
    return r
  }
  addVariantChild(t) {
    const r = this.getClosestVariantNode()
    if (r) return r.variantChildren && r.variantChildren.add(t), () => r.variantChildren.delete(t)
  }
  addValue(t, r) {
    const a = this.values.get(t)
    r !== a &&
      (a && this.removeValue(t),
      this.bindToMotionValue(t, r),
      this.values.set(t, r),
      (this.latestValues[t] = r.get()))
  }
  removeValue(t) {
    this.values.delete(t)
    const r = this.valueSubscriptions.get(t)
    r && (r(), this.valueSubscriptions.delete(t)),
      delete this.latestValues[t],
      this.removeValueFromRenderState(t, this.renderState)
  }
  hasValue(t) {
    return this.values.has(t)
  }
  getValue(t, r) {
    if (this.props.values && this.props.values[t]) return this.props.values[t]
    let a = this.values.get(t)
    return (
      a === void 0 &&
        r !== void 0 &&
        ((a = ch(r === null ? void 0 : r, { owner: this })), this.addValue(t, a)),
      a
    )
  }
  readValue(t, r) {
    var a
    let o =
      this.latestValues[t] !== void 0 || !this.current
        ? this.latestValues[t]
        : (a = this.getBaseTargetFromProps(this.props, t)) !== null && a !== void 0
          ? a
          : this.readValueFromInstance(this.current, t, this.options)
    return (
      o != null &&
        (typeof o == 'string' && (TA(o) || SA(o))
          ? (o = parseFloat(o))
          : !IB(o) && Cs.test(r) && (o = IA(t, r)),
        this.setBaseTarget(t, Ir(o) ? o.get() : o)),
      Ir(o) ? o.get() : o
    )
  }
  setBaseTarget(t, r) {
    this.baseTarget[t] = r
  }
  getBaseTarget(t) {
    var r
    const { initial: a } = this.props
    let o
    if (typeof a == 'string' || typeof a == 'object') {
      const l = kS(
        this.props,
        a,
        (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom
      )
      l && (o = l[t])
    }
    if (a && o !== void 0) return o
    const u = this.getBaseTargetFromProps(this.props, t)
    return u !== void 0 && !Ir(u)
      ? u
      : this.initialValues[t] !== void 0 && o === void 0
        ? void 0
        : this.baseTarget[t]
  }
  on(t, r) {
    return this.events[t] || (this.events[t] = new WS()), this.events[t].add(r)
  }
  notify(t, ...r) {
    this.events[t] && this.events[t].notify(...r)
  }
}
class YD extends VB {
  constructor() {
    super(...arguments), (this.KeyframeResolver = FA)
  }
  sortInstanceNodePosition(t, r) {
    return t.compareDocumentPosition(r) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(t, r) {
    return t.style ? t.style[r] : void 0
  }
  removeValueFromRenderState(t, { vars: r, style: a }) {
    delete r[t], delete a[t]
  }
}
function jB(e) {
  return window.getComputedStyle(e)
}
class UB extends YD {
  constructor() {
    super(...arguments), (this.type = 'html'), (this.applyWillChange = !0), (this.renderInstance = PD)
  }
  readValueFromInstance(t, r) {
    if (Ns.has(r)) {
      const a = VS(r)
      return (a && a.default) || 0
    } else {
      const a = jB(t),
        o = (wA(r) ? a.getPropertyValue(r) : a[r]) || 0
      return typeof o == 'string' ? o.trim() : o
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: r }) {
    return gD(t, r)
  }
  build(t, r, a) {
    QS(t, r, a.transformTemplate)
  }
  scrapeMotionValuesFromProps(t, r, a) {
    return ZS(t, r, a)
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription)
    const { children: t } = this.props
    Ir(t) &&
      (this.childSubscription = t.on('change', r => {
        this.current && (this.current.textContent = `${r}`)
      }))
  }
}
class $B extends YD {
  constructor() {
    super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = jn)
  }
  getBaseTargetFromProps(t, r) {
    return t[r]
  }
  readValueFromInstance(t, r) {
    if (Ns.has(r)) {
      const a = VS(r)
      return (a && a.default) || 0
    }
    return (r = ID.has(r) ? r : pg(r)), t.getAttribute(r)
  }
  scrapeMotionValuesFromProps(t, r, a) {
    return jD(t, r, a)
  }
  build(t, r, a) {
    JS(t, r, this.isSVGTag, a.transformTemplate)
  }
  renderInstance(t, r, a, o) {
    FD(t, r, a, o)
  }
  mount(t) {
    ;(this.isSVGTag = e1(t.tagName)), super.mount(t)
  }
}
const BB = (e, t) => (KS(e) ? new $B(t) : new UB(t, { allowProjection: e !== w.Fragment })),
  zB = NB({ ...OU, ...Z$, ...j$, ...X$ }, BB),
  sc = T8(zB),
  HB = w.createContext(null)
function WB() {
  const e = w.useRef(!1)
  return (
    DD(
      () => (
        (e.current = !0),
        () => {
          e.current = !1
        }
      ),
      []
    ),
    e
  )
}
function YB() {
  const e = WB(),
    [t, r] = w.useState(0),
    a = w.useCallback(() => {
      e.current && r(t + 1)
    }, [t])
  return [w.useCallback(() => un.postRender(a), [a]), t]
}
const qB = e => !e.isLayoutDirty && e.willUpdate(!1)
function xO() {
  const e = new Set(),
    t = new WeakMap(),
    r = () => e.forEach(qB)
  return {
    add: a => {
      e.add(a), t.set(a, a.addEventListener('willUpdate', r))
    },
    remove: a => {
      e.delete(a)
      const o = t.get(a)
      o && (o(), t.delete(a)), r()
    },
    dirty: r
  }
}
const qD = e => e === !0,
  GB = e => qD(e === !0) || e === 'id',
  KB = ({ children: e, id: t, inherit: r = !0 }) => {
    const a = w.useContext(Hv),
      o = w.useContext(HB),
      [u, l] = YB(),
      d = w.useRef(null),
      h = a.id || o
    d.current === null &&
      (GB(r) && h && (t = t ? h + '-' + t : h),
      (d.current = { id: t, group: (qD(r) && a.group) || xO() }))
    const p = w.useMemo(() => ({ ...d.current, forceRender: u }), [l])
    return dt.jsx(Hv.Provider, { value: p, children: e })
  }
function ZB({ color: e = 'currentColor', width: t = '800px', height: r = '800px' }) {
  return le.jsxDEV(
    'svg',
    {
      fill: e,
      width: t,
      height: r,
      viewBox: '0 0 512 512',
      xmlns: 'http://www.w3.org/2000/svg',
      children: le.jsxDEV(
        'path',
        {
          d: 'M450.46,256.09C449.35,175.17,399.81,102.71,324,73.79,247.59,44.67,157.49,69,105.82,132.13,54.4,195,46.61,285.58,88.49,355.68c41.8,69.95,123.74,106,203.55,91.63,91-16.37,156.14-98.12,158.35-189.14A20.16,20.16,0,0,0,450.46,256.09ZM119.05,174.38C152.76,118,220.23,87,285,99.43c69.4,13.29,120.43,70.47,128.83,139H318.41c-8.26-27.36-32-48-62.62-48-29.65,0-55.15,20.65-63.11,48H97.74A158,158,0,0,1,119.05,174.38ZM286.13,256.1c-2,38.75-60.67,39.4-60.67,0S284.17,217.33,286.13,256.1Zm24,149.79C246.85,428.58,175,408.74,132.3,356.82a157.53,157.53,0,0,1-34.57-83H192.6c7.91,27.39,33.7,48,63.19,48,30.67,0,54.36-20.68,62.62-48h95.45C406.61,333,367.54,385.32,310.14,405.89Z'
        },
        void 0,
        !1,
        {
          fileName:
            '/Volumes/workspace/pokemon-frontend/src/components/loaders/card-skeleton-loader/pokeball-skeleton.tsx',
          lineNumber: 11,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName:
        '/Volumes/workspace/pokemon-frontend/src/components/loaders/card-skeleton-loader/pokeball-skeleton.tsx',
      lineNumber: 3,
      columnNumber: 5
    },
    this
  )
}
function XB({ totalCard: e = 1 }) {
  return Array.from({ length: e }).map((t, r) =>
    le.jsxDEV(
      'div',
      {
        'data-testid': 'card-skeleton-loader',
        className:
          'w-60 h-[258px] flex justify-center items-center shadow border border-slate-300 text-slate-400 bg-slate-300 dark:bg-slate-800 dark:text-slate-950 dark:border-slate-700 rounded-3xl animate-pulse ',
        children: le.jsxDEV(
          ZB,
          {},
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/loaders/card-skeleton-loader/card-skeleton-loader.tsx',
            lineNumber: 14,
            columnNumber: 7
          },
          this
        )
      },
      r,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/loaders/card-skeleton-loader/card-skeleton-loader.tsx',
        lineNumber: 9,
        columnNumber: 5
      },
      this
    )
  )
}
const QB =
  "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='200px'%20height='200px'%20viewBox='0%200%20100%20100'%20preserveAspectRatio='xMidYMid'%20style='background:%20none;%20display:%20block;%20margin:%20auto;'%3e%3c!--%20Outer%20spinning%20Pok%20Ball%20--%3e%3cg%3e%3ccircle%20cx='50'%20cy='50'%20r='45'%20fill='%23d81b26'%20/%3e%3cpath%20fill='%23ffffff'%20d='M50%205A45%2045%200%200%201%2095%2050H5A45%2045%200%200%201%2050%205z'%20/%3e%3cpath%20fill='%233d3d3d'%20d='M5%2050H95'%20/%3e%3ccircle%20cx='50'%20cy='50'%20r='45'%20fill='none'%20stroke='%233d3d3d'%20stroke-width='4'%20/%3e%3canimateTransform%20attributeName='transform'%20type='rotate'%20from='0%2050%2050'%20to='360%2050%2050'%20dur='1.2s'%20repeatCount='indefinite'%20keySplines='0.42%200%200.58%201'%20calcMode='spline'%20/%3e%3c/g%3e%3c!--%20Central%20button%20with%20pulse%20and%20glow%20effects%20--%3e%3cg%3e%3ccircle%20cx='50'%20cy='50'%20r='10'%20fill='%23ffffff'%20stroke='%233d3d3d'%20stroke-width='4'%3e%3canimate%20attributeName='r'%20from='8'%20to='10'%20dur='0.6s'%20repeatCount='indefinite'%20values='8;10;8'%20keyTimes='0;0.5;1'%20keySplines='0.42%200%200.58%201;0.42%200%200.58%201'%20calcMode='spline'%20/%3e%3c/circle%3e%3ccircle%20cx='50'%20cy='50'%20r='6'%20fill='%233d3d3d'%3e%3canimate%20attributeName='r'%20from='4'%20to='6'%20dur='0.6s'%20repeatCount='indefinite'%20values='4;6;4'%20keyTimes='0;0.5;1'%20keySplines='0.42%200%200.58%201;0.42%200%200.58%201'%20calcMode='spline'%20/%3e%3c/circle%3e%3ccircle%20cx='50'%20cy='50'%20r='16'%20fill='none'%20stroke='%23ffffff'%20stroke-width='2'%20opacity='0.6'%3e%3canimate%20attributeName='r'%20from='12'%20to='16'%20dur='1.2s'%20repeatCount='indefinite'%20values='12;16;12'%20keyTimes='0;0.5;1'%20keySplines='0.42%200%200.58%201;0.42%200%200.58%201'%20calcMode='spline'%20/%3e%3canimate%20attributeName='opacity'%20from='0.6'%20to='0.2'%20dur='1.2s'%20repeatCount='indefinite'%20values='0.6;0.2;0.6'%20keyTimes='0;0.5;1'%20keySplines='0.42%200%200.58%201;0.42%200%200.58%201'%20calcMode='spline'%20/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e"
function JB(e, t, r, a) {
  return new (r || (r = Promise))(function (o, u) {
    function l(p) {
      try {
        h(a.next(p))
      } catch (v) {
        u(v)
      }
    }
    function d(p) {
      try {
        h(a.throw(p))
      } catch (v) {
        u(v)
      }
    }
    function h(p) {
      var v
      p.done
        ? o(p.value)
        : ((v = p.value),
          v instanceof r
            ? v
            : new r(function (g) {
                g(v)
              })).then(l, d)
    }
    h((a = a.apply(e, [])).next())
  })
}
const SO = (e, t, r, a) => {
    e.style.transition = `${t} ${r}ms ${a}`
  },
  xo = (e, t, r) => Math.min(Math.max(e, t), r)
let ez = class {
    constructor(t, r) {
      ;(this.glareAngle = 0),
        (this.glareOpacity = 0),
        (this.calculateGlareSize = l => {
          const { width: d, height: h } = l,
            p = Math.sqrt(Math.pow(d, 2) + Math.pow(h, 2))
          return { width: p, height: p }
        }),
        (this.setSize = l => {
          const d = this.calculateGlareSize(l)
          ;(this.glareEl.style.width = `${d.width}px`), (this.glareEl.style.height = `${d.height}px`)
        }),
        (this.update = (l, d, h, p) => {
          this.updateAngle(l, d.glareReverse), this.updateOpacity(l, d, h, p)
        }),
        (this.updateAngle = (l, d) => {
          const { xPercentage: h, yPercentage: p } = l,
            v = 180 / Math.PI,
            g = h ? Math.atan2(p, -h) * v : 0
          this.glareAngle = g - (d ? 180 : 0)
        }),
        (this.updateOpacity = (l, d, h, p) => {
          const { xPercentage: v, yPercentage: g } = l,
            { glarePosition: E, glareReverse: x, glareMaxOpacity: C } = d,
            _ = h ? -1 : 1,
            k = p ? -1 : 1,
            R = x ? -1 : 1
          let D = 0
          switch (E) {
            case 'top':
              D = -v * _ * R
              break
            case 'right':
              D = g * k * R
              break
            case 'bottom':
            case void 0:
              D = v * _ * R
              break
            case 'left':
              D = -g * k * R
              break
            case 'all':
              D = Math.hypot(v, g)
          }
          const A = xo(D, 0, 100)
          this.glareOpacity = (A * C) / 100
        }),
        (this.render = l => {
          const { glareColor: d } = l
          ;(this.glareEl.style.transform = `rotate(${this.glareAngle}deg) translate(-50%, -50%)`),
            (this.glareEl.style.opacity = this.glareOpacity.toString()),
            (this.glareEl.style.background = `linear-gradient(0deg, rgba(255,255,255,0) 0%, ${d} 100%)`)
        }),
        (this.glareWrapperEl = document.createElement('div')),
        (this.glareEl = document.createElement('div')),
        this.glareWrapperEl.appendChild(this.glareEl),
        (this.glareWrapperEl.className = 'glare-wrapper'),
        (this.glareEl.className = 'glare')
      const a = {
          position: 'absolute',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          overflow: 'hidden',
          borderRadius: r,
          WebkitMaskImage: '-webkit-radial-gradient(white, black)',
          pointerEvents: 'none'
        },
        o = this.calculateGlareSize(t),
        u = {
          position: 'absolute',
          top: '50%',
          left: '50%',
          transformOrigin: '0% 0%',
          pointerEvents: 'none',
          width: `${o.width}px`,
          height: `${o.height}px`
        }
      Object.assign(this.glareWrapperEl.style, a), Object.assign(this.glareEl.style, u)
    }
  },
  tz = class {
    constructor() {
      ;(this.glareAngle = 0),
        (this.glareOpacity = 0),
        (this.tiltAngleX = 0),
        (this.tiltAngleY = 0),
        (this.tiltAngleXPercentage = 0),
        (this.tiltAngleYPercentage = 0),
        (this.update = (t, r) => {
          this.updateTilt(t, r),
            this.updateTiltManualInput(t, r),
            this.updateTiltReverse(r),
            this.updateTiltLimits(r)
        }),
        (this.updateTilt = (t, r) => {
          const { xPercentage: a, yPercentage: o } = t,
            { tiltMaxAngleX: u, tiltMaxAngleY: l } = r
          ;(this.tiltAngleX = (a * u) / 100), (this.tiltAngleY = ((o * l) / 100) * -1)
        }),
        (this.updateTiltManualInput = (t, r) => {
          const { tiltAngleXManual: a, tiltAngleYManual: o, tiltMaxAngleX: u, tiltMaxAngleY: l } = r
          ;(a !== null || o !== null) &&
            ((this.tiltAngleX = a !== null ? a : 0),
            (this.tiltAngleY = o !== null ? o : 0),
            (t.xPercentage = (100 * this.tiltAngleX) / u),
            (t.yPercentage = (100 * this.tiltAngleY) / l))
        }),
        (this.updateTiltReverse = t => {
          const r = t.tiltReverse ? -1 : 1
          ;(this.tiltAngleX = r * this.tiltAngleX), (this.tiltAngleY = r * this.tiltAngleY)
        }),
        (this.updateTiltLimits = t => {
          const { tiltAxis: r } = t
          ;(this.tiltAngleX = xo(this.tiltAngleX, -90, 90)),
            (this.tiltAngleY = xo(this.tiltAngleY, -90, 90)),
            r &&
              ((this.tiltAngleX = r === 'x' ? this.tiltAngleX : 0),
              (this.tiltAngleY = r === 'y' ? this.tiltAngleY : 0))
        }),
        (this.updateTiltAnglesPercentage = t => {
          const { tiltMaxAngleX: r, tiltMaxAngleY: a } = t
          ;(this.tiltAngleXPercentage = (this.tiltAngleX / r) * 100),
            (this.tiltAngleYPercentage = (this.tiltAngleY / a) * 100)
        }),
        (this.render = t => {
          t.style.transform += `rotateX(${this.tiltAngleX}deg) rotateY(${this.tiltAngleY}deg) `
        })
    }
  }
const nz = Object.assign(
  Object.assign(
    {
      scale: 1,
      perspective: 1e3,
      flipVertically: !1,
      flipHorizontally: !1,
      reset: !0,
      transitionEasing: 'cubic-bezier(.03,.98,.52,.99)',
      transitionSpeed: 400,
      trackOnWindow: !1,
      gyroscope: !1
    },
    {
      tiltEnable: !0,
      tiltReverse: !1,
      tiltAngleXInitial: 0,
      tiltAngleYInitial: 0,
      tiltMaxAngleX: 20,
      tiltMaxAngleY: 20,
      tiltAxis: void 0,
      tiltAngleXManual: null,
      tiltAngleYManual: null
    }
  ),
  {
    glareEnable: !1,
    glareMaxOpacity: 0.7,
    glareColor: '#ffffff',
    glarePosition: 'bottom',
    glareReverse: !1,
    glareBorderRadius: '0'
  }
)
let GD = class extends w.PureComponent {
  constructor() {
    super(...arguments),
      (this.wrapperEl = {
        node: null,
        size: { width: 0, height: 0, left: 0, top: 0 },
        clientPosition: { x: null, y: null, xPercentage: 0, yPercentage: 0 },
        updateAnimationId: null,
        scale: 1
      }),
      (this.tilt = null),
      (this.glare = null),
      (this.addDeviceOrientationEventListener = () =>
        JB(this, void 0, void 0, function* () {
          if (!window.DeviceOrientationEvent) return
          const t = DeviceOrientationEvent.requestPermission
          typeof t == 'function'
            ? (yield t()) === 'granted' && window.addEventListener('deviceorientation', this.onMove)
            : window.addEventListener('deviceorientation', this.onMove)
        })),
      (this.setSize = () => {
        this.setWrapperElSize(), this.glare && this.glare.setSize(this.wrapperEl.size)
      }),
      (this.mainLoop = t => {
        this.wrapperEl.updateAnimationId !== null &&
          cancelAnimationFrame(this.wrapperEl.updateAnimationId),
          this.processInput(t),
          this.update(t.type),
          (this.wrapperEl.updateAnimationId = requestAnimationFrame(this.renderFrame))
      }),
      (this.onEnter = t => {
        const { onEnter: r } = this.props
        this.setSize(),
          (this.wrapperEl.node.style.willChange = 'transform'),
          this.setTransitions(),
          r && r(t.type)
      }),
      (this.onMove = t => {
        this.mainLoop(t), this.emitOnMove(t)
      }),
      (this.onLeave = t => {
        const { onLeave: r } = this.props
        if ((this.setTransitions(), r && r(t.type), this.props.reset)) {
          const a = new CustomEvent('autoreset')
          this.onMove(a)
        }
      }),
      (this.processInput = t => {
        const { scale: r } = this.props
        switch (t.type) {
          case 'mousemove':
            ;(this.wrapperEl.clientPosition.x = t.pageX),
              (this.wrapperEl.clientPosition.y = t.pageY),
              (this.wrapperEl.scale = r)
            break
          case 'touchmove':
            ;(this.wrapperEl.clientPosition.x = t.touches[0].pageX),
              (this.wrapperEl.clientPosition.y = t.touches[0].pageY),
              (this.wrapperEl.scale = r)
            break
          case 'deviceorientation':
            this.processInputDeviceOrientation(t), (this.wrapperEl.scale = r)
            break
          case 'autoreset':
            const {
                tiltAngleXInitial: a,
                tiltAngleYInitial: o,
                tiltMaxAngleX: u,
                tiltMaxAngleY: l
              } = this.props,
              d = (o / l) * 100
            ;(this.wrapperEl.clientPosition.xPercentage = xo((a / u) * 100, -100, 100)),
              (this.wrapperEl.clientPosition.yPercentage = xo(d, -100, 100)),
              (this.wrapperEl.scale = 1)
        }
      }),
      (this.processInputDeviceOrientation = t => {
        if (!t.gamma || !t.beta || !this.props.gyroscope) return
        const { tiltMaxAngleX: r, tiltMaxAngleY: a } = this.props,
          o = t.gamma
        ;(this.wrapperEl.clientPosition.xPercentage = (t.beta / r) * 100),
          (this.wrapperEl.clientPosition.yPercentage = (o / a) * 100),
          (this.wrapperEl.clientPosition.xPercentage = xo(
            this.wrapperEl.clientPosition.xPercentage,
            -100,
            100
          )),
          (this.wrapperEl.clientPosition.yPercentage = xo(
            this.wrapperEl.clientPosition.yPercentage,
            -100,
            100
          ))
      }),
      (this.update = t => {
        const { tiltEnable: r, flipVertically: a, flipHorizontally: o } = this.props
        t !== 'autoreset' && t !== 'deviceorientation' && t !== 'propChange' && this.updateClientInput(),
          r && this.tilt.update(this.wrapperEl.clientPosition, this.props),
          this.updateFlip(),
          this.tilt.updateTiltAnglesPercentage(this.props),
          this.glare && this.glare.update(this.wrapperEl.clientPosition, this.props, a, o)
      }),
      (this.updateClientInput = () => {
        const { trackOnWindow: t } = this.props
        let r, a
        if (t) {
          const { x: o, y: u } = this.wrapperEl.clientPosition
          ;(r = (u / window.innerHeight) * 200 - 100), (a = (o / window.innerWidth) * 200 - 100)
        } else {
          const {
            size: { width: o, height: u, left: l, top: d },
            clientPosition: { x: h, y: p }
          } = this.wrapperEl
          ;(r = ((p - d) / u) * 200 - 100), (a = ((h - l) / o) * 200 - 100)
        }
        ;(this.wrapperEl.clientPosition.xPercentage = xo(r, -100, 100)),
          (this.wrapperEl.clientPosition.yPercentage = xo(a, -100, 100))
      }),
      (this.updateFlip = () => {
        const { flipVertically: t, flipHorizontally: r } = this.props
        t && ((this.tilt.tiltAngleX += 180), (this.tilt.tiltAngleY *= -1)),
          r && (this.tilt.tiltAngleY += 180)
      }),
      (this.renderFrame = () => {
        this.resetWrapperElTransform(),
          this.renderPerspective(),
          this.tilt.render(this.wrapperEl.node),
          this.renderScale(),
          this.glare && this.glare.render(this.props)
      })
  }
  componentDidMount() {
    if (((this.tilt = new tz()), this.initGlare(), this.addEventListeners(), typeof CustomEvent > 'u'))
      return
    const t = new CustomEvent('autoreset')
    this.mainLoop(t)
    const r = new CustomEvent('initial')
    this.emitOnMove(r)
  }
  componentWillUnmount() {
    this.wrapperEl.updateAnimationId !== null && cancelAnimationFrame(this.wrapperEl.updateAnimationId),
      this.removeEventListeners()
  }
  componentDidUpdate() {
    const t = new CustomEvent('propChange')
    this.mainLoop(t), this.emitOnMove(t)
  }
  addEventListeners() {
    const { trackOnWindow: t, gyroscope: r } = this.props
    window.addEventListener('resize', this.setSize),
      t &&
        (window.addEventListener('mouseenter', this.onEnter),
        window.addEventListener('mousemove', this.onMove),
        window.addEventListener('mouseout', this.onLeave),
        window.addEventListener('touchstart', this.onEnter),
        window.addEventListener('touchmove', this.onMove),
        window.addEventListener('touchend', this.onLeave)),
      r && this.addDeviceOrientationEventListener()
  }
  removeEventListeners() {
    const { trackOnWindow: t, gyroscope: r } = this.props
    window.removeEventListener('resize', this.setSize),
      t &&
        (window.removeEventListener('mouseenter', this.onEnter),
        window.removeEventListener('mousemove', this.onMove),
        window.removeEventListener('mouseout', this.onLeave),
        window.removeEventListener('touchstart', this.onEnter),
        window.removeEventListener('touchmove', this.onMove),
        window.removeEventListener('touchend', this.onLeave)),
      r && window.DeviceOrientationEvent && window.removeEventListener('deviceorientation', this.onMove)
  }
  setWrapperElSize() {
    const t = this.wrapperEl.node.getBoundingClientRect()
    ;(this.wrapperEl.size.width = this.wrapperEl.node.offsetWidth),
      (this.wrapperEl.size.height = this.wrapperEl.node.offsetHeight),
      (this.wrapperEl.size.left = t.left + window.scrollX),
      (this.wrapperEl.size.top = t.top + window.scrollY)
  }
  initGlare() {
    const { glareEnable: t, glareBorderRadius: r } = this.props
    t &&
      ((this.glare = new ez(this.wrapperEl.size, r)),
      this.wrapperEl.node.appendChild(this.glare.glareWrapperEl))
  }
  emitOnMove(t) {
    const { onMove: r } = this.props
    if (!r) return
    let a = 0,
      o = 0
    this.glare && ((a = this.glare.glareAngle), (o = this.glare.glareOpacity)),
      r({
        tiltAngleX: this.tilt.tiltAngleX,
        tiltAngleY: this.tilt.tiltAngleY,
        tiltAngleXPercentage: this.tilt.tiltAngleXPercentage,
        tiltAngleYPercentage: this.tilt.tiltAngleYPercentage,
        glareAngle: a,
        glareOpacity: o,
        eventType: t.type
      })
  }
  resetWrapperElTransform() {
    this.wrapperEl.node.style.transform = ''
  }
  renderPerspective() {
    const { perspective: t } = this.props
    this.wrapperEl.node.style.transform += `perspective(${t}px) `
  }
  renderScale() {
    const { scale: t } = this.wrapperEl
    this.wrapperEl.node.style.transform += `scale3d(${t},${t},${t})`
  }
  setTransitions() {
    const { transitionSpeed: t, transitionEasing: r } = this.props
    SO(this.wrapperEl.node, 'all', t, r), this.glare && SO(this.glare.glareEl, 'opacity', t, r)
  }
  render() {
    const { children: t, className: r, style: a } = this.props
    return Gt.createElement(
      'div',
      {
        ref: o => (this.wrapperEl.node = o),
        onMouseEnter: this.onEnter,
        onMouseMove: this.onMove,
        onMouseLeave: this.onLeave,
        onTouchStart: this.onEnter,
        onTouchMove: this.onMove,
        onTouchEnd: this.onLeave,
        className: r,
        style: a
      },
      t
    )
  }
}
GD.defaultProps = nz
function rz({
  children: e,
  className: t = '',
  scale: r = 1.05,
  tiltMaxAngleY: a = 10,
  glareEnable: o = !0,
  gyroscope: u = !0,
  glarePosition: l = 'all',
  glareBorderRadius: d = '24px',
  glareMaxOpacity: h = 0.2,
  parralexEffect: p = !0
}) {
  return le.jsxDEV(
    GD,
    {
      scale: r,
      tiltMaxAngleY: a,
      glareEnable: o,
      gyroscope: u,
      glarePosition: l,
      glareBorderRadius: d,
      glareMaxOpacity: h,
      className: `${p ? 'parallax-effect-glare-scale' : ''} ${t}`,
      children: e
    },
    void 0,
    !1,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/ui/tilt-card/tilt-card.tsx',
      lineNumber: 32,
      columnNumber: 5
    },
    this
  )
}
const TO = {}
function iz(e, t) {
  const [r, a] = w.useState({ src: t, isLoading: !0, error: null })
  return (
    w.useEffect(() => {
      if (TO[e]) {
        a({ src: e, isLoading: !1, error: null })
        return
      }
      const o = new Image()
      return (
        (o.src = e),
        (o.onload = () => {
          ;(TO[e] = !0), a({ src: e, isLoading: !1, error: null })
        }),
        (o.onerror = u => {
          a({ src: t, isLoading: !1, error: u })
        }),
        () => {
          ;(o.onload = null), (o.onerror = null)
        }
      )
    }, [e, t]),
    r
  )
}
function az({ src: e, alt: t }) {
  return le.jsxDEV(
    'figure',
    {
      className: 'popup-element flex items-center justify-center',
      children: le.jsxDEV(
        sc.div,
        {
          layout: !0,
          className: 'relative w-60 h-60 -mt-16',
          children: [
            le.jsxDEV(
              sc.img,
              {
                loading: 'lazy',
                src: e,
                height: 240,
                width: 240,
                alt: `${t}-backdrop`,
                className:
                  'blur-2xl w-52 absolute opacity-50 group-hover:opacity-90 m-auto inset-0 transition-opacity'
              },
              void 0,
              !1,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-image.tsx',
                lineNumber: 12,
                columnNumber: 9
              },
              this
            ),
            le.jsxDEV(
              sc.img,
              {
                loading: 'lazy',
                layoutId: `${t} pokemon`,
                alt: t,
                height: 240,
                width: 240,
                src: e,
                className: 'w-52 m-auto z-10 relative'
              },
              void 0,
              !1,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-image.tsx',
                lineNumber: 20,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName:
            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-image.tsx',
          lineNumber: 11,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName:
        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-image.tsx',
      lineNumber: 10,
      columnNumber: 5
    },
    this
  )
}
function oz({ id: e, children: t, className: r }) {
  return le.jsxDEV(
    'div',
    {
      className: 'flex items-center justify-center gap-2',
      children: [
        le.jsxDEV(
          sc.h3,
          {
            layoutId: `pokemon-name-${e}`,
            className: `text-slate-300 group-hover:text-slate-50 dark:text-slate-400 dark:group-hover:text-slate-50 group-hover:underline capitalize text-center font-semibold my-5 ${r}`,
            children: t
          },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-title.tsx',
            lineNumber: 15,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          GV,
          {
            'aria-hidden': 'true',
            'aria-label': 'navigate icon',
            className:
              'opacity-0 size-0 scale-0 group-hover:opacity-100 group-hover:scale-100 group-hover:size-auto transition-transform text-slate-50 dark:text-slate-50'
          },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-title.tsx',
            lineNumber: 21,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName:
        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/card-title.tsx',
      lineNumber: 14,
      columnNumber: 5
    },
    this
  )
}
function sz({ name: e, image: t }) {
  const r = e.length > 22,
    { src: a, error: o } = iz(t, QB)
  return (
    o && console.error(o),
    le.jsxDEV(
      uV,
      {
        to: `pokemon-details/${e}`,
        search: u => ({ ...u }),
        'aria-label': `View details of ${e}`,
        className:
          'inline-block focus-visible:outline outline-yellow-500 outline-2 focus-visible:outline-offset-8 outline-offset-0  rounded-3xl transition-offset duration-200 motion-reduce:duration-0',
        children: le.jsxDEV(
          sc.div,
          {
            layoutId: `image-wrapper-${e}`,
            transition: { duration: 0.2 },
            className:
              'inner-glow bg-slate-800 inline-flex flex-col justify-center group cursor-pointer  dark:bg-slate-900 p-2 dark:text-slate-50 rounded-3xl dark:border-slate-800 border',
            children: le.jsxDEV(
              rz,
              {
                children: [
                  le.jsxDEV(
                    az,
                    { src: a, alt: `${e} image` },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/pokemon-preview-card.tsx',
                      lineNumber: 40,
                      columnNumber: 11
                    },
                    this
                  ),
                  le.jsxDEV(
                    oz,
                    { className: r ? 'text-base' : 'text-xl', id: e, children: e },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/pokemon-preview-card.tsx',
                      lineNumber: 42,
                      columnNumber: 11
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/pokemon-preview-card.tsx',
                lineNumber: 39,
                columnNumber: 9
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName:
              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/pokemon-preview-card.tsx',
            lineNumber: 34,
            columnNumber: 7
          },
          this
        )
      },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-preview-card/pokemon-preview-card.tsx',
        lineNumber: 28,
        columnNumber: 5
      },
      this
    )
  )
}
const lz = w.memo(sz),
  uz = '/assets/Pokeball-MRKc3I6s.svg',
  cz =
    "data:image/svg+xml,%3csvg%20fill='none'%20height='512'%20viewBox='0%200%20512%20512'%20width='512'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20clip-rule='evenodd'%20d='m342.198.501279c.373-.5317158%201.105-.660937%201.637-.288625l36.354%2025.455546c.532.3723.661%201.1051.289%201.6368l-50.599%2072.2623c24.599%207.8587%2041.358%2016.3357%2041.358%2016.3357s-40.964%2070.462-110.443%2070.462-118.85-65.672-118.85-65.672%2017.506-11.172%2043.456-20.7539l-55.5-66.1415c-.417-.4973-.352-1.2386.145-1.6558l33.997-28.52715c.498-.41723%201.239-.35238%201.656.14487l70.272%2083.74688c6.017-.6806%2012.147-1.061%2018.333-1.061%208.891%200%2017.771.6759%2026.44%201.8229zm13.746%20189.200721c18.541-13.242%2046.597-47.804%2046.597-47.804s71.664%2056.79%2071.664%20177.206c0%20120.415-123.896%20192.888-123.896%20192.888s-59.195-59.781-73.727-135.562c-14.531-75.781%2021.496-159.927%2021.496-159.927s39.324-13.559%2057.866-26.801zm-199.683%200c-18.541-13.242-46.597-47.804-46.597-47.804s-71.664%2056.79-71.664%20177.206c0%20120.415%20123.896%20192.888%20123.896%20192.888s59.195-59.781%2073.727-135.562c14.531-75.781-21.496-159.927-21.496-159.927s-39.324-13.559-57.866-26.801z'%20fill='%23fff'%20fill-rule='evenodd'/%3e%3c/svg%3e",
  fz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M229.379%20452.85C239.106%20454.339%20249.068%20455.111%20259.212%20455.111C367.214%20455.111%20454.767%20367.558%20454.767%20259.556C454.767%20151.553%20367.214%2064%20259.212%2064C251.966%2064%20244.811%2064.3941%20237.77%2065.1621C291.345%20105.751%20326.767%20176.062%20326.767%20256C326.767%20340.04%20287.616%20413.44%20229.379%20452.85ZM255.656%20512C397.041%20512%20511.656%20397.385%20511.656%20256C511.656%20114.615%20397.041%200%20255.656%200C114.271%200%20-0.34375%20114.615%20-0.34375%20256C-0.34375%20397.385%20114.271%20512%20255.656%20512Z'%20fill='white'/%3e%3c/svg%3e",
  dz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M280.702%20254.881C284.172%20252.765%20287.116%20248.331%20289.49%20243.403C320.735%20256.173%20342.692%20286.349%20342.692%20321.54C342.692%20368.29%20303.942%20406.189%20256.142%20406.189C236.52%20406.189%20218.423%20399.802%20203.906%20389.039C199.144%20386.784%20195.226%20384.618%20192.02%20382.845C187.047%20380.096%20183.786%20378.293%20181.744%20378.575C175.775%20379.398%20177.508%20384.89%20179.083%20389.879C180.152%20393.268%20181.149%20396.425%20179.606%20397.727C177.992%20399.091%20172.764%20394.106%20166.655%20388.282C158.339%20380.353%20148.391%20370.868%20143.7%20373.717C139.991%20375.97%20143.592%20382.081%20148%20389.561L148.327%20390.116C150.189%20393.278%20152.347%20396.498%20154.316%20399.436C158.319%20405.407%20161.543%20410.219%20159.93%20411.033C157.98%20412.017%20144.394%20402.847%20132.945%20390.116C128.526%20385.203%20124.246%20379.877%20120.268%20374.928L120.268%20374.927C111.561%20364.093%20104.307%20355.068%20100.235%20356.137C95.3365%20357.423%2099.0421%20367.527%20104.487%20377.25C107.033%20381.797%20110.028%20386.427%20112.621%20390.436L112.621%20390.437C116.654%20396.671%20119.715%20401.402%20118.605%20401.984C117.107%20402.767%20103.926%20389.914%2094.9734%20373.717C89.6559%20364.096%2085.1909%20353.464%2081.5761%20344.857C77.656%20335.522%2074.7359%20328.569%2072.8131%20327.869C66.1325%20325.438%2066.1325%20339.059%2068.8119%20358.718C69.1614%20361.283%2069.6819%20363.973%2070.3228%20366.712C96.307%20450.785%20176.128%20512%20270.567%20512C386.084%20512%20479.728%20420.412%20479.728%20307.432C479.728%20199.9%20394.899%20111.747%20287.12%20103.494C287.256%2098.4284%20289.9%2088.383%20289.9%2088.383C289.9%2088.383%20308.927%2042.3472%20309.933%2032.5099C309.999%2031.857%20310.078%2031.1475%20310.163%2030.3919C311.348%2019.7629%20313.553%200%20296.551%200C287.471%200%20283.249%206.75464%20278.42%2014.4799L278.42%2014.48C276.566%2017.4457%20274.622%2020.5545%20272.28%2023.479C255.412%2044.5436%20227.048%2070.8488%20210.965%2084.8631C176.971%20114.484%20143.619%20138.828%20124.167%20153.026L124.167%20153.026L124.166%20153.027C115.319%20159.484%20109.348%20163.843%20107.5%20165.644C93.574%20179.22%2043.6418%20269.286%2043.6418%20269.286C43.6418%20269.286%2027.4943%20298.182%2033.2338%20304.043C38.9733%20309.903%2052.8141%20308.56%2052.8141%20308.56C52.8141%20308.56%20238.755%20265.903%20255.402%20262.539C259.884%20261.633%20263.048%20261.11%20265.477%20260.709C272.072%20259.62%20273.256%20259.424%20280.702%20254.881ZM149.235%20200.064C139.254%20209.551%20122.701%20232.196%20122.701%20232.196C122.701%20232.196%20153.465%20234.091%20170.408%20217.986C187.352%20201.88%20183.47%20174.433%20183.47%20174.433C183.47%20174.433%20159.215%20190.577%20149.235%20200.064Z'%20fill='white'/%3e%3c/svg%3e",
  hz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M152.56%200.583659C152.461%200.29796%20152.674%200%20152.976%200H332.805C332.998%200%20333.169%200.125587%20333.226%200.309782L415.824%20267.171C415.911%20267.454%20415.7%20267.741%20415.403%20267.741H295.684C295.538%20267.741%20295.433%20267.88%20295.473%20268.021L364.135%20509.726C364.269%20510.195%20363.654%20510.501%20363.361%20510.111L96.5295%20155.267C96.3115%20154.977%2096.5184%20154.563%2096.881%20154.563H205.536C205.687%20154.563%20205.793%20154.414%20205.743%20154.271L152.56%200.583659Z'%20fill='white'/%3e%3c/svg%3e",
  pz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M102.726%20405.978L184.848%20382.166L255.778%20511.857C255.871%20512.025%20256.112%20512.025%20256.204%20511.857L327.134%20382.166L409.257%20405.978C409.441%20406.031%20409.612%20405.86%20409.557%20405.676L385.741%20325.179L511.856%20256.204C512.025%20256.112%20512.025%20255.871%20511.857%20255.779L384.702%20186.235L409.557%20102.225C409.612%20102.041%20409.441%20101.87%20409.257%20101.923L325.208%20126.294L256.204%200.126188C256.112%20-0.0420597%20255.871%20-0.0420644%20255.779%200.126184L186.775%20126.294L102.726%20101.923C102.542%20101.87%20102.371%20102.041%20102.426%20102.225L127.281%20186.235L0.126188%20255.779C-0.0420597%20255.871%20-0.0420644%20256.112%200.126184%20256.204L126.241%20325.179L102.426%20405.676C102.371%20405.86%20102.542%20406.031%20102.726%20405.978ZM166.452%20256.876L224.631%20288.695L256.45%20346.873C256.542%20347.042%20256.784%20347.042%20256.876%20346.873L288.695%20288.695L346.873%20256.876C347.041%20256.784%20347.041%20256.542%20346.873%20256.45L288.695%20224.631L256.876%20166.453C256.784%20166.284%20256.542%20166.284%20256.45%20166.453L224.631%20224.631L166.452%20256.45C166.284%20256.542%20166.284%20256.784%20166.452%20256.876Z'%20fill='white'/%3e%3c/svg%3e",
  mz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M88.2336%2042.5656C94.4299%2018.1014%20116.593%200%20142.983%200C162.778%200%20180.195%2010.1847%20190.279%2025.6H206.792C217.051%2015.0716%20231.384%208.53333%20247.245%208.53333C270.499%208.53333%20290.471%2022.5882%20299.129%2042.6667H312.954C321.617%2037.2585%20331.853%2034.1333%20342.818%2034.1333C366.073%2034.1333%20386.044%2048.1882%20394.702%2068.2667H432.297C432.618%2068.2667%20432.919%2068.3532%20433.178%2068.5041C434.895%2068.347%20436.634%2068.2667%20438.391%2068.2667C469.582%2068.2667%20494.866%2093.5514%20494.866%20124.742V294.086L494.867%20294.4L494.866%20294.714V297.153C494.866%20298.186%20494.838%20299.215%20494.782%20300.239C491.384%20417.717%20385.749%20512%20255.933%20512C123.974%20512%2017%20414.577%2017%20294.4C17%20236.391%2041.9249%20183.683%2082.5535%20144.675C82.4522%20201.228%2083.4074%20259.694%2087.8107%20258.691C99.6011%20256.003%2090.3891%2080.8395%2088.2336%2042.5656Z'%20fill='white'/%3e%3c/svg%3e",
  vz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M352.258%20395.394C358.584%20372.263%20346.305%20324.71%20346.305%20324.71C346.305%20324.71%20337.399%20363.449%20323.483%20377.767C311.611%20389.98%20297.066%20398.451%20276.206%20400.677C293.261%20392.393%20304.99%20375.12%20304.99%20355.155C304.99%20327.129%20281.878%20304.409%20253.368%20304.409C224.858%20304.409%20201.745%20327.129%20201.745%20355.155C201.745%20362.809%20203.47%20370.068%20206.557%20376.576C188.725%20362.37%20185.921%20339.594%20185.921%20339.594C185.921%20339.594%20166.009%20422.264%20220.875%20461.152C275.74%20500.04%20383.219%20466.614%20383.219%20466.614C383.219%20466.614%20229.41%20574.837%20115.436%20457.05C17.2568%20355.584%2089.8111%20222.003%2089.8111%20222.003C89.8111%20222.003%2086.6777%20234.395%2086.6777%20248.78C86.6777%20263.165%2094.477%20274.11%2094.477%20274.11C94.477%20274.11%20117.742%20225.071%20135.848%20205.128C152.984%20186.254%20174.465%20170.946%20193.019%20157.724C207.301%20147.546%20219.849%20138.604%20227.343%20130.223C268.62%2084.0687%20243.311%200%20243.311%200C243.311%200%20289.841%2041.02%20302.831%2093.9978C307.783%20114.192%20304.597%20137.169%20301.749%20157.716C297.125%20191.072%20293.388%20218.025%20326.793%20216.276C380.775%20213.449%20333.866%20130.223%20333.866%20130.223C333.866%20130.223%20456.318%20194.583%20447.17%20307.145C438.021%20419.707%20313.324%20445.297%20313.324%20445.297C313.324%20445.297%20345.931%20418.525%20352.258%20395.394Z'%20fill='white'/%3e%3c/svg%3e",
  gz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M178.712%20477.733C253.715%20477.733%20317.927%20436.048%20344.436%20376.956C344.76%20376.235%20238.007%20404.699%20241.411%20394.637C242.931%20390.144%20308.371%20366.238%20356.048%20338.354C383.451%20322.327%20396.07%20288.4%20396.07%20288.4C396.07%20288.4%20349.903%20310.815%20326.564%20316.501C279.532%20327.961%20238.131%20326.727%20238.131%20325.533C238.131%20322.951%20306.876%20309.889%20402.424%20251.664C447.367%20224.277%20459.574%20177.103%20459.574%20177.103C459.574%20177.103%20410.163%20206.535%20380.293%20216.252C309.457%20239.295%20244.815%20246.239%20244.815%20243.121C244.815%20236.445%20301.702%20220.802%20362.016%20191.577C393.376%20176.382%20420.535%20156.53%20452.008%20134.453C503.506%2098.332%20511.999%2034%20511.999%2034C511.999%2034%20461.207%2066.7601%20436.42%2077.6394C334.141%20122.531%20243.829%20146.079%20178.712%20151.177C80.416%20158.873%200%20227.456%200%20316.501C0%20405.547%2080.0119%20477.733%20178.712%20477.733Z'%20fill='white'/%3e%3c/svg%3e",
  yz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M368.952%20510.227C322.769%20512.591%20269.896%20512.591%20251.928%20510.227C111.77%20491.788%200%20389.313%200%20250.8C0%20112.287%20114.615%200%20256%200C397.385%200%20512%20112.287%20512%20250.8C512%20315.221%20487.207%20373.969%20446.46%20418.387C435.395%20430.448%20450.577%20438.908%20466.002%20447.504C481.13%20455.935%20496.492%20464.496%20487.564%20476.712C477.726%20490.173%20424.392%20507.389%20368.952%20510.227ZM220%20219.45C220%20241.092%20202.091%20258.637%20180%20258.637C157.909%20258.637%20140%20241.092%20140%20219.45C140%20204.935%20148.055%20192.264%20160.024%20185.491C160.713%20204.362%20176.229%20219.449%20195.269%20219.449H220C220%20219.449%20220%20219.45%20220%20219.45ZM343.976%20185.491C343.287%20204.362%20327.771%20219.449%20308.731%20219.449H284C284%20219.449%20284%20219.45%20284%20219.45C284%20241.092%20301.909%20258.637%20324%20258.637C346.091%20258.637%20364%20241.092%20364%20219.45C364%20204.935%20355.945%20192.264%20343.976%20185.491Z'%20fill='white'/%3e%3c/svg%3e",
  bz =
    "data:image/svg+xml,%3csvg%20fill='none'%20height='512'%20viewBox='0%200%20512%20512'%20width='512'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20clip-rule='evenodd'%20d='m97.4121%20440.649c-1.7574-1.653-3.4954-3.338-5.2132-5.056-90.68455-90.684-90.68453-237.713%200-328.397%2090.6841-90.6849%20379.6401-96.7516%20379.6401-96.7516s39.442%20334.4646-51.242%20425.1486c-80.54%2080.54-205.522%2089.55-296.005%2027.031l72.908-89.471%20116.55-25.163-95.139-9.511%2060.462-61.562%2068.824-15.077-54.422-16.117%2054.422-98.176-77.41%2086.828-29.893-42.183%2010.523%2069.648-53.917%2060.782-24.993-76.9v102.268z'%20fill='%23fff'%20fill-rule='evenodd'/%3e%3c/svg%3e",
  Ez =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M112.764%20439.754C112.625%20439.754%20112.528%20439.617%20112.574%20439.486L243.289%2070.134C243.318%2070.0537%20243.394%2070%20243.479%2070H383.021C383.106%2070%20383.183%2070.0541%20383.211%2070.1349L511.987%20439.487C512.032%20439.618%20511.935%20439.754%20511.797%20439.754H116.692H112.764ZM0.201306%20441.199C0.0609122%20441.199%20-0.0362852%20441.059%200.0129607%20440.928L97.3526%20181.056C97.3821%20180.977%2097.4571%20180.925%2097.541%20180.925H182.118C182.258%20180.925%20182.355%20181.064%20182.307%20181.195L88.1823%20441.067C88.1535%20441.146%2088.0779%20441.199%2087.9932%20441.199H0.201306Z'%20fill='white'/%3e%3c/svg%3e",
  xz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M384.304%2039.0418L385.879%20177.392L265.209%20235.319L263.721%20104.69L384.304%2039.0418Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M505.269%20257.047L385.814%20325.374L266.288%20256.939L385.752%20194.187L505.269%20257.047Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M245.04%20257.047L125.585%20325.374L6.05861%20256.939L125.523%20194.187L245.04%20257.047Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M124.243%2038.4753L248.229%2099.881L245.059%20233.697L127.993%20175.719L124.243%2038.4753Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M387.678%20473.525L263.692%20412.119L266.862%20278.302L383.928%20336.281L387.678%20473.525Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M128.525%20474.77L126.949%20336.42L247.62%20278.493L249.108%20409.121L128.525%20474.77Z'%20fill='white'/%3e%3c/svg%3e",
  Sz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M481%20256C481%20380.264%20380.264%20481%20256%20481C131.736%20481%2031%20380.264%2031%20256C31%20131.736%20131.736%2031%20256%2031C380.264%2031%20481%20131.736%20481%20256ZM384.571%20256C384.571%20327.008%20327.008%20384.571%20256%20384.571C184.992%20384.571%20127.429%20327.008%20127.429%20256C127.429%20184.992%20184.992%20127.429%20256%20127.429C327.008%20127.429%20384.571%20184.992%20384.571%20256Z'%20fill='white'/%3e%3c/svg%3e",
  Tz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M427.821%20393.449C479.524%20352.108%20512%20292.376%20512%20225.95C512%20101.161%20397.385%200%20256%200C114.615%200%200%20101.161%200%20225.95C0%20289.978%2030.1737%20347.786%2078.6553%20388.901C75.7171%20399.046%2074.1052%20410.081%2074.1052%20421.62C74.1052%20471.535%20104.267%20512%20141.474%20512C165.65%20512%20186.852%20494.915%20198.737%20469.254C210.622%20494.915%20231.824%20512%20256%20512C278.038%20512%20297.604%20497.804%20309.895%20475.857C322.186%20497.804%20341.752%20512%20363.789%20512C400.996%20512%20431.158%20471.535%20431.158%20421.62C431.158%20411.784%20429.986%20402.314%20427.821%20393.449ZM404.211%20230.431C404.211%20293.785%20336.346%20345.144%20252.632%20345.144C168.917%20345.144%20101.053%20293.785%20101.053%20230.431C101.053%20167.077%20168.917%20115.718%20252.632%20115.718C336.346%20115.718%20404.211%20167.077%20404.211%20230.431Z'%20fill='white'/%3e%3c/svg%3e",
  Cz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M455.925%20425.184C455.925%20425.184%20391.365%20476.963%20262.893%20455.536C165.423%20439.279%20113.437%20331.833%20113.437%20274.079C113.437%20137.149%20214.783%20105.988%20283.3%20105.988C351.816%20105.988%20396.513%20172.788%20396.513%20224.508C396.513%20276.228%20359.933%20321.466%20303.006%20321.466C246.08%20321.466%20229.22%20281.501%20229.22%20244.758C229.22%20208.016%20258.947%20195.071%20286.058%20195.071C313.169%20195.071%20322.452%20218.217%20322.452%20238.11C322.452%20258.004%20307.017%20265.128%20294.143%20265.128C281.269%20265.128%20279.996%20258.633%20275.069%20251.807C270.141%20244.982%20281.353%20219.146%20262.893%20219.146C244.433%20219.146%20240.992%20248.847%20240.992%20248.847C240.992%20248.847%20247.722%20306.18%20303.006%20305.191C358.291%20304.201%20384.518%20261.461%20376.896%20219.146C369.274%20176.83%20328.207%20131.865%20256.133%20140.951C184.059%20150.037%20154.632%20222.861%20167.603%20300.685C180.574%20378.51%20273.807%20423.602%20347.112%20407.379C420.418%20391.156%20493.429%20338.086%20493.429%20203.533C493.429%2068.9789%20376.896%20-11.9002%20237.941%201.42913C98.9859%2014.7584%2012.729%20136.242%2018.2502%20282.207C23.7714%20428.172%20162.275%20507.669%20279.394%20511.766C396.513%20515.864%20468.312%20448.067%20468.312%20448.067C468.312%20448.067%20484.459%20433.668%20478.128%20422.424C471.798%20411.18%20455.925%20425.184%20455.925%20425.184Z'%20fill='white'/%3e%3c/svg%3e",
  wz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M395.138%20244.757C395.109%20244.717%20395.097%20244.667%20395.105%20244.618L427.769%2054.1518C427.784%2054.0641%20427.861%2054%20427.949%2054H438.287C438.367%2054%20438.437%2054.0517%20438.461%2054.1277L512.051%20287.131C512.074%20287.203%20512.049%20287.283%20511.989%20287.33L457.73%20329.693C457.649%20329.756%20457.532%20329.74%20457.471%20329.657L395.138%20244.757ZM-1%20371.022C-1%20371.101%20-0.949204%20371.171%20-0.874109%20371.196L110.975%20407.767C111.029%20407.785%20111.089%20407.776%20111.136%20407.744L361.145%20235.144C361.187%20235.115%20361.215%20235.07%20361.222%20235.02L388.032%2055.1284C388.049%2055.018%20387.963%2054.9188%20387.852%2054.9188H166.406C166.351%2054.9188%20166.3%2054.943%20166.265%2054.9849L-0.957974%20256.714C-0.98514%20256.747%20-1%20256.788%20-1%20256.831V371.022ZM157.583%20417.085L279.776%20457.112C279.831%20457.13%20279.892%20457.121%20279.939%20457.087L425.418%20352.734C425.499%20352.677%20425.519%20352.566%20425.464%20352.484L370.928%20271.329C370.871%20271.244%20370.757%20271.222%20370.673%20271.28L157.583%20417.085Z'%20fill='white'/%3e%3c/svg%3e",
  Rz =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M0.0511107%20254.527C-0.0170046%20254.411%20-0.0170388%20254.267%200.0510196%20254.15L128.795%2034.1843C128.862%2034.0702%20128.985%2034%20129.117%2034H384.294C384.427%2034%20384.55%2034.0708%20384.617%2034.1859L511.949%20254.152C512.016%20254.267%20512.016%20254.41%20511.949%20254.525L384.617%20474.244C384.55%20474.359%20384.427%20474.43%20384.294%20474.43H129.117C128.985%20474.43%20128.862%20474.36%20128.795%20474.246L0.0511107%20254.527ZM374.617%20254.215C374.617%20319.703%20321.528%20372.792%20256.04%20372.792C190.552%20372.792%20137.463%20319.703%20137.463%20254.215C137.463%20188.726%20190.552%20135.638%20256.04%20135.638C321.528%20135.638%20374.617%20188.726%20374.617%20254.215Z'%20fill='white'/%3e%3c/svg%3e",
  _z =
    "data:image/svg+xml,%3csvg%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M422.172%20346.515C422.172%20437.897%20347.813%20511.977%20256.086%20511.977C164.359%20511.977%2090%20437.897%2090%20346.515C90%20257.639%20247.102%2013.5479%20255.718%200.22781C255.915%20-0.0759384%20256.258%20-0.0759358%20256.454%200.227813C265.07%2013.5479%20422.172%20257.639%20422.172%20346.515ZM228.4%20458.931C144.12%20440.49%20158.542%20347.13%20158.542%20347.13C158.542%20347.13%20181.556%20403.488%20237.405%20421.744C293.253%20439.999%20360.745%20413.225%20360.745%20413.225C360.745%20413.225%20312.68%20477.371%20228.4%20458.931Z'%20fill='white'/%3e%3c/svg%3e",
  th = 20,
  jh = 0,
  KD = 5 * 60 * 1e3,
  Qx = {
    bug: cz,
    dark: fz,
    dragon: dz,
    electric: hz,
    fairy: pz,
    fighting: mz,
    fire: vz,
    flying: gz,
    ghost: yz,
    grass: bz,
    ground: Ez,
    ice: xz,
    normal: Sz,
    poison: Tz,
    psychic: Cz,
    rock: wz,
    steel: Rz,
    water: _z
  },
  ZD = {
    normal: '#A8A77A',
    fire: '#EE8130',
    water: '#6390F0',
    electric: '#F7D02C',
    grass: '#7AC74C',
    ice: '#96D9D6',
    fighting: '#C22E28',
    poison: '#A33EA1',
    ground: '#E2BF65',
    flying: '#A98FF3',
    psychic: '#F95587',
    bug: '#A6B91A',
    rock: '#B6A136',
    ghost: '#735797',
    dragon: '#6F35FC',
    dark: '#705746',
    steel: '#B7B7CE',
    fairy: '#D685AD'
  },
  CO = {
    hp: { max: 255, color: '#ff0000' },
    attack: { max: 190, color: '#ff0097' },
    defense: { max: 250, color: '#11e800' },
    'special-attack': { max: 194, color: '#ff4d00' },
    'special-defense': { max: 250, color: '#383bff' },
    speed: { max: 200, color: '#00a9ff' }
  }
function XD(e) {
  var r, a, o, u, l, d, h, p, v
  const t = Array.isArray(e == null ? void 0 : e.sprites)
    ? (r = e.sprites[0]) == null
      ? void 0
      : r.sprites
    : e == null
      ? void 0
      : e.sprites
  return (
    ((o = (a = t == null ? void 0 : t.other) == null ? void 0 : a['official-artwork']) == null
      ? void 0
      : o.front_shiny) ||
    ((l = (u = t == null ? void 0 : t.other) == null ? void 0 : u['official-artwork']) == null
      ? void 0
      : l.front_default) ||
    ((h = (d = t == null ? void 0 : t.other) == null ? void 0 : d.dream_world) == null
      ? void 0
      : h.front_default) ||
    ((v = (p = t == null ? void 0 : t.other) == null ? void 0 : p.home) == null
      ? void 0
      : v.front_shiny) ||
    (t == null ? void 0 : t.front_shiny) ||
    uz
  )
}
function SZ(e) {
  var l, d, h
  const t = e == null ? void 0 : e.id,
    r = XD(e),
    a =
      (l = e == null ? void 0 : e.types) == null
        ? void 0
        : l.map(p => {
            var v, g, E
            return {
              name: (v = p == null ? void 0 : p.type) == null ? void 0 : v.name,
              icon: ((g = p == null ? void 0 : p.type) == null ? void 0 : g.name) && Qx[p.type.name],
              color: ((E = p == null ? void 0 : p.type) == null ? void 0 : E.name) && ZD[p.type.name]
            }
          }),
    o =
      (d = e == null ? void 0 : e.abilities) == null
        ? void 0
        : d.map(p => {
            var v
            return (v = p == null ? void 0 : p.ability) == null ? void 0 : v.name
          }),
    u =
      (h = e == null ? void 0 : e.stats) == null
        ? void 0
        : h.reduce((p, v) => {
            var g
            if ((g = v == null ? void 0 : v.stat) != null && g.name) {
              const E = v.stat.name
              p.push({ name: E, value: v.base_stat || 0, max: CO[E].max, color: CO[E].color })
            }
            return p
          }, [])
  return { id: t, image: r, types: a, abilities: o, baseStats: u }
}
function Oz(e) {
  return e.map(t => ({ type: { name: t.pokemon_v2_type.name } }))
}
function kz(e, t) {
  var r, a
  for (const o of e) {
    const u =
      (a = (r = o == null ? void 0 : o[1]) == null ? void 0 : r.pokemons) == null
        ? void 0
        : a.find(l => l.name === t)
    if (u) return u
  }
  return null
}
function TZ(e, t) {
  var d
  const r = kz(t, e)
  if (!r) return
  const { sprites: a, types: o } = r,
    u = ((d = a == null ? void 0 : a[0]) == null ? void 0 : d.sprites) || null,
    l = Oz(o)
  return { sprites: u, types: l }
}
function Az({ pokemons: e, isLoading: t, limit: r }) {
  return le.jsxDEV(
    'section',
    {
      'aria-label': 'List of Pokmon',
      className: 'mt-24 p-2',
      children: le.jsxDEV(
        'ul',
        {
          className: 'flex justify-center gap-x-10 gap-y-28 flex-wrap',
          children: [
            t &&
              !(e != null && e.length) &&
              le.jsxDEV(
                XB,
                { totalCard: r },
                void 0,
                !1,
                {
                  fileName:
                    '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
                  lineNumber: 18,
                  columnNumber: 44
                },
                this
              ),
            le.jsxDEV(
              KB,
              {
                children:
                  !!(e != null && e.length) &&
                  (e == null
                    ? void 0
                    : e.map(a =>
                        le.jsxDEV(
                          sc.li,
                          {
                            layout: !0,
                            className: 'list-none',
                            children: le.jsxDEV(
                              lz,
                              { name: a.name, image: XD(a) },
                              void 0,
                              !1,
                              {
                                fileName:
                                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
                                lineNumber: 24,
                                columnNumber: 17
                              },
                              this
                            )
                          },
                          a.name,
                          !1,
                          {
                            fileName:
                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
                            lineNumber: 23,
                            columnNumber: 15
                          },
                          this
                        )
                      ))
              },
              void 0,
              !1,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
                lineNumber: 20,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName:
            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
          lineNumber: 17,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName:
        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/pokemon-list/pokemon-list.tsx',
      lineNumber: 16,
      columnNumber: 5
    },
    this
  )
}
const QD = typeof document < 'u' ? Gt.useLayoutEffect : () => {}
function Dz(e) {
  const t = w.useRef(null)
  return (
    QD(() => {
      t.current = e
    }, [e]),
    w.useCallback((...r) => {
      const a = t.current
      return a == null ? void 0 : a(...r)
    }, [])
  )
}
const Uh = e => {
    var t
    return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document
  },
  Tl = e => (e && 'window' in e && e.window === e ? e : Uh(e).defaultView || window)
function Nz(e) {
  var t
  return typeof window > 'u' || window.navigator == null
    ? !1
    : ((t = window.navigator.userAgentData) === null || t === void 0
        ? void 0
        : t.brands.some(r => e.test(r.brand))) || e.test(window.navigator.userAgent)
}
function Mz(e) {
  var t
  return typeof window < 'u' && window.navigator != null
    ? e.test(
        ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) ||
          window.navigator.platform
      )
    : !1
}
function JD(e) {
  let t = null
  return () => (t == null && (t = e()), t)
}
const Lz = JD(function () {
    return Mz(/^Mac/i)
  }),
  Pz = JD(function () {
    return Nz(/Android/i)
  })
function Iz(e) {
  return e.mozInputSource === 0 && e.isTrusted
    ? !0
    : Pz() && e.pointerType
      ? e.type === 'click' && e.buttons === 1
      : e.detail === 0 && !e.pointerType
}
class Fz {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented
  }
  preventDefault() {
    ;(this.defaultPrevented = !0), this.nativeEvent.preventDefault()
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), (this.isPropagationStopped = () => !0)
  }
  isPropagationStopped() {
    return !1
  }
  persist() {}
  constructor(t, r) {
    ;(this.nativeEvent = r),
      (this.target = r.target),
      (this.currentTarget = r.currentTarget),
      (this.relatedTarget = r.relatedTarget),
      (this.bubbles = r.bubbles),
      (this.cancelable = r.cancelable),
      (this.defaultPrevented = r.defaultPrevented),
      (this.eventPhase = r.eventPhase),
      (this.isTrusted = r.isTrusted),
      (this.timeStamp = r.timeStamp),
      (this.type = t)
  }
}
function eN(e) {
  let t = w.useRef({ isFocused: !1, observer: null })
  QD(() => {
    const a = t.current
    return () => {
      a.observer && (a.observer.disconnect(), (a.observer = null))
    }
  }, [])
  let r = Dz(a => {
    e == null || e(a)
  })
  return w.useCallback(
    a => {
      if (
        a.target instanceof HTMLButtonElement ||
        a.target instanceof HTMLInputElement ||
        a.target instanceof HTMLTextAreaElement ||
        a.target instanceof HTMLSelectElement
      ) {
        t.current.isFocused = !0
        let o = a.target,
          u = l => {
            ;(t.current.isFocused = !1),
              o.disabled && r(new Fz('blur', l)),
              t.current.observer && (t.current.observer.disconnect(), (t.current.observer = null))
          }
        o.addEventListener('focusout', u, { once: !0 }),
          (t.current.observer = new MutationObserver(() => {
            if (t.current.isFocused && o.disabled) {
              var l
              ;(l = t.current.observer) === null || l === void 0 || l.disconnect()
              let d = o === document.activeElement ? null : document.activeElement
              o.dispatchEvent(new FocusEvent('blur', { relatedTarget: d })),
                o.dispatchEvent(new FocusEvent('focusout', { bubbles: !0, relatedTarget: d }))
            }
          })),
          t.current.observer.observe(o, { attributes: !0, attributeFilter: ['disabled'] })
      }
    },
    [r]
  )
}
function Vz(e) {
  let { isDisabled: t, onFocus: r, onBlur: a, onFocusChange: o } = e
  const u = w.useCallback(
      h => {
        if (h.target === h.currentTarget) return a && a(h), o && o(!1), !0
      },
      [a, o]
    ),
    l = eN(u),
    d = w.useCallback(
      h => {
        const p = Uh(h.target)
        h.target === h.currentTarget && p.activeElement === h.target && (r && r(h), o && o(!0), l(h))
      },
      [o, r, l]
    )
  return {
    focusProps: { onFocus: !t && (r || o || a) ? d : void 0, onBlur: !t && (a || o) ? u : void 0 }
  }
}
let $h = null,
  Jx = new Set(),
  nh = new Map(),
  Vl = !1,
  eS = !1
const jz = { Tab: !0, Escape: !0 }
function t1(e, t) {
  for (let r of Jx) r(e, t)
}
function Uz(e) {
  return !(
    e.metaKey ||
    (!Lz() && e.altKey) ||
    e.ctrlKey ||
    e.key === 'Control' ||
    e.key === 'Shift' ||
    e.key === 'Meta'
  )
}
function qv(e) {
  ;(Vl = !0), Uz(e) && (($h = 'keyboard'), t1('keyboard', e))
}
function Yi(e) {
  ;($h = 'pointer'),
    (e.type === 'mousedown' || e.type === 'pointerdown') && ((Vl = !0), t1('pointer', e))
}
function tN(e) {
  Iz(e) && ((Vl = !0), ($h = 'virtual'))
}
function nN(e) {
  e.target === window ||
    e.target === document ||
    (!Vl && !eS && (($h = 'virtual'), t1('virtual', e)), (Vl = !1), (eS = !1))
}
function rN() {
  ;(Vl = !1), (eS = !0)
}
function tS(e) {
  if (typeof window > 'u' || nh.get(Tl(e))) return
  const t = Tl(e),
    r = Uh(e)
  let a = t.HTMLElement.prototype.focus
  ;(t.HTMLElement.prototype.focus = function () {
    ;(Vl = !0), a.apply(this, arguments)
  }),
    r.addEventListener('keydown', qv, !0),
    r.addEventListener('keyup', qv, !0),
    r.addEventListener('click', tN, !0),
    t.addEventListener('focus', nN, !0),
    t.addEventListener('blur', rN, !1),
    typeof PointerEvent < 'u'
      ? (r.addEventListener('pointerdown', Yi, !0),
        r.addEventListener('pointermove', Yi, !0),
        r.addEventListener('pointerup', Yi, !0))
      : (r.addEventListener('mousedown', Yi, !0),
        r.addEventListener('mousemove', Yi, !0),
        r.addEventListener('mouseup', Yi, !0)),
    t.addEventListener(
      'beforeunload',
      () => {
        iN(e)
      },
      { once: !0 }
    ),
    nh.set(t, { focus: a })
}
const iN = (e, t) => {
  const r = Tl(e),
    a = Uh(e)
  t && a.removeEventListener('DOMContentLoaded', t),
    nh.has(r) &&
      ((r.HTMLElement.prototype.focus = nh.get(r).focus),
      a.removeEventListener('keydown', qv, !0),
      a.removeEventListener('keyup', qv, !0),
      a.removeEventListener('click', tN, !0),
      r.removeEventListener('focus', nN, !0),
      r.removeEventListener('blur', rN, !1),
      typeof PointerEvent < 'u'
        ? (a.removeEventListener('pointerdown', Yi, !0),
          a.removeEventListener('pointermove', Yi, !0),
          a.removeEventListener('pointerup', Yi, !0))
        : (a.removeEventListener('mousedown', Yi, !0),
          a.removeEventListener('mousemove', Yi, !0),
          a.removeEventListener('mouseup', Yi, !0)),
      nh.delete(r))
}
function $z(e) {
  const t = Uh(e)
  let r
  return (
    t.readyState !== 'loading'
      ? tS(e)
      : ((r = () => {
          tS(e)
        }),
        t.addEventListener('DOMContentLoaded', r)),
    () => iN(e, r)
  )
}
typeof document < 'u' && $z()
function aN() {
  return $h !== 'pointer'
}
const Bz = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset'])
function zz(e, t, r) {
  var a
  const o = typeof window < 'u' ? Tl(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement,
    u =
      typeof window < 'u' ? Tl(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement,
    l = typeof window < 'u' ? Tl(r == null ? void 0 : r.target).HTMLElement : HTMLElement,
    d = typeof window < 'u' ? Tl(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent
  return (
    (e =
      e ||
      ((r == null ? void 0 : r.target) instanceof o &&
        !Bz.has(r == null || (a = r.target) === null || a === void 0 ? void 0 : a.type)) ||
      (r == null ? void 0 : r.target) instanceof u ||
      ((r == null ? void 0 : r.target) instanceof l &&
        (r == null ? void 0 : r.target.isContentEditable))),
    !(e && t === 'keyboard' && r instanceof d && !jz[r.key])
  )
}
function Hz(e, t, r) {
  tS(),
    w.useEffect(() => {
      let a = (o, u) => {
        zz(!!(r != null && r.isTextInput), o, u) && e(aN())
      }
      return (
        Jx.add(a),
        () => {
          Jx.delete(a)
        }
      )
    }, t)
}
function Wz(e) {
  let { isDisabled: t, onBlurWithin: r, onFocusWithin: a, onFocusWithinChange: o } = e,
    u = w.useRef({ isFocusWithin: !1 }),
    l = w.useCallback(
      p => {
        u.current.isFocusWithin &&
          !p.currentTarget.contains(p.relatedTarget) &&
          ((u.current.isFocusWithin = !1), r && r(p), o && o(!1))
      },
      [r, o, u]
    ),
    d = eN(l),
    h = w.useCallback(
      p => {
        !u.current.isFocusWithin &&
          document.activeElement === p.target &&
          (a && a(p), o && o(!0), (u.current.isFocusWithin = !0), d(p))
      },
      [a, o, d]
    )
  return t
    ? { focusWithinProps: { onFocus: void 0, onBlur: void 0 } }
    : { focusWithinProps: { onFocus: h, onBlur: l } }
}
let Gv = !1,
  nx = 0
function nS() {
  ;(Gv = !0),
    setTimeout(() => {
      Gv = !1
    }, 50)
}
function wO(e) {
  e.pointerType === 'touch' && nS()
}
function Yz() {
  if (!(typeof document > 'u'))
    return (
      typeof PointerEvent < 'u'
        ? document.addEventListener('pointerup', wO)
        : document.addEventListener('touchend', nS),
      nx++,
      () => {
        nx--,
          !(nx > 0) &&
            (typeof PointerEvent < 'u'
              ? document.removeEventListener('pointerup', wO)
              : document.removeEventListener('touchend', nS))
      }
    )
}
function oN(e) {
  let { onHoverStart: t, onHoverChange: r, onHoverEnd: a, isDisabled: o } = e,
    [u, l] = w.useState(!1),
    d = w.useRef({ isHovered: !1, ignoreEmulatedMouseEvents: !1, pointerType: '', target: null }).current
  w.useEffect(Yz, [])
  let { hoverProps: h, triggerHoverEnd: p } = w.useMemo(() => {
    let v = (x, C) => {
        if (
          ((d.pointerType = C), o || C === 'touch' || d.isHovered || !x.currentTarget.contains(x.target))
        )
          return
        d.isHovered = !0
        let _ = x.currentTarget
        ;(d.target = _), t && t({ type: 'hoverstart', target: _, pointerType: C }), r && r(!0), l(!0)
      },
      g = (x, C) => {
        if (((d.pointerType = ''), (d.target = null), C === 'touch' || !d.isHovered)) return
        d.isHovered = !1
        let _ = x.currentTarget
        a && a({ type: 'hoverend', target: _, pointerType: C }), r && r(!1), l(!1)
      },
      E = {}
    return (
      typeof PointerEvent < 'u'
        ? ((E.onPointerEnter = x => {
            ;(Gv && x.pointerType === 'mouse') || v(x, x.pointerType)
          }),
          (E.onPointerLeave = x => {
            !o && x.currentTarget.contains(x.target) && g(x, x.pointerType)
          }))
        : ((E.onTouchStart = () => {
            d.ignoreEmulatedMouseEvents = !0
          }),
          (E.onMouseEnter = x => {
            !d.ignoreEmulatedMouseEvents && !Gv && v(x, 'mouse'), (d.ignoreEmulatedMouseEvents = !1)
          }),
          (E.onMouseLeave = x => {
            !o && x.currentTarget.contains(x.target) && g(x, 'mouse')
          })),
      { hoverProps: E, triggerHoverEnd: g }
    )
  }, [t, r, a, o, d])
  return (
    w.useEffect(() => {
      o && p({ currentTarget: d.target }, d.pointerType)
    }, [o]),
    { hoverProps: h, isHovered: u }
  )
}
function sN(e = {}) {
  let { autoFocus: t = !1, isTextInput: r, within: a } = e,
    o = w.useRef({ isFocused: !1, isFocusVisible: t || aN() }),
    [u, l] = w.useState(!1),
    [d, h] = w.useState(() => o.current.isFocused && o.current.isFocusVisible),
    p = w.useCallback(() => h(o.current.isFocused && o.current.isFocusVisible), []),
    v = w.useCallback(
      x => {
        ;(o.current.isFocused = x), l(x), p()
      },
      [p]
    )
  Hz(
    x => {
      ;(o.current.isFocusVisible = x), p()
    },
    [],
    { isTextInput: r }
  )
  let { focusProps: g } = Vz({ isDisabled: a, onFocusChange: v }),
    { focusWithinProps: E } = Wz({ isDisabled: !a, onFocusWithinChange: v })
  return { isFocused: u, isFocusVisible: d, focusProps: a ? E : g }
}
var qz = Object.defineProperty,
  Gz = (e, t, r) =>
    t in e ? qz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r),
  rx = (e, t, r) => (Gz(e, typeof t != 'symbol' ? t + '' : t, r), r)
let Kz = class {
    constructor() {
      rx(this, 'current', this.detect()), rx(this, 'handoffState', 'pending'), rx(this, 'currentId', 0)
    }
    set(t) {
      this.current !== t && ((this.handoffState = 'pending'), (this.currentId = 0), (this.current = t))
    }
    reset() {
      this.set(this.detect())
    }
    nextId() {
      return ++this.currentId
    }
    get isServer() {
      return this.current === 'server'
    }
    get isClient() {
      return this.current === 'client'
    }
    detect() {
      return typeof window > 'u' || typeof document > 'u' ? 'server' : 'client'
    }
    handoff() {
      this.handoffState === 'pending' && (this.handoffState = 'complete')
    }
    get isHandoffComplete() {
      return this.handoffState === 'complete'
    }
  },
  Ll = new Kz()
function Bh(e) {
  return Ll.isServer
    ? null
    : e instanceof Node
      ? e.ownerDocument
      : e != null && e.hasOwnProperty('current') && e.current instanceof Node
        ? e.current.ownerDocument
        : document
}
function lN(e) {
  typeof queueMicrotask == 'function'
    ? queueMicrotask(e)
    : Promise.resolve()
        .then(e)
        .catch(t =>
          setTimeout(() => {
            throw t
          })
        )
}
function Ha() {
  let e = [],
    t = {
      addEventListener(r, a, o, u) {
        return r.addEventListener(a, o, u), t.add(() => r.removeEventListener(a, o, u))
      },
      requestAnimationFrame(...r) {
        let a = requestAnimationFrame(...r)
        return t.add(() => cancelAnimationFrame(a))
      },
      nextFrame(...r) {
        return t.requestAnimationFrame(() => t.requestAnimationFrame(...r))
      },
      setTimeout(...r) {
        let a = setTimeout(...r)
        return t.add(() => clearTimeout(a))
      },
      microTask(...r) {
        let a = { current: !0 }
        return (
          lN(() => {
            a.current && r[0]()
          }),
          t.add(() => {
            a.current = !1
          })
        )
      },
      style(r, a, o) {
        let u = r.style.getPropertyValue(a)
        return (
          Object.assign(r.style, { [a]: o }),
          this.add(() => {
            Object.assign(r.style, { [a]: u })
          })
        )
      },
      group(r) {
        let a = Ha()
        return r(a), this.add(() => a.dispose())
      },
      add(r) {
        return (
          e.includes(r) || e.push(r),
          () => {
            let a = e.indexOf(r)
            if (a >= 0) for (let o of e.splice(a, 1)) o()
          }
        )
      },
      dispose() {
        for (let r of e.splice(0)) r()
      }
    }
  return t
}
function zh() {
  let [e] = w.useState(Ha)
  return w.useEffect(() => () => e.dispose(), [e]), e
}
let An = (e, t) => {
  Ll.isServer ? w.useEffect(e, t) : w.useLayoutEffect(e, t)
}
function Hl(e) {
  let t = w.useRef(e)
  return (
    An(() => {
      t.current = e
    }, [e]),
    t
  )
}
let Ct = function (e) {
  let t = Hl(e)
  return Gt.useCallback((...r) => t.current(...r), [t])
}
function Zz(e) {
  let t = e.width / 2,
    r = e.height / 2
  return { top: e.clientY - r, right: e.clientX + t, bottom: e.clientY + r, left: e.clientX - t }
}
function Xz(e, t) {
  return !(!e || !t || e.right < t.left || e.left > t.right || e.bottom < t.top || e.top > t.bottom)
}
function Qz({ disabled: e = !1 } = {}) {
  let t = w.useRef(null),
    [r, a] = w.useState(!1),
    o = zh(),
    u = Ct(() => {
      ;(t.current = null), a(!1), o.dispose()
    }),
    l = Ct(d => {
      if ((o.dispose(), t.current === null)) {
        ;(t.current = d.currentTarget), a(!0)
        {
          let h = Bh(d.currentTarget)
          o.addEventListener(h, 'pointerup', u, !1),
            o.addEventListener(
              h,
              'pointermove',
              p => {
                if (t.current) {
                  let v = Zz(p)
                  a(Xz(v, t.current.getBoundingClientRect()))
                }
              },
              !1
            ),
            o.addEventListener(h, 'pointercancel', u, !1)
        }
      }
    })
  return { pressed: r, pressProps: e ? {} : { onPointerDown: l, onPointerUp: u, onClick: u } }
}
let Jz = w.createContext(void 0)
function n1() {
  return w.useContext(Jz)
}
function RO(...e) {
  return Array.from(new Set(e.flatMap(t => (typeof t == 'string' ? t.split(' ') : []))))
    .filter(Boolean)
    .join(' ')
}
function _o(e, t, ...r) {
  if (e in t) {
    let o = t[e]
    return typeof o == 'function' ? o(...r) : o
  }
  let a = new Error(
    `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t)
      .map(o => `"${o}"`)
      .join(', ')}.`
  )
  throw (Error.captureStackTrace && Error.captureStackTrace(a, _o), a)
}
var rS = (e => (
    (e[(e.None = 0)] = 'None'),
    (e[(e.RenderStrategy = 1)] = 'RenderStrategy'),
    (e[(e.Static = 2)] = 'Static'),
    e
  ))(rS || {}),
  eH = (e => ((e[(e.Unmount = 0)] = 'Unmount'), (e[(e.Hidden = 1)] = 'Hidden'), e))(eH || {})
function ba({
  ourProps: e,
  theirProps: t,
  slot: r,
  defaultTag: a,
  features: o,
  visible: u = !0,
  name: l,
  mergeRefs: d
}) {
  d = d ?? tH
  let h = uN(t, e)
  if (u) return yv(h, r, a, l, d)
  let p = o ?? 0
  if (p & 2) {
    let { static: v = !1, ...g } = h
    if (v) return yv(g, r, a, l, d)
  }
  if (p & 1) {
    let { unmount: v = !0, ...g } = h
    return _o(v ? 0 : 1, {
      0() {
        return null
      },
      1() {
        return yv({ ...g, hidden: !0, style: { display: 'none' } }, r, a, l, d)
      }
    })
  }
  return yv(h, r, a, l, d)
}
function yv(e, t = {}, r, a, o) {
  let { as: u = r, children: l, refName: d = 'ref', ...h } = ix(e, ['unmount', 'static']),
    p = e.ref !== void 0 ? { [d]: e.ref } : {},
    v = typeof l == 'function' ? l(t) : l
  'className' in h && h.className && typeof h.className == 'function' && (h.className = h.className(t)),
    h['aria-labelledby'] && h['aria-labelledby'] === h.id && (h['aria-labelledby'] = void 0)
  let g = {}
  if (t) {
    let E = !1,
      x = []
    for (let [C, _] of Object.entries(t))
      typeof _ == 'boolean' && (E = !0),
        _ === !0 && x.push(C.replace(/([A-Z])/g, k => `-${k.toLowerCase()}`))
    if (E) {
      g['data-headlessui-state'] = x.join(' ')
      for (let C of x) g[`data-${C}`] = ''
    }
  }
  if (u === w.Fragment && (Object.keys(gl(h)).length > 0 || Object.keys(gl(g)).length > 0))
    if (!w.isValidElement(v) || (Array.isArray(v) && v.length > 1)) {
      if (Object.keys(gl(h)).length > 0)
        throw new Error(
          [
            'Passing props on "Fragment"!',
            '',
            `The current component <${a} /> is rendering a "Fragment".`,
            'However we need to passthrough the following props:',
            Object.keys(gl(h))
              .concat(Object.keys(gl(g)))
              .map(E => `  - ${E}`).join(`
`),
            '',
            'You can apply a few solutions:',
            [
              'Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',
              'Render a single element as the child so that we can forward the props onto that element.'
            ].map(E => `  - ${E}`).join(`
`)
          ].join(`
`)
        )
    } else {
      let E = v.props,
        x = E == null ? void 0 : E.className,
        C = typeof x == 'function' ? (...R) => RO(x(...R), h.className) : RO(x, h.className),
        _ = C ? { className: C } : {},
        k = uN(v.props, gl(ix(h, ['ref'])))
      for (let R in g) R in k && delete g[R]
      return w.cloneElement(v, Object.assign({}, k, g, p, { ref: o(v.ref, p.ref) }, _))
    }
  return w.createElement(
    u,
    Object.assign({}, ix(h, ['ref']), u !== w.Fragment && p, u !== w.Fragment && g),
    v
  )
}
function tH(...e) {
  return e.every(t => t == null)
    ? void 0
    : t => {
        for (let r of e) r != null && (typeof r == 'function' ? r(t) : (r.current = t))
      }
}
function uN(...e) {
  if (e.length === 0) return {}
  if (e.length === 1) return e[0]
  let t = {},
    r = {}
  for (let a of e)
    for (let o in a)
      o.startsWith('on') && typeof a[o] == 'function'
        ? (r[o] != null || (r[o] = []), r[o].push(a[o]))
        : (t[o] = a[o])
  if (t.disabled || t['aria-disabled'])
    for (let a in r)
      /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(a) &&
        (r[a] = [
          o => {
            var u
            return (u = o == null ? void 0 : o.preventDefault) == null ? void 0 : u.call(o)
          }
        ])
  for (let a in r)
    Object.assign(t, {
      [a](o, ...u) {
        let l = r[a]
        for (let d of l) {
          if (
            (o instanceof Event || (o == null ? void 0 : o.nativeEvent) instanceof Event) &&
            o.defaultPrevented
          )
            return
          d(o, ...u)
        }
      }
    })
  return t
}
function r1(...e) {
  if (e.length === 0) return {}
  if (e.length === 1) return e[0]
  let t = {},
    r = {}
  for (let a of e)
    for (let o in a)
      o.startsWith('on') && typeof a[o] == 'function'
        ? (r[o] != null || (r[o] = []), r[o].push(a[o]))
        : (t[o] = a[o])
  for (let a in r)
    Object.assign(t, {
      [a](...o) {
        let u = r[a]
        for (let l of u) l == null || l(...o)
      }
    })
  return t
}
function Ea(e) {
  var t
  return Object.assign(w.forwardRef(e), { displayName: (t = e.displayName) != null ? t : e.name })
}
function gl(e) {
  let t = Object.assign({}, e)
  for (let r in t) t[r] === void 0 && delete t[r]
  return t
}
function ix(e, t = []) {
  let r = Object.assign({}, e)
  for (let a of t) a in r && delete r[a]
  return r
}
function nH(e, t, r) {
  let [a, o] = w.useState(r),
    u = e !== void 0,
    l = w.useRef(u),
    d = w.useRef(!1),
    h = w.useRef(!1)
  return (
    u && !l.current && !d.current
      ? ((d.current = !0),
        (l.current = u),
        console.error(
          'A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.'
        ))
      : !u &&
        l.current &&
        !h.current &&
        ((h.current = !0),
        (l.current = u),
        console.error(
          'A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.'
        )),
    [u ? e : a, Ct(p => (u || o(p), t == null ? void 0 : t(p)))]
  )
}
function rH(e) {
  let [t] = w.useState(e)
  return t
}
function cN(e = {}, t = null, r = []) {
  for (let [a, o] of Object.entries(e)) dN(r, fN(t, a), o)
  return r
}
function fN(e, t) {
  return e ? e + '[' + t + ']' : t
}
function dN(e, t, r) {
  if (Array.isArray(r)) for (let [a, o] of r.entries()) dN(e, fN(t, a.toString()), o)
  else
    r instanceof Date
      ? e.push([t, r.toISOString()])
      : typeof r == 'boolean'
        ? e.push([t, r ? '1' : '0'])
        : typeof r == 'string'
          ? e.push([t, r])
          : typeof r == 'number'
            ? e.push([t, `${r}`])
            : r == null
              ? e.push([t, ''])
              : cN(r, t, e)
}
let iH = 'span'
var i1 = (e => (
  (e[(e.None = 1)] = 'None'), (e[(e.Focusable = 2)] = 'Focusable'), (e[(e.Hidden = 4)] = 'Hidden'), e
))(i1 || {})
function aH(e, t) {
  var r
  let { features: a = 1, ...o } = e,
    u = {
      ref: t,
      'aria-hidden': (a & 2) === 2 ? !0 : (r = o['aria-hidden']) != null ? r : void 0,
      hidden: (a & 4) === 4 ? !0 : void 0,
      style: {
        position: 'fixed',
        top: 1,
        left: 1,
        width: 1,
        height: 0,
        padding: 0,
        margin: -1,
        overflow: 'hidden',
        clip: 'rect(0, 0, 0, 0)',
        whiteSpace: 'nowrap',
        borderWidth: '0',
        ...((a & 4) === 4 && (a & 2) !== 2 && { display: 'none' })
      }
    }
  return ba({ ourProps: u, theirProps: o, slot: {}, defaultTag: iH, name: 'Hidden' })
}
let hN = Ea(aH),
  oH = w.createContext(null)
function sH({ children: e }) {
  let t = w.useContext(oH)
  if (!t) return Gt.createElement(Gt.Fragment, null, e)
  let { target: r } = t
  return r ? Pr.createPortal(Gt.createElement(Gt.Fragment, null, e), r) : null
}
function lH({ data: e, form: t, disabled: r, onReset: a, overrides: o }) {
  let [u, l] = w.useState(null),
    d = zh()
  return (
    w.useEffect(() => {
      if (a && u) return d.addEventListener(u, 'reset', a)
    }, [u, t, a]),
    Gt.createElement(
      sH,
      null,
      Gt.createElement(uH, { setForm: l, formId: t }),
      cN(e).map(([h, p]) =>
        Gt.createElement(hN, {
          features: i1.Hidden,
          ...gl({
            key: h,
            as: 'input',
            type: 'hidden',
            hidden: !0,
            readOnly: !0,
            form: t,
            disabled: r,
            name: h,
            value: p,
            ...o
          })
        })
      )
    )
  )
}
function uH({ setForm: e, formId: t }) {
  return (
    w.useEffect(() => {
      if (t) {
        let r = document.getElementById(t)
        r && e(r)
      }
    }, [e, t]),
    t
      ? null
      : Gt.createElement(hN, {
          features: i1.Hidden,
          as: 'input',
          type: 'hidden',
          hidden: !0,
          readOnly: !0,
          ref: r => {
            if (!r) return
            let a = r.closest('form')
            a && e(a)
          }
        })
  )
}
let cH = w.createContext(void 0)
function pN() {
  return w.useContext(cH)
}
function fH(e) {
  let t = e.parentElement,
    r = null
  for (; t && !(t instanceof HTMLFieldSetElement); )
    t instanceof HTMLLegendElement && (r = t), (t = t.parentElement)
  let a = (t == null ? void 0 : t.getAttribute('disabled')) === ''
  return a && dH(r) ? !1 : a
}
function dH(e) {
  if (!e) return !1
  let t = e.previousElementSibling
  for (; t !== null; ) {
    if (t instanceof HTMLLegendElement) return !1
    t = t.previousElementSibling
  }
  return !0
}
let mN = Symbol()
function hH(e, t = !0) {
  return Object.assign(e, { [mN]: t })
}
function Do(...e) {
  let t = w.useRef(e)
  w.useEffect(() => {
    t.current = e
  }, [e])
  let r = Ct(a => {
    for (let o of t.current) o != null && (typeof o == 'function' ? o(a) : (o.current = a))
  })
  return e.every(a => a == null || (a == null ? void 0 : a[mN])) ? void 0 : r
}
let a1 = w.createContext(null)
a1.displayName = 'DescriptionContext'
function vN() {
  let e = w.useContext(a1)
  if (e === null) {
    let t = new Error('You used a <Description /> component, but it is not inside a relevant parent.')
    throw (Error.captureStackTrace && Error.captureStackTrace(t, vN), t)
  }
  return e
}
function pH() {
  var e, t
  return (t = (e = w.useContext(a1)) == null ? void 0 : e.value) != null ? t : void 0
}
let mH = 'p'
function vH(e, t) {
  let r = w.useId(),
    a = n1(),
    { id: o = `headlessui-description-${r}`, ...u } = e,
    l = vN(),
    d = Do(t)
  An(() => l.register(o), [o, l.register])
  let h = a || !1,
    p = w.useMemo(() => ({ ...l.slot, disabled: h }), [l.slot, h]),
    v = { ref: d, ...l.props, id: o }
  return ba({ ourProps: v, theirProps: u, slot: p, defaultTag: mH, name: l.name || 'Description' })
}
let gH = Ea(vH)
Object.assign(gH, {})
var Zr = (e => (
  (e.Space = ' '),
  (e.Enter = 'Enter'),
  (e.Escape = 'Escape'),
  (e.Backspace = 'Backspace'),
  (e.Delete = 'Delete'),
  (e.ArrowLeft = 'ArrowLeft'),
  (e.ArrowUp = 'ArrowUp'),
  (e.ArrowRight = 'ArrowRight'),
  (e.ArrowDown = 'ArrowDown'),
  (e.Home = 'Home'),
  (e.End = 'End'),
  (e.PageUp = 'PageUp'),
  (e.PageDown = 'PageDown'),
  (e.Tab = 'Tab'),
  e
))(Zr || {})
let yg = w.createContext(null)
yg.displayName = 'LabelContext'
function gN() {
  let e = w.useContext(yg)
  if (e === null) {
    let t = new Error('You used a <Label /> component, but it is not inside a relevant parent.')
    throw (Error.captureStackTrace && Error.captureStackTrace(t, gN), t)
  }
  return e
}
function bg(e) {
  var t, r, a
  let o = (r = (t = w.useContext(yg)) == null ? void 0 : t.value) != null ? r : void 0
  return ((a = e == null ? void 0 : e.length) != null ? a : 0) > 0
    ? [o, ...e].filter(Boolean).join(' ')
    : o
}
function yH({ inherit: e = !1 } = {}) {
  let t = bg(),
    [r, a] = w.useState([]),
    o = e ? [t, ...r].filter(Boolean) : r
  return [
    o.length > 0 ? o.join(' ') : void 0,
    w.useMemo(
      () =>
        function (u) {
          let l = Ct(
              h => (
                a(p => [...p, h]),
                () =>
                  a(p => {
                    let v = p.slice(),
                      g = v.indexOf(h)
                    return g !== -1 && v.splice(g, 1), v
                  })
              )
            ),
            d = w.useMemo(
              () => ({ register: l, slot: u.slot, name: u.name, props: u.props, value: u.value }),
              [l, u.slot, u.name, u.props, u.value]
            )
          return Gt.createElement(yg.Provider, { value: d }, u.children)
        },
      [a]
    )
  ]
}
let bH = 'label'
function EH(e, t) {
  var r
  let a = w.useId(),
    o = gN(),
    u = pN(),
    l = n1(),
    {
      id: d = `headlessui-label-${a}`,
      htmlFor: h = u ?? ((r = o.props) == null ? void 0 : r.htmlFor),
      passive: p = !1,
      ...v
    } = e,
    g = Do(t)
  An(() => o.register(d), [d, o.register])
  let E = Ct(k => {
      let R = k.currentTarget
      if (
        (R instanceof HTMLLabelElement && k.preventDefault(),
        o.props && 'onClick' in o.props && typeof o.props.onClick == 'function' && o.props.onClick(k),
        R instanceof HTMLLabelElement)
      ) {
        let D = document.getElementById(R.htmlFor)
        if (D) {
          let A = D.getAttribute('disabled')
          if (A === 'true' || A === '') return
          let L = D.getAttribute('aria-disabled')
          if (L === 'true' || L === '') return
          ;((D instanceof HTMLInputElement && (D.type === 'radio' || D.type === 'checkbox')) ||
            D.role === 'radio' ||
            D.role === 'checkbox' ||
            D.role === 'switch') &&
            D.click(),
            D.focus({ preventScroll: !0 })
        }
      }
    }),
    x = l || !1,
    C = w.useMemo(() => ({ ...o.slot, disabled: x }), [o.slot, x]),
    _ = { ref: g, ...o.props, id: d, htmlFor: h, onClick: E }
  return (
    p && ('onClick' in _ && (delete _.htmlFor, delete _.onClick), 'onClick' in v && delete v.onClick),
    ba({ ourProps: _, theirProps: v, slot: C, defaultTag: h ? bH : 'div', name: o.name || 'Label' })
  )
}
let xH = Ea(EH),
  SH = Object.assign(xH, {})
function Yu(e, t, r) {
  let a = r.initialDeps ?? [],
    o
  return () => {
    var u, l, d, h
    let p
    r.key && (u = r.debug) != null && u.call(r) && (p = Date.now())
    const v = e()
    if (!(v.length !== a.length || v.some((x, C) => a[C] !== x))) return o
    a = v
    let E
    if (
      (r.key && (l = r.debug) != null && l.call(r) && (E = Date.now()),
      (o = t(...v)),
      r.key && (d = r.debug) != null && d.call(r))
    ) {
      const x = Math.round((Date.now() - p) * 100) / 100,
        C = Math.round((Date.now() - E) * 100) / 100,
        _ = C / 16,
        k = (R, D) => {
          for (R = String(R); R.length < D; ) R = ' ' + R
          return R
        }
      console.info(
        `%c ${k(C, 5)} /${k(x, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * _, 120))}deg 100% 31%);`,
        r == null ? void 0 : r.key
      )
    }
    return (h = r == null ? void 0 : r.onChange) == null || h.call(r, o), o
  }
}
function ax(e, t) {
  if (e === void 0) throw new Error('Unexpected undefined')
  return e
}
const TH = (e, t) => Math.abs(e - t) < 1,
  CH = (e, t, r) => {
    let a
    return function (...o) {
      e.clearTimeout(a), (a = e.setTimeout(() => t.apply(this, o), r))
    }
  },
  wH = e => e,
  RH = e => {
    const t = Math.max(e.startIndex - e.overscan, 0),
      r = Math.min(e.endIndex + e.overscan, e.count - 1),
      a = []
    for (let o = t; o <= r; o++) a.push(o)
    return a
  },
  _H = (e, t) => {
    const r = e.scrollElement
    if (!r) return
    const a = e.targetWindow
    if (!a) return
    const o = l => {
      const { width: d, height: h } = l
      t({ width: Math.round(d), height: Math.round(h) })
    }
    if ((o(r.getBoundingClientRect()), !a.ResizeObserver)) return () => {}
    const u = new a.ResizeObserver(l => {
      const d = l[0]
      if (d != null && d.borderBoxSize) {
        const h = d.borderBoxSize[0]
        if (h) {
          o({ width: h.inlineSize, height: h.blockSize })
          return
        }
      }
      o(r.getBoundingClientRect())
    })
    return (
      u.observe(r, { box: 'border-box' }),
      () => {
        u.unobserve(r)
      }
    )
  },
  _O = { passive: !0 },
  OH = typeof window > 'u' ? !0 : 'onscrollend' in window,
  kH = (e, t) => {
    const r = e.scrollElement
    if (!r) return
    const a = e.targetWindow
    if (!a) return
    let o = 0
    const u = OH
        ? () => {}
        : CH(
            a,
            () => {
              t(o, !1)
            },
            e.options.isScrollingResetDelay
          ),
      l = p => () => {
        const { horizontal: v, isRtl: g } = e.options
        ;(o = v ? r.scrollLeft * ((g && -1) || 1) : r.scrollTop), u(), t(o, p)
      },
      d = l(!0),
      h = l(!1)
    return (
      h(),
      r.addEventListener('scroll', d, _O),
      r.addEventListener('scrollend', h, _O),
      () => {
        r.removeEventListener('scroll', d), r.removeEventListener('scrollend', h)
      }
    )
  },
  AH = (e, t, r) => {
    if (t != null && t.borderBoxSize) {
      const a = t.borderBoxSize[0]
      if (a) return Math.round(a[r.options.horizontal ? 'inlineSize' : 'blockSize'])
    }
    return Math.round(e.getBoundingClientRect()[r.options.horizontal ? 'width' : 'height'])
  },
  DH = (e, { adjustments: t = 0, behavior: r }, a) => {
    var o, u
    const l = e + t
    ;(u = (o = a.scrollElement) == null ? void 0 : o.scrollTo) == null ||
      u.call(o, { [a.options.horizontal ? 'left' : 'top']: l, behavior: r })
  }
class NH {
  constructor(t) {
    ;(this.unsubs = []),
      (this.scrollElement = null),
      (this.targetWindow = null),
      (this.isScrolling = !1),
      (this.scrollToIndexTimeoutId = null),
      (this.measurementsCache = []),
      (this.itemSizeCache = new Map()),
      (this.pendingMeasuredCacheIndexes = []),
      (this.scrollRect = null),
      (this.scrollOffset = null),
      (this.scrollDirection = null),
      (this.scrollAdjustments = 0),
      (this.elementsCache = new Map()),
      (this.observer = (() => {
        let r = null
        const a = () =>
          r ||
          (!this.targetWindow || !this.targetWindow.ResizeObserver
            ? null
            : (r = new this.targetWindow.ResizeObserver(o => {
                o.forEach(u => {
                  this._measureElement(u.target, u)
                })
              })))
        return {
          disconnect: () => {
            var o
            ;(o = a()) == null || o.disconnect(), (r = null)
          },
          observe: o => {
            var u
            return (u = a()) == null ? void 0 : u.observe(o, { box: 'border-box' })
          },
          unobserve: o => {
            var u
            return (u = a()) == null ? void 0 : u.unobserve(o)
          }
        }
      })()),
      (this.range = null),
      (this.setOptions = r => {
        Object.entries(r).forEach(([a, o]) => {
          typeof o > 'u' && delete r[a]
        }),
          (this.options = {
            debug: !1,
            initialOffset: 0,
            overscan: 1,
            paddingStart: 0,
            paddingEnd: 0,
            scrollPaddingStart: 0,
            scrollPaddingEnd: 0,
            horizontal: !1,
            getItemKey: wH,
            rangeExtractor: RH,
            onChange: () => {},
            measureElement: AH,
            initialRect: { width: 0, height: 0 },
            scrollMargin: 0,
            gap: 0,
            indexAttribute: 'data-index',
            initialMeasurementsCache: [],
            lanes: 1,
            isScrollingResetDelay: 150,
            enabled: !0,
            isRtl: !1,
            ...r
          })
      }),
      (this.notify = r => {
        var a, o
        ;(o = (a = this.options).onChange) == null || o.call(a, this, r)
      }),
      (this.maybeNotify = Yu(
        () => (
          this.calculateRange(),
          [
            this.isScrolling,
            this.range ? this.range.startIndex : null,
            this.range ? this.range.endIndex : null
          ]
        ),
        r => {
          this.notify(r)
        },
        {
          key: 'maybeNotify',
          debug: () => this.options.debug,
          initialDeps: [
            this.isScrolling,
            this.range ? this.range.startIndex : null,
            this.range ? this.range.endIndex : null
          ]
        }
      )),
      (this.cleanup = () => {
        this.unsubs.filter(Boolean).forEach(r => r()),
          (this.unsubs = []),
          this.observer.disconnect(),
          (this.scrollElement = null),
          (this.targetWindow = null)
      }),
      (this._didMount = () => () => {
        this.cleanup()
      }),
      (this._willUpdate = () => {
        var r
        const a = this.options.enabled ? this.options.getScrollElement() : null
        if (this.scrollElement !== a) {
          if ((this.cleanup(), !a)) {
            this.maybeNotify()
            return
          }
          ;(this.scrollElement = a),
            this.scrollElement && 'ownerDocument' in this.scrollElement
              ? (this.targetWindow = this.scrollElement.ownerDocument.defaultView)
              : (this.targetWindow = ((r = this.scrollElement) == null ? void 0 : r.window) ?? null),
            this.elementsCache.forEach(o => {
              this.observer.observe(o)
            }),
            this._scrollToOffset(this.getScrollOffset(), { adjustments: void 0, behavior: void 0 }),
            this.unsubs.push(
              this.options.observeElementRect(this, o => {
                ;(this.scrollRect = o), this.maybeNotify()
              })
            ),
            this.unsubs.push(
              this.options.observeElementOffset(this, (o, u) => {
                ;(this.scrollAdjustments = 0),
                  (this.scrollDirection = u
                    ? this.getScrollOffset() < o
                      ? 'forward'
                      : 'backward'
                    : null),
                  (this.scrollOffset = o),
                  (this.isScrolling = u),
                  this.maybeNotify()
              })
            )
        }
      }),
      (this.getSize = () =>
        this.options.enabled
          ? ((this.scrollRect = this.scrollRect ?? this.options.initialRect),
            this.scrollRect[this.options.horizontal ? 'width' : 'height'])
          : ((this.scrollRect = null), 0)),
      (this.getScrollOffset = () =>
        this.options.enabled
          ? ((this.scrollOffset =
              this.scrollOffset ??
              (typeof this.options.initialOffset == 'function'
                ? this.options.initialOffset()
                : this.options.initialOffset)),
            this.scrollOffset)
          : ((this.scrollOffset = null), 0)),
      (this.getFurthestMeasurement = (r, a) => {
        const o = new Map(),
          u = new Map()
        for (let l = a - 1; l >= 0; l--) {
          const d = r[l]
          if (o.has(d.lane)) continue
          const h = u.get(d.lane)
          if (
            (h == null || d.end > h.end ? u.set(d.lane, d) : d.end < h.end && o.set(d.lane, !0),
            o.size === this.options.lanes)
          )
            break
        }
        return u.size === this.options.lanes
          ? Array.from(u.values()).sort((l, d) =>
              l.end === d.end ? l.index - d.index : l.end - d.end
            )[0]
          : void 0
      }),
      (this.getMeasurementOptions = Yu(
        () => [
          this.options.count,
          this.options.paddingStart,
          this.options.scrollMargin,
          this.options.getItemKey,
          this.options.enabled
        ],
        (r, a, o, u, l) => (
          (this.pendingMeasuredCacheIndexes = []),
          { count: r, paddingStart: a, scrollMargin: o, getItemKey: u, enabled: l }
        ),
        { key: !1 }
      )),
      (this.getMeasurements = Yu(
        () => [this.getMeasurementOptions(), this.itemSizeCache],
        ({ count: r, paddingStart: a, scrollMargin: o, getItemKey: u, enabled: l }, d) => {
          if (!l) return (this.measurementsCache = []), this.itemSizeCache.clear(), []
          this.measurementsCache.length === 0 &&
            ((this.measurementsCache = this.options.initialMeasurementsCache),
            this.measurementsCache.forEach(v => {
              this.itemSizeCache.set(v.key, v.size)
            }))
          const h =
            this.pendingMeasuredCacheIndexes.length > 0
              ? Math.min(...this.pendingMeasuredCacheIndexes)
              : 0
          this.pendingMeasuredCacheIndexes = []
          const p = this.measurementsCache.slice(0, h)
          for (let v = h; v < r; v++) {
            const g = u(v),
              E = this.options.lanes === 1 ? p[v - 1] : this.getFurthestMeasurement(p, v),
              x = E ? E.end + this.options.gap : a + o,
              C = d.get(g),
              _ = typeof C == 'number' ? C : this.options.estimateSize(v),
              k = x + _,
              R = E ? E.lane : v % this.options.lanes
            p[v] = { index: v, start: x, size: _, end: k, key: g, lane: R }
          }
          return (this.measurementsCache = p), p
        },
        { key: 'getMeasurements', debug: () => this.options.debug }
      )),
      (this.calculateRange = Yu(
        () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],
        (r, a, o) =>
          (this.range =
            r.length > 0 && a > 0 ? MH({ measurements: r, outerSize: a, scrollOffset: o }) : null),
        { key: 'calculateRange', debug: () => this.options.debug }
      )),
      (this.getIndexes = Yu(
        () => [
          this.options.rangeExtractor,
          this.calculateRange(),
          this.options.overscan,
          this.options.count
        ],
        (r, a, o, u) =>
          a === null ? [] : r({ startIndex: a.startIndex, endIndex: a.endIndex, overscan: o, count: u }),
        { key: 'getIndexes', debug: () => this.options.debug }
      )),
      (this.indexFromElement = r => {
        const a = this.options.indexAttribute,
          o = r.getAttribute(a)
        return o
          ? parseInt(o, 10)
          : (console.warn(`Missing attribute name '${a}={index}' on measured element.`), -1)
      }),
      (this._measureElement = (r, a) => {
        const o = this.indexFromElement(r),
          u = this.measurementsCache[o]
        if (!u) return
        const l = u.key,
          d = this.elementsCache.get(l)
        d !== r &&
          (d && this.observer.unobserve(d), this.observer.observe(r), this.elementsCache.set(l, r)),
          r.isConnected && this.resizeItem(o, this.options.measureElement(r, a, this))
      }),
      (this.resizeItem = (r, a) => {
        const o = this.measurementsCache[r]
        if (!o) return
        const u = this.itemSizeCache.get(o.key) ?? o.size,
          l = a - u
        l !== 0 &&
          ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0
            ? this.shouldAdjustScrollPositionOnItemSizeChange(o, l, this)
            : o.start < this.getScrollOffset() + this.scrollAdjustments) &&
            (this.options.debug && console.info('correction', l),
            this._scrollToOffset(this.getScrollOffset(), {
              adjustments: (this.scrollAdjustments += l),
              behavior: void 0
            })),
          this.pendingMeasuredCacheIndexes.push(o.index),
          (this.itemSizeCache = new Map(this.itemSizeCache.set(o.key, a))),
          this.notify(!1))
      }),
      (this.measureElement = r => {
        if (!r) {
          this.elementsCache.forEach((a, o) => {
            a.isConnected || (this.observer.unobserve(a), this.elementsCache.delete(o))
          })
          return
        }
        this._measureElement(r, void 0)
      }),
      (this.getVirtualItems = Yu(
        () => [this.getIndexes(), this.getMeasurements()],
        (r, a) => {
          const o = []
          for (let u = 0, l = r.length; u < l; u++) {
            const d = r[u],
              h = a[d]
            o.push(h)
          }
          return o
        },
        { key: 'getVirtualItems', debug: () => this.options.debug }
      )),
      (this.getVirtualItemForOffset = r => {
        const a = this.getMeasurements()
        if (a.length !== 0) return ax(a[yN(0, a.length - 1, o => ax(a[o]).start, r)])
      }),
      (this.getOffsetForAlignment = (r, a) => {
        const o = this.getSize(),
          u = this.getScrollOffset()
        a === 'auto' && (r <= u ? (a = 'start') : r >= u + o ? (a = 'end') : (a = 'start')),
          a === 'start' ? (r = r) : a === 'end' ? (r = r - o) : a === 'center' && (r = r - o / 2)
        const l = this.options.horizontal ? 'scrollWidth' : 'scrollHeight',
          h =
            (this.scrollElement
              ? 'document' in this.scrollElement
                ? this.scrollElement.document.documentElement[l]
                : this.scrollElement[l]
              : 0) - o
        return Math.max(Math.min(h, r), 0)
      }),
      (this.getOffsetForIndex = (r, a = 'auto') => {
        r = Math.max(0, Math.min(r, this.options.count - 1))
        const o = this.measurementsCache[r]
        if (!o) return
        const u = this.getSize(),
          l = this.getScrollOffset()
        if (a === 'auto')
          if (o.end >= l + u - this.options.scrollPaddingEnd) a = 'end'
          else if (o.start <= l + this.options.scrollPaddingStart) a = 'start'
          else return [l, a]
        const d =
          a === 'end' ? o.end + this.options.scrollPaddingEnd : o.start - this.options.scrollPaddingStart
        return [this.getOffsetForAlignment(d, a), a]
      }),
      (this.isDynamicMode = () => this.elementsCache.size > 0),
      (this.cancelScrollToIndex = () => {
        this.scrollToIndexTimeoutId !== null &&
          this.targetWindow &&
          (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId),
          (this.scrollToIndexTimeoutId = null))
      }),
      (this.scrollToOffset = (r, { align: a = 'start', behavior: o } = {}) => {
        this.cancelScrollToIndex(),
          o === 'smooth' &&
            this.isDynamicMode() &&
            console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.'),
          this._scrollToOffset(this.getOffsetForAlignment(r, a), { adjustments: void 0, behavior: o })
      }),
      (this.scrollToIndex = (r, { align: a = 'auto', behavior: o } = {}) => {
        ;(r = Math.max(0, Math.min(r, this.options.count - 1))),
          this.cancelScrollToIndex(),
          o === 'smooth' &&
            this.isDynamicMode() &&
            console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.')
        const u = this.getOffsetForIndex(r, a)
        if (!u) return
        const [l, d] = u
        this._scrollToOffset(l, { adjustments: void 0, behavior: o }),
          o !== 'smooth' &&
            this.isDynamicMode() &&
            this.targetWindow &&
            (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
              if (
                ((this.scrollToIndexTimeoutId = null),
                this.elementsCache.has(this.options.getItemKey(r)))
              ) {
                const [p] = ax(this.getOffsetForIndex(r, d))
                TH(p, this.getScrollOffset()) || this.scrollToIndex(r, { align: d, behavior: o })
              } else this.scrollToIndex(r, { align: d, behavior: o })
            }))
      }),
      (this.scrollBy = (r, { behavior: a } = {}) => {
        this.cancelScrollToIndex(),
          a === 'smooth' &&
            this.isDynamicMode() &&
            console.warn('The `smooth` scroll behavior is not fully supported with dynamic size.'),
          this._scrollToOffset(this.getScrollOffset() + r, { adjustments: void 0, behavior: a })
      }),
      (this.getTotalSize = () => {
        var r
        const a = this.getMeasurements()
        let o
        return (
          a.length === 0
            ? (o = this.options.paddingStart)
            : (o =
                this.options.lanes === 1
                  ? (((r = a[a.length - 1]) == null ? void 0 : r.end) ?? 0)
                  : Math.max(...a.slice(-this.options.lanes).map(u => u.end))),
          o - this.options.scrollMargin + this.options.paddingEnd
        )
      }),
      (this._scrollToOffset = (r, { adjustments: a, behavior: o }) => {
        this.options.scrollToFn(r, { behavior: o, adjustments: a }, this)
      }),
      (this.measure = () => {
        ;(this.itemSizeCache = new Map()), this.notify(!1)
      }),
      this.setOptions(t)
  }
}
const yN = (e, t, r, a) => {
  for (; e <= t; ) {
    const o = ((e + t) / 2) | 0,
      u = r(o)
    if (u < a) e = o + 1
    else if (u > a) t = o - 1
    else return o
  }
  return e > 0 ? e - 1 : 0
}
function MH({ measurements: e, outerSize: t, scrollOffset: r }) {
  const a = e.length - 1,
    u = yN(0, a, d => e[d].start, r)
  let l = u
  for (; l < a && e[l].end < r + t; ) l++
  return { startIndex: u, endIndex: l }
}
const LH = typeof document < 'u' ? w.useLayoutEffect : w.useEffect
function PH(e) {
  const t = w.useReducer(() => ({}), {})[1],
    r = {
      ...e,
      onChange: (o, u) => {
        var l
        u ? Pr.flushSync(t) : t(), (l = e.onChange) == null || l.call(e, o, u)
      }
    },
    [a] = w.useState(() => new NH(r))
  return a.setOptions(r), w.useEffect(() => a._didMount(), []), LH(() => a._willUpdate()), a
}
function IH(e) {
  return PH({ observeElementRect: _H, observeElementOffset: kH, scrollToFn: DH, ...e })
}
function FH(e, t) {
  return e !== null &&
    t !== null &&
    typeof e == 'object' &&
    typeof t == 'object' &&
    'id' in e &&
    'id' in t
    ? e.id === t.id
    : e === t
}
function VH(e = FH) {
  return w.useCallback(
    (t, r) => {
      if (typeof e == 'string') {
        let a = e
        return (t == null ? void 0 : t[a]) === (r == null ? void 0 : r[a])
      }
      return e(t, r)
    },
    [e]
  )
}
function jH(e) {
  if (e === null) return { width: 0, height: 0 }
  let { width: t, height: r } = e.getBoundingClientRect()
  return { width: t, height: r }
}
function OO(e, t = !1) {
  let [r, a] = w.useReducer(() => ({}), {}),
    o = w.useMemo(() => jH(e), [e, r])
  return (
    An(() => {
      if (!e) return
      let u = new ResizeObserver(a)
      return (
        u.observe(e),
        () => {
          u.disconnect()
        }
      )
    }, [e]),
    t ? { width: `${o.width}px`, height: `${o.height}px` } : o
  )
}
let UH = class extends Map {
  constructor(t) {
    super(), (this.factory = t)
  }
  get(t) {
    let r = super.get(t)
    return r === void 0 && ((r = this.factory(t)), this.set(t, r)), r
  }
}
function bN(e, t) {
  let r = e(),
    a = new Set()
  return {
    getSnapshot() {
      return r
    },
    subscribe(o) {
      return a.add(o), () => a.delete(o)
    },
    dispatch(o, ...u) {
      let l = t[o].call(r, ...u)
      l && ((r = l), a.forEach(d => d()))
    }
  }
}
function EN(e) {
  return w.useSyncExternalStore(e.subscribe, e.getSnapshot, e.getSnapshot)
}
let $H = new UH(() =>
  bN(() => [], {
    ADD(e) {
      return this.includes(e) ? this : [...this, e]
    },
    REMOVE(e) {
      let t = this.indexOf(e)
      if (t === -1) return this
      let r = this.slice()
      return r.splice(t, 1), r
    }
  })
)
function o1(e, t) {
  let r = $H.get(t),
    a = w.useId(),
    o = EN(r)
  if (
    (An(() => {
      if (e) return r.dispatch('ADD', a), () => r.dispatch('REMOVE', a)
    }, [r, e]),
    !e)
  )
    return !1
  let u = o.indexOf(a),
    l = o.length
  return u === -1 && ((u = l), (l += 1)), u === l - 1
}
let iS = new Map(),
  rh = new Map()
function kO(e) {
  var t
  let r = (t = rh.get(e)) != null ? t : 0
  return (
    rh.set(e, r + 1),
    r !== 0
      ? () => AO(e)
      : (iS.set(e, { 'aria-hidden': e.getAttribute('aria-hidden'), inert: e.inert }),
        e.setAttribute('aria-hidden', 'true'),
        (e.inert = !0),
        () => AO(e))
  )
}
function AO(e) {
  var t
  let r = (t = rh.get(e)) != null ? t : 1
  if ((r === 1 ? rh.delete(e) : rh.set(e, r - 1), r !== 1)) return
  let a = iS.get(e)
  a &&
    (a['aria-hidden'] === null
      ? e.removeAttribute('aria-hidden')
      : e.setAttribute('aria-hidden', a['aria-hidden']),
    (e.inert = a.inert),
    iS.delete(e))
}
function BH(e, { allowed: t, disallowed: r } = {}) {
  let a = o1(e, 'inert-others')
  An(() => {
    var o, u
    if (!a) return
    let l = Ha()
    for (let h of (o = r == null ? void 0 : r()) != null ? o : []) h && l.add(kO(h))
    let d = (u = t == null ? void 0 : t()) != null ? u : []
    for (let h of d) {
      if (!h) continue
      let p = Bh(h)
      if (!p) continue
      let v = h.parentElement
      for (; v && v !== p.body; ) {
        for (let g of v.children) d.some(E => g.contains(E)) || l.add(kO(g))
        v = v.parentElement
      }
    }
    return l.dispose
  }, [a, t, r])
}
function zH(e, t, r) {
  let a = Hl(o => {
    let u = o.getBoundingClientRect()
    u.x === 0 && u.y === 0 && u.width === 0 && u.height === 0 && r()
  })
  w.useEffect(() => {
    if (!e) return
    let o = t === null ? null : t instanceof HTMLElement ? t : t.current
    if (!o) return
    let u = Ha()
    if (typeof ResizeObserver < 'u') {
      let l = new ResizeObserver(() => a.current(o))
      l.observe(o), u.add(() => l.disconnect())
    }
    if (typeof IntersectionObserver < 'u') {
      let l = new IntersectionObserver(() => a.current(o))
      l.observe(o), u.add(() => l.disconnect())
    }
    return () => u.dispose()
  }, [t, a, e])
}
let aS = [
  '[contentEditable=true]',
  '[tabindex]',
  'a[href]',
  'area[href]',
  'button:not([disabled])',
  'iframe',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])'
]
  .map(e => `${e}:not([tabindex='-1'])`)
  .join(',')
var HH = (e => (
    (e[(e.First = 1)] = 'First'),
    (e[(e.Previous = 2)] = 'Previous'),
    (e[(e.Next = 4)] = 'Next'),
    (e[(e.Last = 8)] = 'Last'),
    (e[(e.WrapAround = 16)] = 'WrapAround'),
    (e[(e.NoScroll = 32)] = 'NoScroll'),
    (e[(e.AutoFocus = 64)] = 'AutoFocus'),
    e
  ))(HH || {}),
  WH = (e => (
    (e[(e.Error = 0)] = 'Error'),
    (e[(e.Overflow = 1)] = 'Overflow'),
    (e[(e.Success = 2)] = 'Success'),
    (e[(e.Underflow = 3)] = 'Underflow'),
    e
  ))(WH || {}),
  YH = (e => ((e[(e.Previous = -1)] = 'Previous'), (e[(e.Next = 1)] = 'Next'), e))(YH || {}),
  xN = (e => ((e[(e.Strict = 0)] = 'Strict'), (e[(e.Loose = 1)] = 'Loose'), e))(xN || {})
function qH(e, t = 0) {
  var r
  return e === ((r = Bh(e)) == null ? void 0 : r.body)
    ? !1
    : _o(t, {
        0() {
          return e.matches(aS)
        },
        1() {
          let a = e
          for (; a !== null; ) {
            if (a.matches(aS)) return !0
            a = a.parentElement
          }
          return !1
        }
      })
}
var GH = (e => ((e[(e.Keyboard = 0)] = 'Keyboard'), (e[(e.Mouse = 1)] = 'Mouse'), e))(GH || {})
typeof window < 'u' &&
  typeof document < 'u' &&
  (document.addEventListener(
    'keydown',
    e => {
      e.metaKey ||
        e.altKey ||
        e.ctrlKey ||
        (document.documentElement.dataset.headlessuiFocusVisible = '')
    },
    !0
  ),
  document.addEventListener(
    'click',
    e => {
      e.detail === 1
        ? delete document.documentElement.dataset.headlessuiFocusVisible
        : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = '')
    },
    !0
  ))
function KH(e, t = r => r) {
  return e.slice().sort((r, a) => {
    let o = t(r),
      u = t(a)
    if (o === null || u === null) return 0
    let l = o.compareDocumentPosition(u)
    return l & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
  })
}
function SN() {
  return (
    /iPhone/gi.test(window.navigator.platform) ||
    (/Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0)
  )
}
function ZH() {
  return /Android/gi.test(window.navigator.userAgent)
}
function TN() {
  return SN() || ZH()
}
function Pd(e, t, r, a) {
  let o = Hl(r)
  w.useEffect(() => {
    if (!e) return
    function u(l) {
      o.current(l)
    }
    return document.addEventListener(t, u, a), () => document.removeEventListener(t, u, a)
  }, [e, t, a])
}
function XH(e, t, r, a) {
  let o = Hl(r)
  w.useEffect(() => {
    if (!e) return
    function u(l) {
      o.current(l)
    }
    return window.addEventListener(t, u, a), () => window.removeEventListener(t, u, a)
  }, [e, t, a])
}
const DO = 30
function QH(e, t, r) {
  let a = o1(e, 'outside-click'),
    o = Hl(r),
    u = w.useCallback(
      function (h, p) {
        if (h.defaultPrevented) return
        let v = p(h)
        if (v === null || !v.getRootNode().contains(v) || !v.isConnected) return
        let g = (function E(x) {
          return typeof x == 'function' ? E(x()) : Array.isArray(x) || x instanceof Set ? x : [x]
        })(t)
        for (let E of g)
          if (E !== null && (E.contains(v) || (h.composed && h.composedPath().includes(E)))) return
        return !qH(v, xN.Loose) && v.tabIndex !== -1 && h.preventDefault(), o.current(h, v)
      },
      [o, t]
    ),
    l = w.useRef(null)
  Pd(
    a,
    'pointerdown',
    h => {
      var p, v
      l.current =
        ((v = (p = h.composedPath) == null ? void 0 : p.call(h)) == null ? void 0 : v[0]) || h.target
    },
    !0
  ),
    Pd(
      a,
      'mousedown',
      h => {
        var p, v
        l.current =
          ((v = (p = h.composedPath) == null ? void 0 : p.call(h)) == null ? void 0 : v[0]) || h.target
      },
      !0
    ),
    Pd(
      a,
      'click',
      h => {
        TN() || (l.current && (u(h, () => l.current), (l.current = null)))
      },
      !0
    )
  let d = w.useRef({ x: 0, y: 0 })
  Pd(
    a,
    'touchstart',
    h => {
      ;(d.current.x = h.touches[0].clientX), (d.current.y = h.touches[0].clientY)
    },
    !0
  ),
    Pd(
      a,
      'touchend',
      h => {
        let p = { x: h.changedTouches[0].clientX, y: h.changedTouches[0].clientY }
        if (!(Math.abs(p.x - d.current.x) >= DO || Math.abs(p.y - d.current.y) >= DO))
          return u(h, () => (h.target instanceof HTMLElement ? h.target : null))
      },
      !0
    ),
    XH(
      a,
      'blur',
      h =>
        u(h, () =>
          window.document.activeElement instanceof HTMLIFrameElement
            ? window.document.activeElement
            : null
        ),
      !0
    )
}
function Eg(...e) {
  return w.useMemo(() => Bh(...e), [...e])
}
function JH(e, t, r, a) {
  let o = Hl(r)
  w.useEffect(() => {
    e = e ?? window
    function u(l) {
      o.current(l)
    }
    return e.addEventListener(t, u, a), () => e.removeEventListener(t, u, a)
  }, [e, t, a])
}
function CN(e) {
  let t = w.useRef({ value: '', selectionStart: null, selectionEnd: null })
  return (
    JH(e, 'blur', r => {
      let a = r.target
      a instanceof HTMLInputElement &&
        (t.current = { value: a.value, selectionStart: a.selectionStart, selectionEnd: a.selectionEnd })
    }),
    Ct(() => {
      if (document.activeElement !== e && e instanceof HTMLInputElement && e.isConnected) {
        if ((e.focus({ preventScroll: !0 }), e.value !== t.current.value))
          e.setSelectionRange(e.value.length, e.value.length)
        else {
          let { selectionStart: r, selectionEnd: a } = t.current
          r !== null && a !== null && e.setSelectionRange(r, a)
        }
        t.current = { value: '', selectionStart: null, selectionEnd: null }
      }
    })
  )
}
function eW(e, t) {
  return w.useMemo(() => {
    var r
    if (e.type) return e.type
    let a = (r = e.as) != null ? r : 'button'
    if (
      (typeof a == 'string' && a.toLowerCase() === 'button') ||
      ((t == null ? void 0 : t.tagName) === 'BUTTON' && !t.hasAttribute('type'))
    )
      return 'button'
  }, [e.type, e.as, t])
}
function tW() {
  let e
  return {
    before({ doc: t }) {
      var r
      let a = t.documentElement,
        o = (r = t.defaultView) != null ? r : window
      e = Math.max(0, o.innerWidth - a.clientWidth)
    },
    after({ doc: t, d: r }) {
      let a = t.documentElement,
        o = Math.max(0, a.clientWidth - a.offsetWidth),
        u = Math.max(0, e - o)
      r.style(a, 'paddingRight', `${u}px`)
    }
  }
}
function nW() {
  return SN()
    ? {
        before({ doc: e, d: t, meta: r }) {
          function a(o) {
            return r.containers.flatMap(u => u()).some(u => u.contains(o))
          }
          t.microTask(() => {
            var o
            if (window.getComputedStyle(e.documentElement).scrollBehavior !== 'auto') {
              let d = Ha()
              d.style(e.documentElement, 'scrollBehavior', 'auto'),
                t.add(() => t.microTask(() => d.dispose()))
            }
            let u = (o = window.scrollY) != null ? o : window.pageYOffset,
              l = null
            t.addEventListener(
              e,
              'click',
              d => {
                if (d.target instanceof HTMLElement)
                  try {
                    let h = d.target.closest('a')
                    if (!h) return
                    let { hash: p } = new URL(h.href),
                      v = e.querySelector(p)
                    v && !a(v) && (l = v)
                  } catch {}
              },
              !0
            ),
              t.addEventListener(e, 'touchstart', d => {
                if (d.target instanceof HTMLElement)
                  if (a(d.target)) {
                    let h = d.target
                    for (; h.parentElement && a(h.parentElement); ) h = h.parentElement
                    t.style(h, 'overscrollBehavior', 'contain')
                  } else t.style(d.target, 'touchAction', 'none')
              }),
              t.addEventListener(
                e,
                'touchmove',
                d => {
                  if (d.target instanceof HTMLElement) {
                    if (d.target.tagName === 'INPUT') return
                    if (a(d.target)) {
                      let h = d.target
                      for (
                        ;
                        h.parentElement &&
                        h.dataset.headlessuiPortal !== '' &&
                        !(h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth);

                      )
                        h = h.parentElement
                      h.dataset.headlessuiPortal === '' && d.preventDefault()
                    } else d.preventDefault()
                  }
                },
                { passive: !1 }
              ),
              t.add(() => {
                var d
                let h = (d = window.scrollY) != null ? d : window.pageYOffset
                u !== h && window.scrollTo(0, u),
                  l && l.isConnected && (l.scrollIntoView({ block: 'nearest' }), (l = null))
              })
          })
        }
      }
    : {}
}
function rW() {
  return {
    before({ doc: e, d: t }) {
      t.style(e.documentElement, 'overflow', 'hidden')
    }
  }
}
function iW(e) {
  let t = {}
  for (let r of e) Object.assign(t, r(t))
  return t
}
let Cl = bN(() => new Map(), {
  PUSH(e, t) {
    var r
    let a = (r = this.get(e)) != null ? r : { doc: e, count: 0, d: Ha(), meta: new Set() }
    return a.count++, a.meta.add(t), this.set(e, a), this
  },
  POP(e, t) {
    let r = this.get(e)
    return r && (r.count--, r.meta.delete(t)), this
  },
  SCROLL_PREVENT({ doc: e, d: t, meta: r }) {
    let a = { doc: e, d: t, meta: iW(r) },
      o = [nW(), tW(), rW()]
    o.forEach(({ before: u }) => (u == null ? void 0 : u(a))),
      o.forEach(({ after: u }) => (u == null ? void 0 : u(a)))
  },
  SCROLL_ALLOW({ d: e }) {
    e.dispose()
  },
  TEARDOWN({ doc: e }) {
    this.delete(e)
  }
})
Cl.subscribe(() => {
  let e = Cl.getSnapshot(),
    t = new Map()
  for (let [r] of e) t.set(r, r.documentElement.style.overflow)
  for (let r of e.values()) {
    let a = t.get(r.doc) === 'hidden',
      o = r.count !== 0
    ;((o && !a) || (!o && a)) && Cl.dispatch(r.count > 0 ? 'SCROLL_PREVENT' : 'SCROLL_ALLOW', r),
      r.count === 0 && Cl.dispatch('TEARDOWN', r)
  }
})
function aW(e, t, r = () => ({ containers: [] })) {
  let a = EN(Cl),
    o = t ? a.get(t) : void 0,
    u = o ? o.count > 0 : !1
  return (
    An(() => {
      if (!(!t || !e)) return Cl.dispatch('PUSH', t, r), () => Cl.dispatch('POP', t, r)
    }, [e, t]),
    u
  )
}
function oW(e, t, r = () => [document.body]) {
  let a = o1(e, 'scroll-lock')
  aW(a, t, o => {
    var u
    return { containers: [...((u = o.containers) != null ? u : []), r] }
  })
}
function NO(e) {
  return [e.screenX, e.screenY]
}
function sW() {
  let e = w.useRef([-1, -1])
  return {
    wasMoved(t) {
      let r = NO(t)
      return e.current[0] === r[0] && e.current[1] === r[1] ? !1 : ((e.current = r), !0)
    },
    update(t) {
      e.current = NO(t)
    }
  }
}
function lW(e = 0) {
  let [t, r] = w.useState(e),
    a = w.useCallback(h => r(h), [t]),
    o = w.useCallback(h => r(p => p | h), [t]),
    u = w.useCallback(h => (t & h) === h, [t]),
    l = w.useCallback(h => r(p => p & ~h), [r]),
    d = w.useCallback(h => r(p => p ^ h), [r])
  return { flags: t, setFlag: a, addFlag: o, hasFlag: u, removeFlag: l, toggleFlag: d }
}
var uW = (e => (
  (e[(e.None = 0)] = 'None'),
  (e[(e.Closed = 1)] = 'Closed'),
  (e[(e.Enter = 2)] = 'Enter'),
  (e[(e.Leave = 4)] = 'Leave'),
  e
))(uW || {})
function cW(e) {
  let t = {}
  for (let r in e) e[r] === !0 && (t[`data-${r}`] = '')
  return t
}
function fW(e, t, r, a) {
  let [o, u] = w.useState(r),
    { hasFlag: l, addFlag: d, removeFlag: h } = lW(e && o ? 3 : 0),
    p = w.useRef(!1),
    v = w.useRef(!1),
    g = zh()
  return (
    An(() => {
      var E
      if (e) {
        if ((r && u(!0), !t)) {
          r && d(3)
          return
        }
        return (
          (E = void 0) == null || E.call(a, r),
          dW(t, {
            inFlight: p,
            prepare() {
              v.current ? (v.current = !1) : (v.current = p.current),
                (p.current = !0),
                !v.current && (r ? (d(3), h(4)) : (d(4), h(2)))
            },
            run() {
              v.current ? (r ? (h(3), d(4)) : (h(4), d(3))) : r ? h(1) : d(1)
            },
            done() {
              var x
              ;(v.current && typeof t.getAnimations == 'function' && t.getAnimations().length > 0) ||
                ((p.current = !1), h(7), r || u(!1), (x = void 0) == null || x.call(a, r))
            }
          })
        )
      }
    }, [e, r, t, g]),
    e
      ? [o, { closed: l(1), enter: l(2), leave: l(4), transition: l(2) || l(4) }]
      : [r, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }]
  )
}
function dW(e, { prepare: t, run: r, done: a, inFlight: o }) {
  let u = Ha()
  return (
    pW(e, { prepare: t, inFlight: o }),
    u.nextFrame(() => {
      r(),
        u.requestAnimationFrame(() => {
          u.add(hW(e, a))
        })
    }),
    u.dispose
  )
}
function hW(e, t) {
  let r = Ha()
  if (!e) return r.dispose
  let a = !1
  r.add(() => {
    a = !0
  })
  let o = e.getAnimations().filter(u => u instanceof CSSTransition)
  return o.length === 0
    ? (t(), r.dispose)
    : (Promise.allSettled(o.map(u => u.finished)).then(() => {
        a || t()
      }),
      r.dispose)
}
function pW(e, { inFlight: t, prepare: r }) {
  if (t != null && t.current) {
    r()
    return
  }
  let a = e.style.transition
  ;(e.style.transition = 'none'), r(), e.offsetHeight, (e.style.transition = a)
}
function mW(e, { container: t, accept: r, walk: a }) {
  let o = w.useRef(r),
    u = w.useRef(a)
  w.useEffect(() => {
    ;(o.current = r), (u.current = a)
  }, [r, a]),
    An(() => {
      if (!t || !e) return
      let l = Bh(t)
      if (!l) return
      let d = o.current,
        h = u.current,
        p = Object.assign(g => d(g), { acceptNode: d }),
        v = l.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, p, !1)
      for (; v.nextNode(); ) h(v.currentNode)
    }, [t, e, o, u])
}
function MO(e, t) {
  let r = w.useRef([]),
    a = Ct(e)
  w.useEffect(() => {
    let o = [...r.current]
    for (let [u, l] of t.entries())
      if (r.current[u] !== l) {
        let d = a(t, o)
        return (r.current = t), d
      }
  }, [a, ...t])
}
function Fc(e) {
  return wN(e) ? (e.nodeName || '').toLowerCase() : '#document'
}
function _i(e) {
  var t
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function No(e) {
  var t
  return (t = (wN(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement
}
function wN(e) {
  return e instanceof Node || e instanceof _i(e).Node
}
function Fr(e) {
  return e instanceof Element || e instanceof _i(e).Element
}
function Wa(e) {
  return e instanceof HTMLElement || e instanceof _i(e).HTMLElement
}
function LO(e) {
  return typeof ShadowRoot > 'u' ? !1 : e instanceof ShadowRoot || e instanceof _i(e).ShadowRoot
}
function Hh(e) {
  const { overflow: t, overflowX: r, overflowY: a, display: o } = ga(e)
  return /auto|scroll|overlay|hidden|clip/.test(t + a + r) && !['inline', 'contents'].includes(o)
}
function vW(e) {
  return ['table', 'td', 'th'].includes(Fc(e))
}
function xg(e) {
  return [':popover-open', ':modal'].some(t => {
    try {
      return e.matches(t)
    } catch {
      return !1
    }
  })
}
function s1(e) {
  const t = l1(),
    r = Fr(e) ? ga(e) : e
  return (
    r.transform !== 'none' ||
    r.perspective !== 'none' ||
    (r.containerType ? r.containerType !== 'normal' : !1) ||
    (!t && (r.backdropFilter ? r.backdropFilter !== 'none' : !1)) ||
    (!t && (r.filter ? r.filter !== 'none' : !1)) ||
    ['transform', 'perspective', 'filter'].some(a => (r.willChange || '').includes(a)) ||
    ['paint', 'layout', 'strict', 'content'].some(a => (r.contain || '').includes(a))
  )
}
function gW(e) {
  let t = ws(e)
  for (; Wa(t) && !kc(t); ) {
    if (s1(t)) return t
    if (xg(t)) return null
    t = ws(t)
  }
  return null
}
function l1() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none')
}
function kc(e) {
  return ['html', 'body', '#document'].includes(Fc(e))
}
function ga(e) {
  return _i(e).getComputedStyle(e)
}
function Sg(e) {
  return Fr(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY }
}
function ws(e) {
  if (Fc(e) === 'html') return e
  const t = e.assignedSlot || e.parentNode || (LO(e) && e.host) || No(e)
  return LO(t) ? t.host : t
}
function RN(e) {
  const t = ws(e)
  return kc(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : Wa(t) && Hh(t) ? t : RN(t)
}
function fh(e, t, r) {
  var a
  t === void 0 && (t = []), r === void 0 && (r = !0)
  const o = RN(e),
    u = o === ((a = e.ownerDocument) == null ? void 0 : a.body),
    l = _i(o)
  if (u) {
    const d = oS(l)
    return t.concat(l, l.visualViewport || [], Hh(o) ? o : [], d && r ? fh(d) : [])
  }
  return t.concat(o, fh(o, [], r))
}
function oS(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function yW() {
  const e = navigator.userAgentData
  return e && Array.isArray(e.brands)
    ? e.brands
        .map(t => {
          let { brand: r, version: a } = t
          return r + '/' + a
        })
        .join(' ')
    : navigator.userAgent
}
const bs = Math.min,
  wi = Math.max,
  Kv = Math.round,
  bv = Math.floor,
  Rs = e => ({ x: e, y: e }),
  bW = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
  EW = { start: 'end', end: 'start' }
function PO(e, t, r) {
  return wi(e, bs(t, r))
}
function Vc(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function _s(e) {
  return e.split('-')[0]
}
function Wh(e) {
  return e.split('-')[1]
}
function _N(e) {
  return e === 'x' ? 'y' : 'x'
}
function ON(e) {
  return e === 'y' ? 'height' : 'width'
}
function jl(e) {
  return ['top', 'bottom'].includes(_s(e)) ? 'y' : 'x'
}
function kN(e) {
  return _N(jl(e))
}
function xW(e, t, r) {
  r === void 0 && (r = !1)
  const a = Wh(e),
    o = kN(e),
    u = ON(o)
  let l = o === 'x' ? (a === (r ? 'end' : 'start') ? 'right' : 'left') : a === 'start' ? 'bottom' : 'top'
  return t.reference[u] > t.floating[u] && (l = Zv(l)), [l, Zv(l)]
}
function SW(e) {
  const t = Zv(e)
  return [sS(e), t, sS(t)]
}
function sS(e) {
  return e.replace(/start|end/g, t => EW[t])
}
function TW(e, t, r) {
  const a = ['left', 'right'],
    o = ['right', 'left'],
    u = ['top', 'bottom'],
    l = ['bottom', 'top']
  switch (e) {
    case 'top':
    case 'bottom':
      return r ? (t ? o : a) : t ? a : o
    case 'left':
    case 'right':
      return t ? u : l
    default:
      return []
  }
}
function CW(e, t, r, a) {
  const o = Wh(e)
  let u = TW(_s(e), r === 'start', a)
  return o && ((u = u.map(l => l + '-' + o)), t && (u = u.concat(u.map(sS)))), u
}
function Zv(e) {
  return e.replace(/left|right|bottom|top/g, t => bW[t])
}
function wW(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e }
}
function RW(e) {
  return typeof e != 'number' ? wW(e) : { top: e, right: e, bottom: e, left: e }
}
function Xv(e) {
  const { x: t, y: r, width: a, height: o } = e
  return { width: a, height: o, top: r, left: t, right: t + a, bottom: r + o, x: t, y: r }
}
function IO(e, t, r) {
  let { reference: a, floating: o } = e
  const u = jl(t),
    l = kN(t),
    d = ON(l),
    h = _s(t),
    p = u === 'y',
    v = a.x + a.width / 2 - o.width / 2,
    g = a.y + a.height / 2 - o.height / 2,
    E = a[d] / 2 - o[d] / 2
  let x
  switch (h) {
    case 'top':
      x = { x: v, y: a.y - o.height }
      break
    case 'bottom':
      x = { x: v, y: a.y + a.height }
      break
    case 'right':
      x = { x: a.x + a.width, y: g }
      break
    case 'left':
      x = { x: a.x - o.width, y: g }
      break
    default:
      x = { x: a.x, y: a.y }
  }
  switch (Wh(t)) {
    case 'start':
      x[l] -= E * (r && p ? -1 : 1)
      break
    case 'end':
      x[l] += E * (r && p ? -1 : 1)
      break
  }
  return x
}
const _W = async (e, t, r) => {
  const { placement: a = 'bottom', strategy: o = 'absolute', middleware: u = [], platform: l } = r,
    d = u.filter(Boolean),
    h = await (l.isRTL == null ? void 0 : l.isRTL(t))
  let p = await l.getElementRects({ reference: e, floating: t, strategy: o }),
    { x: v, y: g } = IO(p, a, h),
    E = a,
    x = {},
    C = 0
  for (let _ = 0; _ < d.length; _++) {
    const { name: k, fn: R } = d[_],
      {
        x: D,
        y: A,
        data: L,
        reset: F
      } = await R({
        x: v,
        y: g,
        initialPlacement: a,
        placement: E,
        strategy: o,
        middlewareData: x,
        rects: p,
        platform: l,
        elements: { reference: e, floating: t }
      })
    ;(v = D ?? v),
      (g = A ?? g),
      (x = { ...x, [k]: { ...x[k], ...L } }),
      F &&
        C <= 50 &&
        (C++,
        typeof F == 'object' &&
          (F.placement && (E = F.placement),
          F.rects &&
            (p =
              F.rects === !0
                ? await l.getElementRects({ reference: e, floating: t, strategy: o })
                : F.rects),
          ({ x: v, y: g } = IO(p, E, h))),
        (_ = -1))
  }
  return { x: v, y: g, placement: E, strategy: o, middlewareData: x }
}
async function Tg(e, t) {
  var r
  t === void 0 && (t = {})
  const { x: a, y: o, platform: u, rects: l, elements: d, strategy: h } = e,
    {
      boundary: p = 'clippingAncestors',
      rootBoundary: v = 'viewport',
      elementContext: g = 'floating',
      altBoundary: E = !1,
      padding: x = 0
    } = Vc(t, e),
    C = RW(x),
    k = d[E ? (g === 'floating' ? 'reference' : 'floating') : g],
    R = Xv(
      await u.getClippingRect({
        element:
          (r = await (u.isElement == null ? void 0 : u.isElement(k))) == null || r
            ? k
            : k.contextElement ||
              (await (u.getDocumentElement == null ? void 0 : u.getDocumentElement(d.floating))),
        boundary: p,
        rootBoundary: v,
        strategy: h
      })
    ),
    D =
      g === 'floating'
        ? { x: a, y: o, width: l.floating.width, height: l.floating.height }
        : l.reference,
    A = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(d.floating)),
    L = (await (u.isElement == null ? void 0 : u.isElement(A)))
      ? (await (u.getScale == null ? void 0 : u.getScale(A))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    F = Xv(
      u.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await u.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: d,
            rect: D,
            offsetParent: A,
            strategy: h
          })
        : D
    )
  return {
    top: (R.top - F.top + C.top) / L.y,
    bottom: (F.bottom - R.bottom + C.bottom) / L.y,
    left: (R.left - F.left + C.left) / L.x,
    right: (F.right - R.right + C.right) / L.x
  }
}
const OW = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: 'flip',
      options: e,
      async fn(t) {
        var r, a
        const {
            placement: o,
            middlewareData: u,
            rects: l,
            initialPlacement: d,
            platform: h,
            elements: p
          } = t,
          {
            mainAxis: v = !0,
            crossAxis: g = !0,
            fallbackPlacements: E,
            fallbackStrategy: x = 'bestFit',
            fallbackAxisSideDirection: C = 'none',
            flipAlignment: _ = !0,
            ...k
          } = Vc(e, t)
        if ((r = u.arrow) != null && r.alignmentOffset) return {}
        const R = _s(o),
          D = jl(d),
          A = _s(d) === d,
          L = await (h.isRTL == null ? void 0 : h.isRTL(p.floating)),
          F = E || (A || !_ ? [Zv(d)] : SW(d)),
          z = C !== 'none'
        !E && z && F.push(...CW(d, _, C, L))
        const H = [d, ...F],
          $ = await Tg(t, k),
          Q = []
        let ue = ((a = u.flip) == null ? void 0 : a.overflows) || []
        if ((v && Q.push($[R]), g)) {
          const G = xW(o, l, L)
          Q.push($[G[0]], $[G[1]])
        }
        if (((ue = [...ue, { placement: o, overflows: Q }]), !Q.every(G => G <= 0))) {
          var se, we
          const G = (((se = u.flip) == null ? void 0 : se.index) || 0) + 1,
            ge = H[G]
          if (ge) return { data: { index: G, overflows: ue }, reset: { placement: ge } }
          let De =
            (we = ue
              .filter(de => de.overflows[0] <= 0)
              .sort((de, ve) => de.overflows[1] - ve.overflows[1])[0]) == null
              ? void 0
              : we.placement
          if (!De)
            switch (x) {
              case 'bestFit': {
                var he
                const de =
                  (he = ue
                    .filter(ve => {
                      if (z) {
                        const Ke = jl(ve.placement)
                        return Ke === D || Ke === 'y'
                      }
                      return !0
                    })
                    .map(ve => [
                      ve.placement,
                      ve.overflows.filter(Ke => Ke > 0).reduce((Ke, ot) => Ke + ot, 0)
                    ])
                    .sort((ve, Ke) => ve[1] - Ke[1])[0]) == null
                    ? void 0
                    : he[0]
                de && (De = de)
                break
              }
              case 'initialPlacement':
                De = d
                break
            }
          if (o !== De) return { reset: { placement: De } }
        }
        return {}
      }
    }
  )
}
async function kW(e, t) {
  const { placement: r, platform: a, elements: o } = e,
    u = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)),
    l = _s(r),
    d = Wh(r),
    h = jl(r) === 'y',
    p = ['left', 'top'].includes(l) ? -1 : 1,
    v = u && h ? -1 : 1,
    g = Vc(t, e)
  let {
    mainAxis: E,
    crossAxis: x,
    alignmentAxis: C
  } = typeof g == 'number'
    ? { mainAxis: g, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...g }
  return (
    d && typeof C == 'number' && (x = d === 'end' ? C * -1 : C),
    h ? { x: x * v, y: E * p } : { x: E * p, y: x * v }
  )
}
const AW = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: 'offset',
        options: e,
        async fn(t) {
          var r, a
          const { x: o, y: u, placement: l, middlewareData: d } = t,
            h = await kW(t, e)
          return l === ((r = d.offset) == null ? void 0 : r.placement) &&
            (a = d.arrow) != null &&
            a.alignmentOffset
            ? {}
            : { x: o + h.x, y: u + h.y, data: { ...h, placement: l } }
        }
      }
    )
  },
  DW = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'shift',
        options: e,
        async fn(t) {
          const { x: r, y: a, placement: o } = t,
            {
              mainAxis: u = !0,
              crossAxis: l = !1,
              limiter: d = {
                fn: k => {
                  let { x: R, y: D } = k
                  return { x: R, y: D }
                }
              },
              ...h
            } = Vc(e, t),
            p = { x: r, y: a },
            v = await Tg(t, h),
            g = jl(_s(o)),
            E = _N(g)
          let x = p[E],
            C = p[g]
          if (u) {
            const k = E === 'y' ? 'top' : 'left',
              R = E === 'y' ? 'bottom' : 'right',
              D = x + v[k],
              A = x - v[R]
            x = PO(D, x, A)
          }
          if (l) {
            const k = g === 'y' ? 'top' : 'left',
              R = g === 'y' ? 'bottom' : 'right',
              D = C + v[k],
              A = C - v[R]
            C = PO(D, C, A)
          }
          const _ = d.fn({ ...t, [E]: x, [g]: C })
          return { ..._, data: { x: _.x - r, y: _.y - a } }
        }
      }
    )
  },
  NW = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'size',
        options: e,
        async fn(t) {
          const { placement: r, rects: a, platform: o, elements: u } = t,
            { apply: l = () => {}, ...d } = Vc(e, t),
            h = await Tg(t, d),
            p = _s(r),
            v = Wh(r),
            g = jl(r) === 'y',
            { width: E, height: x } = a.floating
          let C, _
          p === 'top' || p === 'bottom'
            ? ((C = p),
              (_ =
                v === ((await (o.isRTL == null ? void 0 : o.isRTL(u.floating))) ? 'start' : 'end')
                  ? 'left'
                  : 'right'))
            : ((_ = p), (C = v === 'end' ? 'top' : 'bottom'))
          const k = x - h.top - h.bottom,
            R = E - h.left - h.right,
            D = bs(x - h[C], k),
            A = bs(E - h[_], R),
            L = !t.middlewareData.shift
          let F = D,
            z = A
          if ((g ? (z = v || L ? bs(A, R) : R) : (F = v || L ? bs(D, k) : k), L && !v)) {
            const $ = wi(h.left, 0),
              Q = wi(h.right, 0),
              ue = wi(h.top, 0),
              se = wi(h.bottom, 0)
            g
              ? (z = E - 2 * ($ !== 0 || Q !== 0 ? $ + Q : wi(h.left, h.right)))
              : (F = x - 2 * (ue !== 0 || se !== 0 ? ue + se : wi(h.top, h.bottom)))
          }
          await l({ ...t, availableWidth: z, availableHeight: F })
          const H = await o.getDimensions(u.floating)
          return E !== H.width || x !== H.height ? { reset: { rects: !0 } } : {}
        }
      }
    )
  }
function AN(e) {
  const t = ga(e)
  let r = parseFloat(t.width) || 0,
    a = parseFloat(t.height) || 0
  const o = Wa(e),
    u = o ? e.offsetWidth : r,
    l = o ? e.offsetHeight : a,
    d = Kv(r) !== u || Kv(a) !== l
  return d && ((r = u), (a = l)), { width: r, height: a, $: d }
}
function u1(e) {
  return Fr(e) ? e : e.contextElement
}
function lc(e) {
  const t = u1(e)
  if (!Wa(t)) return Rs(1)
  const r = t.getBoundingClientRect(),
    { width: a, height: o, $: u } = AN(t)
  let l = (u ? Kv(r.width) : r.width) / a,
    d = (u ? Kv(r.height) : r.height) / o
  return (!l || !Number.isFinite(l)) && (l = 1), (!d || !Number.isFinite(d)) && (d = 1), { x: l, y: d }
}
const MW = Rs(0)
function DN(e) {
  const t = _i(e)
  return !l1() || !t.visualViewport
    ? MW
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
}
function LW(e, t, r) {
  return t === void 0 && (t = !1), !r || (t && r !== _i(e)) ? !1 : t
}
function Ul(e, t, r, a) {
  t === void 0 && (t = !1), r === void 0 && (r = !1)
  const o = e.getBoundingClientRect(),
    u = u1(e)
  let l = Rs(1)
  t && (a ? Fr(a) && (l = lc(a)) : (l = lc(e)))
  const d = LW(u, r, a) ? DN(u) : Rs(0)
  let h = (o.left + d.x) / l.x,
    p = (o.top + d.y) / l.y,
    v = o.width / l.x,
    g = o.height / l.y
  if (u) {
    const E = _i(u),
      x = a && Fr(a) ? _i(a) : a
    let C = E,
      _ = oS(C)
    for (; _ && a && x !== C; ) {
      const k = lc(_),
        R = _.getBoundingClientRect(),
        D = ga(_),
        A = R.left + (_.clientLeft + parseFloat(D.paddingLeft)) * k.x,
        L = R.top + (_.clientTop + parseFloat(D.paddingTop)) * k.y
      ;(h *= k.x), (p *= k.y), (v *= k.x), (g *= k.y), (h += A), (p += L), (C = _i(_)), (_ = oS(C))
    }
  }
  return Xv({ width: v, height: g, x: h, y: p })
}
function PW(e) {
  let { elements: t, rect: r, offsetParent: a, strategy: o } = e
  const u = o === 'fixed',
    l = No(a),
    d = t ? xg(t.floating) : !1
  if (a === l || (d && u)) return r
  let h = { scrollLeft: 0, scrollTop: 0 },
    p = Rs(1)
  const v = Rs(0),
    g = Wa(a)
  if ((g || (!g && !u)) && ((Fc(a) !== 'body' || Hh(l)) && (h = Sg(a)), Wa(a))) {
    const E = Ul(a)
    ;(p = lc(a)), (v.x = E.x + a.clientLeft), (v.y = E.y + a.clientTop)
  }
  return {
    width: r.width * p.x,
    height: r.height * p.y,
    x: r.x * p.x - h.scrollLeft * p.x + v.x,
    y: r.y * p.y - h.scrollTop * p.y + v.y
  }
}
function IW(e) {
  return Array.from(e.getClientRects())
}
function NN(e) {
  return Ul(No(e)).left + Sg(e).scrollLeft
}
function FW(e) {
  const t = No(e),
    r = Sg(e),
    a = e.ownerDocument.body,
    o = wi(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth),
    u = wi(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight)
  let l = -r.scrollLeft + NN(e)
  const d = -r.scrollTop
  return (
    ga(a).direction === 'rtl' && (l += wi(t.clientWidth, a.clientWidth) - o),
    { width: o, height: u, x: l, y: d }
  )
}
function VW(e, t) {
  const r = _i(e),
    a = No(e),
    o = r.visualViewport
  let u = a.clientWidth,
    l = a.clientHeight,
    d = 0,
    h = 0
  if (o) {
    ;(u = o.width), (l = o.height)
    const p = l1()
    ;(!p || (p && t === 'fixed')) && ((d = o.offsetLeft), (h = o.offsetTop))
  }
  return { width: u, height: l, x: d, y: h }
}
function jW(e, t) {
  const r = Ul(e, !0, t === 'fixed'),
    a = r.top + e.clientTop,
    o = r.left + e.clientLeft,
    u = Wa(e) ? lc(e) : Rs(1),
    l = e.clientWidth * u.x,
    d = e.clientHeight * u.y,
    h = o * u.x,
    p = a * u.y
  return { width: l, height: d, x: h, y: p }
}
function FO(e, t, r) {
  let a
  if (t === 'viewport') a = VW(e, r)
  else if (t === 'document') a = FW(No(e))
  else if (Fr(t)) a = jW(t, r)
  else {
    const o = DN(e)
    a = { ...t, x: t.x - o.x, y: t.y - o.y }
  }
  return Xv(a)
}
function MN(e, t) {
  const r = ws(e)
  return r === t || !Fr(r) || kc(r) ? !1 : ga(r).position === 'fixed' || MN(r, t)
}
function UW(e, t) {
  const r = t.get(e)
  if (r) return r
  let a = fh(e, [], !1).filter(d => Fr(d) && Fc(d) !== 'body'),
    o = null
  const u = ga(e).position === 'fixed'
  let l = u ? ws(e) : e
  for (; Fr(l) && !kc(l); ) {
    const d = ga(l),
      h = s1(l)
    !h && d.position === 'fixed' && (o = null),
      (
        u
          ? !h && !o
          : (!h && d.position === 'static' && !!o && ['absolute', 'fixed'].includes(o.position)) ||
            (Hh(l) && !h && MN(e, l))
      )
        ? (a = a.filter(v => v !== l))
        : (o = d),
      (l = ws(l))
  }
  return t.set(e, a), a
}
function $W(e) {
  let { element: t, boundary: r, rootBoundary: a, strategy: o } = e
  const l = [...(r === 'clippingAncestors' ? (xg(t) ? [] : UW(t, this._c)) : [].concat(r)), a],
    d = l[0],
    h = l.reduce(
      (p, v) => {
        const g = FO(t, v, o)
        return (
          (p.top = wi(g.top, p.top)),
          (p.right = bs(g.right, p.right)),
          (p.bottom = bs(g.bottom, p.bottom)),
          (p.left = wi(g.left, p.left)),
          p
        )
      },
      FO(t, d, o)
    )
  return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top }
}
function BW(e) {
  const { width: t, height: r } = AN(e)
  return { width: t, height: r }
}
function zW(e, t, r) {
  const a = Wa(t),
    o = No(t),
    u = r === 'fixed',
    l = Ul(e, !0, u, t)
  let d = { scrollLeft: 0, scrollTop: 0 }
  const h = Rs(0)
  if (a || (!a && !u))
    if (((Fc(t) !== 'body' || Hh(o)) && (d = Sg(t)), a)) {
      const g = Ul(t, !0, u, t)
      ;(h.x = g.x + t.clientLeft), (h.y = g.y + t.clientTop)
    } else o && (h.x = NN(o))
  const p = l.left + d.scrollLeft - h.x,
    v = l.top + d.scrollTop - h.y
  return { x: p, y: v, width: l.width, height: l.height }
}
function ox(e) {
  return ga(e).position === 'static'
}
function VO(e, t) {
  return !Wa(e) || ga(e).position === 'fixed' ? null : t ? t(e) : e.offsetParent
}
function LN(e, t) {
  const r = _i(e)
  if (xg(e)) return r
  if (!Wa(e)) {
    let o = ws(e)
    for (; o && !kc(o); ) {
      if (Fr(o) && !ox(o)) return o
      o = ws(o)
    }
    return r
  }
  let a = VO(e, t)
  for (; a && vW(a) && ox(a); ) a = VO(a, t)
  return a && kc(a) && ox(a) && !s1(a) ? r : a || gW(e) || r
}
const HW = async function (e) {
  const t = this.getOffsetParent || LN,
    r = this.getDimensions,
    a = await r(e.floating)
  return {
    reference: zW(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: a.width, height: a.height }
  }
}
function WW(e) {
  return ga(e).direction === 'rtl'
}
const YW = {
  convertOffsetParentRelativeRectToViewportRelativeRect: PW,
  getDocumentElement: No,
  getClippingRect: $W,
  getOffsetParent: LN,
  getElementRects: HW,
  getClientRects: IW,
  getDimensions: BW,
  getScale: lc,
  isElement: Fr,
  isRTL: WW
}
function qW(e, t) {
  let r = null,
    a
  const o = No(e)
  function u() {
    var d
    clearTimeout(a), (d = r) == null || d.disconnect(), (r = null)
  }
  function l(d, h) {
    d === void 0 && (d = !1), h === void 0 && (h = 1), u()
    const { left: p, top: v, width: g, height: E } = e.getBoundingClientRect()
    if ((d || t(), !g || !E)) return
    const x = bv(v),
      C = bv(o.clientWidth - (p + g)),
      _ = bv(o.clientHeight - (v + E)),
      k = bv(p),
      D = {
        rootMargin: -x + 'px ' + -C + 'px ' + -_ + 'px ' + -k + 'px',
        threshold: wi(0, bs(1, h)) || 1
      }
    let A = !0
    function L(F) {
      const z = F[0].intersectionRatio
      if (z !== h) {
        if (!A) return l()
        z
          ? l(!1, z)
          : (a = setTimeout(() => {
              l(!1, 1e-7)
            }, 1e3))
      }
      A = !1
    }
    try {
      r = new IntersectionObserver(L, { ...D, root: o.ownerDocument })
    } catch {
      r = new IntersectionObserver(L, D)
    }
    r.observe(e)
  }
  return l(!0), u
}
function GW(e, t, r, a) {
  a === void 0 && (a = {})
  const {
      ancestorScroll: o = !0,
      ancestorResize: u = !0,
      elementResize: l = typeof ResizeObserver == 'function',
      layoutShift: d = typeof IntersectionObserver == 'function',
      animationFrame: h = !1
    } = a,
    p = u1(e),
    v = o || u ? [...(p ? fh(p) : []), ...fh(t)] : []
  v.forEach(R => {
    o && R.addEventListener('scroll', r, { passive: !0 }), u && R.addEventListener('resize', r)
  })
  const g = p && d ? qW(p, r) : null
  let E = -1,
    x = null
  l &&
    ((x = new ResizeObserver(R => {
      let [D] = R
      D &&
        D.target === p &&
        x &&
        (x.unobserve(t),
        cancelAnimationFrame(E),
        (E = requestAnimationFrame(() => {
          var A
          ;(A = x) == null || A.observe(t)
        }))),
        r()
    })),
    p && !h && x.observe(p),
    x.observe(t))
  let C,
    _ = h ? Ul(e) : null
  h && k()
  function k() {
    const R = Ul(e)
    _ && (R.x !== _.x || R.y !== _.y || R.width !== _.width || R.height !== _.height) && r(),
      (_ = R),
      (C = requestAnimationFrame(k))
  }
  return (
    r(),
    () => {
      var R
      v.forEach(D => {
        o && D.removeEventListener('scroll', r), u && D.removeEventListener('resize', r)
      }),
        g == null || g(),
        (R = x) == null || R.disconnect(),
        (x = null),
        h && cancelAnimationFrame(C)
    }
  )
}
const sx = Tg,
  KW = AW,
  ZW = DW,
  XW = OW,
  QW = NW,
  JW = (e, t, r) => {
    const a = new Map(),
      o = { platform: YW, ...r },
      u = { ...o.platform, _c: a }
    return _W(e, t, { ...o, platform: u })
  }
var kv = typeof document < 'u' ? w.useLayoutEffect : w.useEffect
function Qv(e, t) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (typeof e == 'function' && e.toString() === t.toString()) return !0
  let r, a, o
  if (e && t && typeof e == 'object') {
    if (Array.isArray(e)) {
      if (((r = e.length), r !== t.length)) return !1
      for (a = r; a-- !== 0; ) if (!Qv(e[a], t[a])) return !1
      return !0
    }
    if (((o = Object.keys(e)), (r = o.length), r !== Object.keys(t).length)) return !1
    for (a = r; a-- !== 0; ) if (!{}.hasOwnProperty.call(t, o[a])) return !1
    for (a = r; a-- !== 0; ) {
      const u = o[a]
      if (!(u === '_owner' && e.$$typeof) && !Qv(e[u], t[u])) return !1
    }
    return !0
  }
  return e !== e && t !== t
}
function PN(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function jO(e, t) {
  const r = PN(e)
  return Math.round(t * r) / r
}
function UO(e) {
  const t = w.useRef(e)
  return (
    kv(() => {
      t.current = e
    }),
    t
  )
}
function eY(e) {
  e === void 0 && (e = {})
  const {
      placement: t = 'bottom',
      strategy: r = 'absolute',
      middleware: a = [],
      platform: o,
      elements: { reference: u, floating: l } = {},
      transform: d = !0,
      whileElementsMounted: h,
      open: p
    } = e,
    [v, g] = w.useState({ x: 0, y: 0, strategy: r, placement: t, middlewareData: {}, isPositioned: !1 }),
    [E, x] = w.useState(a)
  Qv(E, a) || x(a)
  const [C, _] = w.useState(null),
    [k, R] = w.useState(null),
    D = w.useCallback(de => {
      de !== z.current && ((z.current = de), _(de))
    }, []),
    A = w.useCallback(de => {
      de !== H.current && ((H.current = de), R(de))
    }, []),
    L = u || C,
    F = l || k,
    z = w.useRef(null),
    H = w.useRef(null),
    $ = w.useRef(v),
    Q = h != null,
    ue = UO(h),
    se = UO(o),
    we = w.useCallback(() => {
      if (!z.current || !H.current) return
      const de = { placement: t, strategy: r, middleware: E }
      se.current && (de.platform = se.current),
        JW(z.current, H.current, de).then(ve => {
          const Ke = { ...ve, isPositioned: !0 }
          he.current &&
            !Qv($.current, Ke) &&
            (($.current = Ke),
            Pr.flushSync(() => {
              g(Ke)
            }))
        })
    }, [E, t, r, se])
  kv(() => {
    p === !1 &&
      $.current.isPositioned &&
      (($.current.isPositioned = !1), g(de => ({ ...de, isPositioned: !1 })))
  }, [p])
  const he = w.useRef(!1)
  kv(
    () => (
      (he.current = !0),
      () => {
        he.current = !1
      }
    ),
    []
  ),
    kv(() => {
      if ((L && (z.current = L), F && (H.current = F), L && F)) {
        if (ue.current) return ue.current(L, F, we)
        we()
      }
    }, [L, F, we, ue, Q])
  const G = w.useMemo(() => ({ reference: z, floating: H, setReference: D, setFloating: A }), [D, A]),
    ge = w.useMemo(() => ({ reference: L, floating: F }), [L, F]),
    De = w.useMemo(() => {
      const de = { position: r, left: 0, top: 0 }
      if (!ge.floating) return de
      const ve = jO(ge.floating, v.x),
        Ke = jO(ge.floating, v.y)
      return d
        ? {
            ...de,
            transform: 'translate(' + ve + 'px, ' + Ke + 'px)',
            ...(PN(ge.floating) >= 1.5 && { willChange: 'transform' })
          }
        : { position: r, left: ve, top: Ke }
    }, [r, d, ge.floating, v.x, v.y])
  return w.useMemo(
    () => ({ ...v, update: we, refs: G, elements: ge, floatingStyles: De }),
    [v, we, G, ge, De]
  )
}
const IN = (e, t) => ({ ...KW(e), options: [e, t] }),
  tY = (e, t) => ({ ...ZW(e), options: [e, t] }),
  nY = (e, t) => ({ ...XW(e), options: [e, t] }),
  rY = (e, t) => ({ ...QW(e), options: [e, t] }),
  FN = { ...Sx },
  iY = FN.useInsertionEffect,
  aY = iY || (e => e())
function VN(e) {
  const t = w.useRef(() => {
    throw new Error('Cannot call an event handler while rendering.')
  })
  return (
    aY(() => {
      t.current = e
    }),
    w.useCallback(function () {
      for (var r = arguments.length, a = new Array(r), o = 0; o < r; o++) a[o] = arguments[o]
      return t.current == null ? void 0 : t.current(...a)
    }, [])
  )
}
var lS = typeof document < 'u' ? w.useLayoutEffect : w.useEffect
let $O = !1,
  oY = 0
const BO = () => 'floating-ui-' + Math.random().toString(36).slice(2, 6) + oY++
function sY() {
  const [e, t] = w.useState(() => ($O ? BO() : void 0))
  return (
    lS(() => {
      e == null && t(BO())
    }, []),
    w.useEffect(() => {
      $O = !0
    }, []),
    e
  )
}
const lY = FN.useId,
  uY = lY || sY
let dh
dh = new Set()
function cY() {
  for (var e, t = arguments.length, r = new Array(t), a = 0; a < t; a++) r[a] = arguments[a]
  const o = 'Floating UI: ' + r.join(' ')
  if (!((e = dh) != null && e.has(o))) {
    var u
    ;(u = dh) == null || u.add(o), console.warn(o)
  }
}
function fY() {
  for (var e, t = arguments.length, r = new Array(t), a = 0; a < t; a++) r[a] = arguments[a]
  const o = 'Floating UI: ' + r.join(' ')
  if (!((e = dh) != null && e.has(o))) {
    var u
    ;(u = dh) == null || u.add(o), console.error(o)
  }
}
function dY() {
  const e = new Map()
  return {
    emit(t, r) {
      var a
      ;(a = e.get(t)) == null || a.forEach(o => o(r))
    },
    on(t, r) {
      e.set(t, [...(e.get(t) || []), r])
    },
    off(t, r) {
      var a
      e.set(t, ((a = e.get(t)) == null ? void 0 : a.filter(o => o !== r)) || [])
    }
  }
}
const hY = w.createContext(null),
  pY = w.createContext(null),
  mY = () => {
    var e
    return ((e = w.useContext(hY)) == null ? void 0 : e.id) || null
  },
  vY = () => w.useContext(pY),
  gY = 'data-floating-ui-focusable'
function yY(e) {
  const { open: t = !1, onOpenChange: r, elements: a } = e,
    o = uY(),
    u = w.useRef({}),
    [l] = w.useState(() => dY()),
    d = mY() != null
  {
    const x = a.reference
    x &&
      !Fr(x) &&
      fY(
        'Cannot pass a virtual element to the `elements.reference` option,',
        'as it must be a real DOM element. Use `refs.setPositionReference()`',
        'instead.'
      )
  }
  const [h, p] = w.useState(a.reference),
    v = VN((x, C, _) => {
      ;(u.current.openEvent = x ? C : void 0),
        l.emit('openchange', { open: x, event: C, reason: _, nested: d }),
        r == null || r(x, C, _)
    }),
    g = w.useMemo(() => ({ setPositionReference: p }), []),
    E = w.useMemo(
      () => ({
        reference: h || a.reference || null,
        floating: a.floating || null,
        domReference: a.reference
      }),
      [h, a.reference, a.floating]
    )
  return w.useMemo(
    () => ({ dataRef: u, open: t, onOpenChange: v, elements: E, events: l, floatingId: o, refs: g }),
    [t, v, E, l, o, g]
  )
}
function bY(e) {
  e === void 0 && (e = {})
  const { nodeId: t } = e,
    r = yY({ ...e, elements: { reference: null, floating: null, ...e.elements } }),
    a = e.rootContext || r,
    o = a.elements,
    [u, l] = w.useState(null),
    [d, h] = w.useState(null),
    v = (o == null ? void 0 : o.reference) || u,
    g = w.useRef(null),
    E = vY()
  lS(() => {
    v && (g.current = v)
  }, [v])
  const x = eY({ ...e, elements: { ...o, ...(d && { reference: d }) } }),
    C = w.useCallback(
      A => {
        const L = Fr(A)
          ? { getBoundingClientRect: () => A.getBoundingClientRect(), contextElement: A }
          : A
        h(L), x.refs.setReference(L)
      },
      [x.refs]
    ),
    _ = w.useCallback(
      A => {
        ;(Fr(A) || A === null) && ((g.current = A), l(A)),
          (Fr(x.refs.reference.current) ||
            x.refs.reference.current === null ||
            (A !== null && !Fr(A))) &&
            x.refs.setReference(A)
      },
      [x.refs]
    ),
    k = w.useMemo(
      () => ({ ...x.refs, setReference: _, setPositionReference: C, domReference: g }),
      [x.refs, _, C]
    ),
    R = w.useMemo(() => ({ ...x.elements, domReference: v }), [x.elements, v]),
    D = w.useMemo(() => ({ ...x, ...a, refs: k, elements: R, nodeId: t }), [x, k, R, t, a])
  return (
    lS(() => {
      a.dataRef.current.floatingContext = D
      const A = E == null ? void 0 : E.nodesRef.current.find(L => L.id === t)
      A && (A.context = D)
    }),
    w.useMemo(() => ({ ...x, context: D, refs: k, elements: R }), [x, k, R, D])
  )
}
const zO = 'active',
  HO = 'selected'
function lx(e, t, r) {
  const a = new Map(),
    o = r === 'item'
  let u = e
  if (o && e) {
    const { [zO]: l, [HO]: d, ...h } = e
    u = h
  }
  return {
    ...(r === 'floating' && { tabIndex: -1, [gY]: '' }),
    ...u,
    ...t
      .map(l => {
        const d = l ? l[r] : null
        return typeof d == 'function' ? (e ? d(e) : null) : d
      })
      .concat(e)
      .reduce(
        (l, d) => (
          d &&
            Object.entries(d).forEach(h => {
              let [p, v] = h
              if (!(o && [zO, HO].includes(p)))
                if (p.indexOf('on') === 0) {
                  if ((a.has(p) || a.set(p, []), typeof v == 'function')) {
                    var g
                    ;(g = a.get(p)) == null || g.push(v),
                      (l[p] = function () {
                        for (var E, x = arguments.length, C = new Array(x), _ = 0; _ < x; _++)
                          C[_] = arguments[_]
                        return (E = a.get(p)) == null
                          ? void 0
                          : E.map(k => k(...C)).find(k => k !== void 0)
                      })
                  }
                } else l[p] = v
            }),
          l
        ),
        {}
      )
  }
}
function EY(e) {
  e === void 0 && (e = [])
  const t = e.map(d => (d == null ? void 0 : d.reference)),
    r = e.map(d => (d == null ? void 0 : d.floating)),
    a = e.map(d => (d == null ? void 0 : d.item)),
    o = w.useCallback(d => lx(d, e, 'reference'), t),
    u = w.useCallback(d => lx(d, e, 'floating'), r),
    l = w.useCallback(d => lx(d, e, 'item'), a)
  return w.useMemo(() => ({ getReferenceProps: o, getFloatingProps: u, getItemProps: l }), [o, u, l])
}
function WO(e, t) {
  return { ...e, rects: { ...e.rects, floating: { ...e.rects.floating, height: t } } }
}
const xY = e => ({
  name: 'inner',
  options: e,
  async fn(t) {
    const {
        listRef: r,
        overflowRef: a,
        onFallbackChange: o,
        offset: u = 0,
        index: l = 0,
        minItemsVisible: d = 4,
        referenceOverflowThreshold: h = 0,
        scrollRef: p,
        ...v
      } = Vc(e, t),
      {
        rects: g,
        elements: { floating: E }
      } = t,
      x = r.current[l],
      C = (p == null ? void 0 : p.current) || E,
      _ = E.clientTop || C.clientTop,
      k = E.clientTop !== 0,
      R = C.clientTop !== 0,
      D = E === C
    if (
      (t.placement.startsWith('bottom') ||
        cY('`placement` side must be "bottom" when using the `inner`', 'middleware.'),
      !x)
    )
      return {}
    const A = {
        ...t,
        ...(await IN(-x.offsetTop - E.clientTop - g.reference.height / 2 - x.offsetHeight / 2 - u).fn(t))
      },
      L = await sx(WO(A, C.scrollHeight + _ + E.clientTop), v),
      F = await sx(A, { ...v, elementContext: 'reference' }),
      z = Math.max(0, L.top),
      H = A.y + z,
      $ = Math.max(0, C.scrollHeight + ((k && D) || R ? _ * 2 : 0) - z - Math.max(0, L.bottom))
    return (
      (C.style.maxHeight = $ + 'px'),
      (C.scrollTop = z),
      o &&
        (C.offsetHeight < x.offsetHeight * Math.min(d, r.current.length - 1) - 1 ||
        F.top >= -h ||
        F.bottom >= -h
          ? Pr.flushSync(() => o(!0))
          : Pr.flushSync(() => o(!1))),
      a && (a.current = await sx(WO({ ...A, y: H }, C.offsetHeight + _ + E.clientTop), v)),
      { y: H }
    )
  }
})
function SY(e, t) {
  const { open: r, elements: a } = e,
    { enabled: o = !0, overflowRef: u, scrollRef: l, onChange: d } = t,
    h = VN(d),
    p = w.useRef(!1),
    v = w.useRef(null),
    g = w.useRef(null)
  w.useEffect(() => {
    if (!o) return
    function x(_) {
      if (_.ctrlKey || !C || u.current == null) return
      const k = _.deltaY,
        R = u.current.top >= -0.5,
        D = u.current.bottom >= -0.5,
        A = C.scrollHeight - C.clientHeight,
        L = k < 0 ? -1 : 1,
        F = k < 0 ? 'max' : 'min'
      C.scrollHeight <= C.clientHeight ||
        ((!R && k > 0) || (!D && k < 0)
          ? (_.preventDefault(),
            Pr.flushSync(() => {
              h(z => z + Math[F](k, A * L))
            }))
          : /firefox/i.test(yW()) && (C.scrollTop += k))
    }
    const C = (l == null ? void 0 : l.current) || a.floating
    if (r && C)
      return (
        C.addEventListener('wheel', x),
        requestAnimationFrame(() => {
          ;(v.current = C.scrollTop), u.current != null && (g.current = { ...u.current })
        }),
        () => {
          ;(v.current = null), (g.current = null), C.removeEventListener('wheel', x)
        }
      )
  }, [o, r, a.floating, u, l, h])
  const E = w.useMemo(
    () => ({
      onKeyDown() {
        p.current = !0
      },
      onWheel() {
        p.current = !1
      },
      onPointerMove() {
        p.current = !1
      },
      onScroll() {
        const x = (l == null ? void 0 : l.current) || a.floating
        if (!(!u.current || !x || !p.current)) {
          if (v.current !== null) {
            const C = x.scrollTop - v.current
            ;((u.current.bottom < -0.5 && C < -1) || (u.current.top < -0.5 && C > 1)) &&
              Pr.flushSync(() => h(_ => _ + C))
          }
          requestAnimationFrame(() => {
            v.current = x.scrollTop
          })
        }
      }
    }),
    [a.floating, h, u, l]
  )
  return w.useMemo(() => (o ? { floating: E } : {}), [o, E])
}
let Yh = w.createContext({
  styles: void 0,
  setReference: () => {},
  setFloating: () => {},
  getReferenceProps: () => ({}),
  getFloatingProps: () => ({}),
  slot: {}
})
Yh.displayName = 'FloatingContext'
let c1 = w.createContext(null)
c1.displayName = 'PlacementContext'
function TY(e) {
  return w.useMemo(() => (e ? (typeof e == 'string' ? { to: e } : e) : null), [e])
}
function CY() {
  return w.useContext(Yh).setReference
}
function wY() {
  let { getFloatingProps: e, slot: t } = w.useContext(Yh)
  return w.useCallback((...r) => Object.assign({}, e(...r), { 'data-anchor': t.anchor }), [e, t])
}
function RY(e = null) {
  e === !1 && (e = null), typeof e == 'string' && (e = { to: e })
  let t = w.useContext(c1),
    r = w.useMemo(
      () => e,
      [
        JSON.stringify(
          e,
          typeof HTMLElement < 'u' ? (o, u) => (u instanceof HTMLElement ? u.outerHTML : u) : void 0
        )
      ]
    )
  An(() => {
    t == null || t(r ?? null)
  }, [t, r])
  let a = w.useContext(Yh)
  return w.useMemo(() => [a.setFloating, e ? a.styles : {}], [a.setFloating, e, a.styles])
}
let YO = 4
function _Y({ children: e, enabled: t = !0 }) {
  let [r, a] = w.useState(null),
    [o, u] = w.useState(0),
    l = w.useRef(null),
    [d, h] = w.useState(null)
  OY(d)
  let p = t && r !== null && d !== null,
    { to: v = 'bottom', gap: g = 0, offset: E = 0, padding: x = 0, inner: C } = kY(r, d),
    [_, k = 'center'] = v.split(' ')
  An(() => {
    p && u(0)
  }, [p])
  let {
      refs: R,
      floatingStyles: D,
      context: A
    } = bY({
      open: p,
      placement:
        _ === 'selection'
          ? k === 'center'
            ? 'bottom'
            : `bottom-${k}`
          : k === 'center'
            ? `${_}`
            : `${_}-${k}`,
      strategy: 'absolute',
      transform: !1,
      middleware: [
        IN({ mainAxis: _ === 'selection' ? 0 : g, crossAxis: E }),
        tY({ padding: x }),
        _ !== 'selection' && nY({ padding: x }),
        _ === 'selection' && C
          ? xY({
              ...C,
              padding: x,
              overflowRef: l,
              offset: o,
              minItemsVisible: YO,
              referenceOverflowThreshold: x,
              onFallbackChange(se) {
                var we, he
                if (!se) return
                let G = A.elements.floating
                if (!G) return
                let ge = parseFloat(getComputedStyle(G).scrollPaddingBottom) || 0,
                  De = Math.min(YO, G.childElementCount),
                  de = 0,
                  ve = 0
                for (let Ke of (he = (we = A.elements.floating) == null ? void 0 : we.childNodes) != null
                  ? he
                  : [])
                  if (Ke instanceof HTMLElement) {
                    let ot = Ke.offsetTop,
                      Me = ot + Ke.clientHeight + ge,
                      Ue = G.scrollTop,
                      pe = Ue + G.clientHeight
                    if (ot >= Ue && Me <= pe) De--
                    else {
                      ;(ve = Math.max(0, Math.min(Me, pe) - Math.max(ot, Ue))), (de = Ke.clientHeight)
                      break
                    }
                  }
                De >= 1 &&
                  u(Ke => {
                    let ot = de * De - ve + ge
                    return Ke >= ot ? Ke : ot
                  })
              }
            })
          : null,
        rY({
          padding: x,
          apply({ availableWidth: se, availableHeight: we, elements: he }) {
            Object.assign(he.floating.style, {
              overflow: 'auto',
              maxWidth: `${se}px`,
              maxHeight: `min(var(--anchor-max-height, 100vh), ${we}px)`
            })
          }
        })
      ].filter(Boolean),
      whileElementsMounted: GW
    }),
    [L = _, F = k] = A.placement.split('-')
  _ === 'selection' && (L = 'selection')
  let z = w.useMemo(() => ({ anchor: [L, F].filter(Boolean).join(' ') }), [L, F]),
    H = SY(A, { overflowRef: l, onChange: u }),
    { getReferenceProps: $, getFloatingProps: Q } = EY([H]),
    ue = Ct(se => {
      h(se), R.setFloating(se)
    })
  return w.createElement(
    c1.Provider,
    { value: a },
    w.createElement(
      Yh.Provider,
      {
        value: {
          setFloating: ue,
          setReference: R.setReference,
          styles: D,
          getReferenceProps: $,
          getFloatingProps: Q,
          slot: z
        }
      },
      e
    )
  )
}
function OY(e) {
  An(() => {
    if (!e) return
    let t = new MutationObserver(() => {
      let r = window.getComputedStyle(e).maxHeight,
        a = parseFloat(r)
      if (isNaN(a)) return
      let o = parseInt(r)
      isNaN(o) || (a !== o && (e.style.maxHeight = `${Math.ceil(a)}px`))
    })
    return (
      t.observe(e, { attributes: !0, attributeFilter: ['style'] }),
      () => {
        t.disconnect()
      }
    )
  }, [e])
}
function kY(e, t) {
  var r, a, o
  let u = ux((r = e == null ? void 0 : e.gap) != null ? r : 'var(--anchor-gap, 0)', t),
    l = ux((a = e == null ? void 0 : e.offset) != null ? a : 'var(--anchor-offset, 0)', t),
    d = ux((o = e == null ? void 0 : e.padding) != null ? o : 'var(--anchor-padding, 0)', t)
  return { ...e, gap: u, offset: l, padding: d }
}
function ux(e, t, r = void 0) {
  let a = zh(),
    o = Ct((h, p) => {
      if (h == null) return [r, null]
      if (typeof h == 'number') return [h, null]
      if (typeof h == 'string') {
        if (!p) return [r, null]
        let v = qO(h, p)
        return [
          v,
          g => {
            let E = jN(h)
            {
              let x = E.map(C => window.getComputedStyle(p).getPropertyValue(C))
              a.requestAnimationFrame(function C() {
                a.nextFrame(C)
                let _ = !1
                for (let [R, D] of E.entries()) {
                  let A = window.getComputedStyle(p).getPropertyValue(D)
                  if (x[R] !== A) {
                    ;(x[R] = A), (_ = !0)
                    break
                  }
                }
                if (!_) return
                let k = qO(h, p)
                v !== k && (g(k), (v = k))
              })
            }
            return a.dispose
          }
        ]
      }
      return [r, null]
    }),
    u = w.useMemo(() => o(e, t)[0], [e, t]),
    [l = u, d] = w.useState()
  return (
    An(() => {
      let [h, p] = o(e, t)
      if ((d(h), !!p)) return p(d)
    }, [e, t]),
    l
  )
}
function jN(e) {
  let t = /var\((.*)\)/.exec(e)
  if (t) {
    let r = t[1].indexOf(',')
    if (r === -1) return [t[1]]
    let a = t[1].slice(0, r).trim(),
      o = t[1].slice(r + 1).trim()
    return o ? [a, ...jN(o)] : [a]
  }
  return []
}
function qO(e, t) {
  let r = document.createElement('div')
  t.appendChild(r),
    r.style.setProperty('margin-top', '0px', 'important'),
    r.style.setProperty('margin-top', e, 'important')
  let a = parseFloat(window.getComputedStyle(r).marginTop) || 0
  return t.removeChild(r), a
}
function AY({ children: e, freeze: t }) {
  let r = uS(t, e)
  return Gt.createElement(Gt.Fragment, null, r)
}
function uS(e, t) {
  let [r, a] = w.useState(t)
  return !e && r !== t && a(t), e ? r : t
}
let f1 = w.createContext(null)
f1.displayName = 'OpenClosedContext'
var hh = (e => (
  (e[(e.Open = 1)] = 'Open'),
  (e[(e.Closed = 2)] = 'Closed'),
  (e[(e.Closing = 4)] = 'Closing'),
  (e[(e.Opening = 8)] = 'Opening'),
  e
))(hh || {})
function DY() {
  return w.useContext(f1)
}
function NY({ value: e, children: t }) {
  return Gt.createElement(f1.Provider, { value: e }, t)
}
function MY(e) {
  function t() {
    document.readyState !== 'loading' && (e(), document.removeEventListener('DOMContentLoaded', t))
  }
  typeof window < 'u' && typeof document < 'u' && (document.addEventListener('DOMContentLoaded', t), t())
}
let bl = []
MY(() => {
  function e(t) {
    if (!(t.target instanceof HTMLElement) || t.target === document.body || bl[0] === t.target) return
    let r = t.target
    ;(r = r.closest(aS)),
      bl.unshift(r ?? t.target),
      (bl = bl.filter(a => a != null && a.isConnected)),
      bl.splice(10)
  }
  window.addEventListener('click', e, { capture: !0 }),
    window.addEventListener('mousedown', e, { capture: !0 }),
    window.addEventListener('focus', e, { capture: !0 }),
    document.body.addEventListener('click', e, { capture: !0 }),
    document.body.addEventListener('mousedown', e, { capture: !0 }),
    document.body.addEventListener('focus', e, { capture: !0 })
})
function LY(e) {
  throw new Error('Unexpected object: ' + e)
}
var Yn = (e => (
  (e[(e.First = 0)] = 'First'),
  (e[(e.Previous = 1)] = 'Previous'),
  (e[(e.Next = 2)] = 'Next'),
  (e[(e.Last = 3)] = 'Last'),
  (e[(e.Specific = 4)] = 'Specific'),
  (e[(e.Nothing = 5)] = 'Nothing'),
  e
))(Yn || {})
function GO(e, t) {
  let r = t.resolveItems()
  if (r.length <= 0) return null
  let a = t.resolveActiveIndex(),
    o = a ?? -1
  switch (e.focus) {
    case 0: {
      for (let u = 0; u < r.length; ++u) if (!t.resolveDisabled(r[u], u, r)) return u
      return a
    }
    case 1: {
      o === -1 && (o = r.length)
      for (let u = o - 1; u >= 0; --u) if (!t.resolveDisabled(r[u], u, r)) return u
      return a
    }
    case 2: {
      for (let u = o + 1; u < r.length; ++u) if (!t.resolveDisabled(r[u], u, r)) return u
      return a
    }
    case 3: {
      for (let u = r.length - 1; u >= 0; --u) if (!t.resolveDisabled(r[u], u, r)) return u
      return a
    }
    case 4: {
      for (let u = 0; u < r.length; ++u) if (t.resolveId(r[u], u, r) === e.id) return u
      return a
    }
    case 5:
      return null
    default:
      LY(e)
  }
}
var d1 = (e => ((e[(e.Left = 0)] = 'Left'), (e[(e.Right = 2)] = 'Right'), e))(d1 || {})
function PY(e) {
  let t = Ct(e),
    r = w.useRef(!1)
  w.useEffect(
    () => (
      (r.current = !1),
      () => {
        ;(r.current = !0),
          lN(() => {
            r.current && t()
          })
      }
    ),
    [t]
  )
}
function IY() {
  let e = typeof document > 'u'
  return 'useSyncExternalStore' in Sx
    ? (t => t.useSyncExternalStore)(Sx)(
        () => () => {},
        () => !1,
        () => !e
      )
    : !1
}
function FY() {
  let e = IY(),
    [t, r] = w.useState(Ll.isHandoffComplete)
  return (
    t && Ll.isHandoffComplete === !1 && r(!1),
    w.useEffect(() => {
      t !== !0 && r(!0)
    }, [t]),
    w.useEffect(() => Ll.handoff(), []),
    e ? !1 : t
  )
}
let VY = w.createContext(!1)
function jY() {
  return w.useContext(VY)
}
function UY(e) {
  let t = jY(),
    r = w.useContext($N),
    a = Eg(e),
    [o, u] = w.useState(() => {
      var l
      if (!t && r !== null) return (l = r.current) != null ? l : null
      if (Ll.isServer) return null
      let d = a == null ? void 0 : a.getElementById('headlessui-portal-root')
      if (d) return d
      if (a === null) return null
      let h = a.createElement('div')
      return h.setAttribute('id', 'headlessui-portal-root'), a.body.appendChild(h)
    })
  return (
    w.useEffect(() => {
      o !== null && ((a != null && a.body.contains(o)) || a == null || a.body.appendChild(o))
    }, [o, a]),
    w.useEffect(() => {
      t || (r !== null && u(r.current))
    }, [r, u, t]),
    o
  )
}
let UN = w.Fragment,
  $Y = Ea(function (e, t) {
    let r = e,
      a = w.useRef(null),
      o = Do(
        hH(v => {
          a.current = v
        }),
        t
      ),
      u = Eg(a),
      l = UY(a),
      [d] = w.useState(() => {
        var v
        return Ll.isServer ? null : (v = u == null ? void 0 : u.createElement('div')) != null ? v : null
      }),
      h = w.useContext(WY),
      p = FY()
    return (
      An(() => {
        !l || !d || l.contains(d) || (d.setAttribute('data-headlessui-portal', ''), l.appendChild(d))
      }, [l, d]),
      An(() => {
        if (d && h) return h.register(d)
      }, [h, d]),
      PY(() => {
        var v
        !l ||
          !d ||
          (d instanceof Node && l.contains(d) && l.removeChild(d),
          l.childNodes.length <= 0 && ((v = l.parentElement) == null || v.removeChild(l)))
      }),
      p
        ? !l || !d
          ? null
          : Pr.createPortal(
              ba({ ourProps: { ref: o }, theirProps: r, slot: {}, defaultTag: UN, name: 'Portal' }),
              d
            )
        : null
    )
  })
function BY(e, t) {
  let r = Do(t),
    { enabled: a = !0, ...o } = e
  return a
    ? Gt.createElement($Y, { ...o, ref: r })
    : ba({ ourProps: { ref: r }, theirProps: o, slot: {}, defaultTag: UN, name: 'Portal' })
}
let zY = w.Fragment,
  $N = w.createContext(null)
function HY(e, t) {
  let { target: r, ...a } = e,
    o = { ref: Do(t) }
  return Gt.createElement(
    $N.Provider,
    { value: r },
    ba({ ourProps: o, theirProps: a, defaultTag: zY, name: 'Popover.Group' })
  )
}
let WY = w.createContext(null),
  YY = Ea(BY),
  qY = Ea(HY),
  GY = Object.assign(YY, { Group: qY })
var KY = {},
  ZY = (e => ((e[(e.Open = 0)] = 'Open'), (e[(e.Closed = 1)] = 'Closed'), e))(ZY || {}),
  XY = (e => ((e[(e.Single = 0)] = 'Single'), (e[(e.Multi = 1)] = 'Multi'), e))(XY || {}),
  QY = (e => (
    (e[(e.Pointer = 0)] = 'Pointer'), (e[(e.Focus = 1)] = 'Focus'), (e[(e.Other = 2)] = 'Other'), e
  ))(QY || {}),
  JY = (e => (
    (e[(e.OpenCombobox = 0)] = 'OpenCombobox'),
    (e[(e.CloseCombobox = 1)] = 'CloseCombobox'),
    (e[(e.GoToOption = 2)] = 'GoToOption'),
    (e[(e.SetTyping = 3)] = 'SetTyping'),
    (e[(e.RegisterOption = 4)] = 'RegisterOption'),
    (e[(e.UnregisterOption = 5)] = 'UnregisterOption'),
    (e[(e.SetActivationTrigger = 6)] = 'SetActivationTrigger'),
    (e[(e.UpdateVirtualConfiguration = 7)] = 'UpdateVirtualConfiguration'),
    (e[(e.SetInputElement = 8)] = 'SetInputElement'),
    (e[(e.SetButtonElement = 9)] = 'SetButtonElement'),
    (e[(e.SetOptionsElement = 10)] = 'SetOptionsElement'),
    e
  ))(JY || {})
function cx(e, t = r => r) {
  let r = e.activeOptionIndex !== null ? e.options[e.activeOptionIndex] : null,
    a = t(e.options.slice()),
    o =
      a.length > 0 && a[0].dataRef.current.order !== null
        ? a.sort((l, d) => l.dataRef.current.order - d.dataRef.current.order)
        : KH(a, l => l.dataRef.current.domRef.current),
    u = r ? o.indexOf(r) : null
  return u === -1 && (u = null), { options: o, activeOptionIndex: u }
}
let eq = {
    1(e) {
      var t
      return ((t = e.dataRef.current) != null && t.disabled) || e.comboboxState === 1
        ? e
        : {
            ...e,
            activeOptionIndex: null,
            comboboxState: 1,
            isTyping: !1,
            activationTrigger: 2,
            __demoMode: !1
          }
    },
    0(e) {
      var t, r
      if (((t = e.dataRef.current) != null && t.disabled) || e.comboboxState === 0) return e
      if ((r = e.dataRef.current) != null && r.value) {
        let a = e.dataRef.current.calculateIndex(e.dataRef.current.value)
        if (a !== -1) return { ...e, activeOptionIndex: a, comboboxState: 0, __demoMode: !1 }
      }
      return { ...e, comboboxState: 0, __demoMode: !1 }
    },
    3(e, t) {
      return e.isTyping === t.isTyping ? e : { ...e, isTyping: t.isTyping }
    },
    2(e, t) {
      var r, a, o, u
      if (
        ((r = e.dataRef.current) != null && r.disabled) ||
        (e.optionsElement &&
          !((a = e.dataRef.current) != null && a.optionsPropsRef.current.static) &&
          e.comboboxState === 1)
      )
        return e
      if (e.virtual) {
        let { options: p, disabled: v } = e.virtual,
          g =
            t.focus === Yn.Specific
              ? t.idx
              : GO(t, {
                  resolveItems: () => p,
                  resolveActiveIndex: () => {
                    var x, C
                    return (C = (x = e.activeOptionIndex) != null ? x : p.findIndex(_ => !v(_))) != null
                      ? C
                      : null
                  },
                  resolveDisabled: v,
                  resolveId() {
                    throw new Error('Function not implemented.')
                  }
                }),
          E = (o = t.trigger) != null ? o : 2
        return e.activeOptionIndex === g && e.activationTrigger === E
          ? e
          : { ...e, activeOptionIndex: g, activationTrigger: E, isTyping: !1, __demoMode: !1 }
      }
      let l = cx(e)
      if (l.activeOptionIndex === null) {
        let p = l.options.findIndex(v => !v.dataRef.current.disabled)
        p !== -1 && (l.activeOptionIndex = p)
      }
      let d =
          t.focus === Yn.Specific
            ? t.idx
            : GO(t, {
                resolveItems: () => l.options,
                resolveActiveIndex: () => l.activeOptionIndex,
                resolveId: p => p.id,
                resolveDisabled: p => p.dataRef.current.disabled
              }),
        h = (u = t.trigger) != null ? u : 2
      return e.activeOptionIndex === d && e.activationTrigger === h
        ? e
        : { ...e, ...l, isTyping: !1, activeOptionIndex: d, activationTrigger: h, __demoMode: !1 }
    },
    4: (e, t) => {
      var r, a, o
      if ((r = e.dataRef.current) != null && r.virtual)
        return { ...e, options: [...e.options, t.payload] }
      let u = t.payload,
        l = cx(e, h => (h.push(u), h))
      e.activeOptionIndex === null &&
        (a = e.dataRef.current) != null &&
        a.isSelected(t.payload.dataRef.current.value) &&
        (l.activeOptionIndex = l.options.indexOf(u))
      let d = { ...e, ...l, activationTrigger: 2 }
      return (
        (o = e.dataRef.current) != null &&
          o.__demoMode &&
          e.dataRef.current.value === void 0 &&
          (d.activeOptionIndex = 0),
        d
      )
    },
    5: (e, t) => {
      var r
      if ((r = e.dataRef.current) != null && r.virtual)
        return { ...e, options: e.options.filter(o => o.id !== t.id) }
      let a = cx(e, o => {
        let u = o.findIndex(l => l.id === t.id)
        return u !== -1 && o.splice(u, 1), o
      })
      return { ...e, ...a, activationTrigger: 2 }
    },
    6: (e, t) => (e.activationTrigger === t.trigger ? e : { ...e, activationTrigger: t.trigger }),
    7: (e, t) => {
      var r, a
      if (e.virtual === null)
        return {
          ...e,
          virtual: { options: t.options, disabled: (r = t.disabled) != null ? r : () => !1 }
        }
      if (e.virtual.options === t.options && e.virtual.disabled === t.disabled) return e
      let o = e.activeOptionIndex
      if (e.activeOptionIndex !== null) {
        let u = t.options.indexOf(e.virtual.options[e.activeOptionIndex])
        u !== -1 ? (o = u) : (o = null)
      }
      return {
        ...e,
        activeOptionIndex: o,
        virtual: { options: t.options, disabled: (a = t.disabled) != null ? a : () => !1 }
      }
    },
    8: (e, t) => (e.inputElement === t.element ? e : { ...e, inputElement: t.element }),
    9: (e, t) => (e.buttonElement === t.element ? e : { ...e, buttonElement: t.element }),
    10: (e, t) => (e.optionsElement === t.element ? e : { ...e, optionsElement: t.element })
  },
  h1 = w.createContext(null)
h1.displayName = 'ComboboxActionsContext'
function qh(e) {
  let t = w.useContext(h1)
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Combobox /> component.`)
    throw (Error.captureStackTrace && Error.captureStackTrace(r, qh), r)
  }
  return t
}
let BN = w.createContext(null)
function tq(e) {
  let t = jc('VirtualProvider'),
    { options: r } = t.virtual,
    [a, o] = w.useMemo(() => {
      let p = t.optionsElement
      if (!p) return [0, 0]
      let v = window.getComputedStyle(p)
      return [
        parseFloat(v.paddingBlockStart || v.paddingTop),
        parseFloat(v.paddingBlockEnd || v.paddingBottom)
      ]
    }, [t.optionsElement]),
    u = IH({
      enabled: r.length !== 0,
      scrollPaddingStart: a,
      scrollPaddingEnd: o,
      count: r.length,
      estimateSize() {
        return 40
      },
      getScrollElement() {
        return t.optionsElement
      },
      overscan: 12
    }),
    [l, d] = w.useState(0)
  An(() => {
    d(p => p + 1)
  }, [r])
  let h = u.getVirtualItems()
  return h.length === 0
    ? null
    : Gt.createElement(
        BN.Provider,
        { value: u },
        Gt.createElement(
          'div',
          {
            style: { position: 'relative', width: '100%', height: `${u.getTotalSize()}px` },
            ref: p => {
              if (p) {
                if ((typeof process < 'u' && KY.JEST_WORKER_ID !== void 0) || t.activationTrigger === 0)
                  return
                t.activeOptionIndex !== null &&
                  r.length > t.activeOptionIndex &&
                  u.scrollToIndex(t.activeOptionIndex)
              }
            }
          },
          h.map(p => {
            var v
            return Gt.createElement(
              w.Fragment,
              { key: p.key },
              Gt.cloneElement(
                (v = e.children) == null ? void 0 : v.call(e, { ...e.slot, option: r[p.index] }),
                {
                  key: `${l}-${p.key}`,
                  'data-index': p.index,
                  'aria-setsize': r.length,
                  'aria-posinset': p.index + 1,
                  style: {
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    transform: `translateY(${p.start}px)`,
                    overflowAnchor: 'none'
                  }
                }
              )
            )
          })
        )
      )
}
let ph = w.createContext(null)
ph.displayName = 'ComboboxDataContext'
function jc(e) {
  let t = w.useContext(ph)
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Combobox /> component.`)
    throw (Error.captureStackTrace && Error.captureStackTrace(r, jc), r)
  }
  return t
}
function nq(e, t) {
  return _o(t.type, eq, e, t)
}
let rq = w.Fragment
function iq(e, t) {
  var r, a
  let o = n1(),
    {
      value: u,
      defaultValue: l,
      onChange: d,
      form: h,
      name: p,
      by: v,
      disabled: g = o || !1,
      onClose: E,
      __demoMode: x = !1,
      multiple: C = !1,
      immediate: _ = !1,
      virtual: k = null,
      nullable: R,
      ...D
    } = e,
    A = rH(l),
    [L = C ? [] : void 0, F] = nH(u, d, A),
    [z, H] = w.useReducer(nq, {
      dataRef: w.createRef(),
      comboboxState: x ? 0 : 1,
      isTyping: !1,
      options: [],
      virtual: k ? { options: k.options, disabled: (r = k.disabled) != null ? r : () => !1 } : null,
      activeOptionIndex: null,
      activationTrigger: 2,
      inputElement: null,
      buttonElement: null,
      optionsElement: null,
      __demoMode: x
    }),
    $ = w.useRef(!1),
    Q = w.useRef({ static: !1, hold: !1 }),
    ue = VH(v),
    se = Ct(Re =>
      k
        ? v === null
          ? k.options.indexOf(Re)
          : k.options.findIndex(Oe => ue(Oe, Re))
        : z.options.findIndex(Oe => ue(Oe.dataRef.current.value, Re))
    ),
    we = w.useCallback(Re => _o(G.mode, { 1: () => L.some(Oe => ue(Oe, Re)), 0: () => ue(L, Re) }), [L]),
    he = Ct(Re => z.activeOptionIndex === se(Re)),
    G = w.useMemo(
      () => ({
        ...z,
        immediate: _,
        optionsPropsRef: Q,
        value: L,
        defaultValue: A,
        disabled: g,
        mode: C ? 1 : 0,
        virtual: k ? z.virtual : null,
        get activeOptionIndex() {
          if (
            $.current &&
            z.activeOptionIndex === null &&
            (k ? k.options.length > 0 : z.options.length > 0)
          ) {
            if (k) {
              let Oe = k.options.findIndex(Xe => {
                var Dt, Vt
                return !((Vt = (Dt = k.disabled) == null ? void 0 : Dt.call(k, Xe)) != null && Vt)
              })
              if (Oe !== -1) return Oe
            }
            let Re = z.options.findIndex(Oe => !Oe.dataRef.current.disabled)
            if (Re !== -1) return Re
          }
          return z.activeOptionIndex
        },
        calculateIndex: se,
        compare: ue,
        isSelected: we,
        isActive: he
      }),
      [L, A, g, C, x, z, k]
    )
  An(() => {
    var Re
    k && H({ type: 7, options: k.options, disabled: (Re = k.disabled) != null ? Re : null })
  }, [k, k == null ? void 0 : k.options, k == null ? void 0 : k.disabled]),
    An(() => {
      z.dataRef.current = G
    }, [G])
  let ge = G.comboboxState === 0
  QH(ge, [G.buttonElement, G.inputElement, G.optionsElement], () => Et.closeCombobox())
  let De = w.useMemo(() => {
      var Re, Oe, Xe
      return {
        open: G.comboboxState === 0,
        disabled: g,
        activeIndex: G.activeOptionIndex,
        activeOption:
          G.activeOptionIndex === null
            ? null
            : G.virtual
              ? G.virtual.options[(Re = G.activeOptionIndex) != null ? Re : 0]
              : (Xe =
                    (Oe = G.options[G.activeOptionIndex]) == null ? void 0 : Oe.dataRef.current.value) !=
                  null
                ? Xe
                : null,
        value: L
      }
    }, [G, g, L]),
    de = Ct(() => {
      if (G.activeOptionIndex !== null) {
        if ((Et.setIsTyping(!1), G.virtual)) pe(G.virtual.options[G.activeOptionIndex])
        else {
          let { dataRef: Re } = G.options[G.activeOptionIndex]
          pe(Re.current.value)
        }
        Et.goToOption(Yn.Specific, G.activeOptionIndex)
      }
    }),
    ve = Ct(() => {
      H({ type: 0 }), ($.current = !0)
    }),
    Ke = Ct(() => {
      H({ type: 1 }), ($.current = !1), E == null || E()
    }),
    ot = Ct(Re => {
      H({ type: 3, isTyping: Re })
    }),
    Me = Ct(
      (Re, Oe, Xe) => (
        ($.current = !1),
        Re === Yn.Specific
          ? H({ type: 2, focus: Yn.Specific, idx: Oe, trigger: Xe })
          : H({ type: 2, focus: Re, trigger: Xe })
      )
    ),
    Ue = Ct(
      (Re, Oe) => (
        H({ type: 4, payload: { id: Re, dataRef: Oe } }),
        () => {
          G.isActive(Oe.current.value) && ($.current = !0), H({ type: 5, id: Re })
        }
      )
    ),
    pe = Ct(Re =>
      _o(G.mode, {
        0() {
          return F == null ? void 0 : F(Re)
        },
        1() {
          let Oe = G.value.slice(),
            Xe = Oe.findIndex(Dt => ue(Dt, Re))
          return Xe === -1 ? Oe.push(Re) : Oe.splice(Xe, 1), F == null ? void 0 : F(Oe)
        }
      })
    ),
    xt = Ct(Re => {
      H({ type: 6, trigger: Re })
    }),
    Ye = Ct(Re => {
      H({ type: 8, element: Re })
    }),
    kt = Ct(Re => {
      H({ type: 9, element: Re })
    }),
    yt = Ct(Re => {
      H({ type: 10, element: Re })
    }),
    Et = w.useMemo(
      () => ({
        onChange: pe,
        registerOption: Ue,
        goToOption: Me,
        setIsTyping: ot,
        closeCombobox: Ke,
        openCombobox: ve,
        setActivationTrigger: xt,
        selectActiveOption: de,
        setInputElement: Ye,
        setButtonElement: kt,
        setOptionsElement: yt
      }),
      []
    ),
    [st, At] = yH(),
    en = t === null ? {} : { ref: t },
    nn = w.useCallback(() => {
      if (A !== void 0) return F == null ? void 0 : F(A)
    }, [F, A])
  return Gt.createElement(
    At,
    {
      value: st,
      props: { htmlFor: (a = G.inputElement) == null ? void 0 : a.id },
      slot: { open: G.comboboxState === 0, disabled: g }
    },
    Gt.createElement(
      _Y,
      null,
      Gt.createElement(
        h1.Provider,
        { value: Et },
        Gt.createElement(
          ph.Provider,
          { value: G },
          Gt.createElement(
            NY,
            { value: _o(G.comboboxState, { 0: hh.Open, 1: hh.Closed }) },
            p != null &&
              Gt.createElement(lH, {
                disabled: g,
                data: L != null ? { [p]: L } : {},
                form: h,
                onReset: nn
              }),
            ba({ ourProps: en, theirProps: D, slot: De, defaultTag: rq, name: 'Combobox' })
          )
        )
      )
    )
  )
}
let aq = 'input'
function oq(e, t) {
  var r, a, o, u, l
  let d = jc('Combobox.Input'),
    h = qh('Combobox.Input'),
    p = w.useId(),
    v = pN(),
    {
      id: g = v || `headlessui-combobox-input-${p}`,
      onChange: E,
      displayValue: x,
      disabled: C = d.disabled || !1,
      autoFocus: _ = !1,
      type: k = 'text',
      ...R
    } = e,
    D = w.useRef(null),
    A = Do(D, t, CY(), h.setInputElement),
    L = Eg(d.inputElement),
    F = zh(),
    z = Ct(() => {
      h.onChange(null), d.optionsElement && (d.optionsElement.scrollTop = 0), h.goToOption(Yn.Nothing)
    }),
    H = w.useMemo(() => {
      var pe
      return typeof x == 'function' && d.value !== void 0
        ? (pe = x(d.value)) != null
          ? pe
          : ''
        : typeof d.value == 'string'
          ? d.value
          : ''
    }, [d.value, x])
  MO(
    ([pe, xt], [Ye, kt]) => {
      if (d.isTyping) return
      let yt = D.current
      yt &&
        (((kt === 0 && xt === 1) || pe !== Ye) && (yt.value = pe),
        requestAnimationFrame(() => {
          if (d.isTyping || !yt || (L == null ? void 0 : L.activeElement) !== yt) return
          let { selectionStart: Et, selectionEnd: st } = yt
          Math.abs((st ?? 0) - (Et ?? 0)) === 0 &&
            Et === 0 &&
            yt.setSelectionRange(yt.value.length, yt.value.length)
        }))
    },
    [H, d.comboboxState, L, d.isTyping]
  ),
    MO(
      ([pe], [xt]) => {
        if (pe === 0 && xt === 1) {
          if (d.isTyping) return
          let Ye = D.current
          if (!Ye) return
          let kt = Ye.value,
            { selectionStart: yt, selectionEnd: Et, selectionDirection: st } = Ye
          ;(Ye.value = ''),
            (Ye.value = kt),
            st !== null ? Ye.setSelectionRange(yt, Et, st) : Ye.setSelectionRange(yt, Et)
        }
      },
      [d.comboboxState]
    )
  let $ = w.useRef(!1),
    Q = Ct(() => {
      $.current = !0
    }),
    ue = Ct(() => {
      F.nextFrame(() => {
        $.current = !1
      })
    }),
    se = Ct(pe => {
      switch ((h.setIsTyping(!0), pe.key)) {
        case Zr.Enter:
          if (d.comboboxState !== 0 || $.current) return
          if ((pe.preventDefault(), pe.stopPropagation(), d.activeOptionIndex === null)) {
            h.closeCombobox()
            return
          }
          h.selectActiveOption(), d.mode === 0 && h.closeCombobox()
          break
        case Zr.ArrowDown:
          return (
            pe.preventDefault(),
            pe.stopPropagation(),
            _o(d.comboboxState, { 0: () => h.goToOption(Yn.Next), 1: () => h.openCombobox() })
          )
        case Zr.ArrowUp:
          return (
            pe.preventDefault(),
            pe.stopPropagation(),
            _o(d.comboboxState, {
              0: () => h.goToOption(Yn.Previous),
              1: () => {
                Pr.flushSync(() => h.openCombobox()), d.value || h.goToOption(Yn.Last)
              }
            })
          )
        case Zr.Home:
          if (pe.shiftKey) break
          return pe.preventDefault(), pe.stopPropagation(), h.goToOption(Yn.First)
        case Zr.PageUp:
          return pe.preventDefault(), pe.stopPropagation(), h.goToOption(Yn.First)
        case Zr.End:
          if (pe.shiftKey) break
          return pe.preventDefault(), pe.stopPropagation(), h.goToOption(Yn.Last)
        case Zr.PageDown:
          return pe.preventDefault(), pe.stopPropagation(), h.goToOption(Yn.Last)
        case Zr.Escape:
          return d.comboboxState !== 0
            ? void 0
            : (pe.preventDefault(),
              d.optionsElement && !d.optionsPropsRef.current.static && pe.stopPropagation(),
              d.mode === 0 && d.value === null && z(),
              h.closeCombobox())
        case Zr.Tab:
          if (d.comboboxState !== 0) return
          d.mode === 0 && d.activationTrigger !== 1 && h.selectActiveOption(), h.closeCombobox()
          break
      }
    }),
    we = Ct(pe => {
      E == null || E(pe), d.mode === 0 && pe.target.value === '' && z(), h.openCombobox()
    }),
    he = Ct(pe => {
      var xt, Ye, kt
      let yt = (xt = pe.relatedTarget) != null ? xt : bl.find(Et => Et !== pe.currentTarget)
      if (
        !((Ye = d.optionsElement) != null && Ye.contains(yt)) &&
        !((kt = d.buttonElement) != null && kt.contains(yt)) &&
        d.comboboxState === 0
      )
        return pe.preventDefault(), d.mode === 0 && d.value === null && z(), h.closeCombobox()
    }),
    G = Ct(pe => {
      var xt, Ye, kt
      let yt = (xt = pe.relatedTarget) != null ? xt : bl.find(Et => Et !== pe.currentTarget)
      ;((Ye = d.buttonElement) != null && Ye.contains(yt)) ||
        ((kt = d.optionsElement) != null && kt.contains(yt)) ||
        d.disabled ||
        (d.immediate &&
          d.comboboxState !== 0 &&
          F.microTask(() => {
            Pr.flushSync(() => h.openCombobox()), h.setActivationTrigger(1)
          }))
    }),
    ge = bg(),
    De = pH(),
    { isFocused: de, focusProps: ve } = sN({ autoFocus: _ }),
    { isHovered: Ke, hoverProps: ot } = oN({ isDisabled: C }),
    Me = w.useMemo(
      () => ({ open: d.comboboxState === 0, disabled: C, hover: Ke, focus: de, autofocus: _ }),
      [d, Ke, de, _, C]
    ),
    Ue = r1(
      {
        ref: A,
        id: g,
        role: 'combobox',
        type: k,
        'aria-controls': (r = d.optionsElement) == null ? void 0 : r.id,
        'aria-expanded': d.comboboxState === 0,
        'aria-activedescendant':
          d.activeOptionIndex === null
            ? void 0
            : d.virtual
              ? (a = d.options.find(
                  pe =>
                    !pe.dataRef.current.disabled &&
                    d.compare(pe.dataRef.current.value, d.virtual.options[d.activeOptionIndex])
                )) == null
                ? void 0
                : a.id
              : (o = d.options[d.activeOptionIndex]) == null
                ? void 0
                : o.id,
        'aria-labelledby': ge,
        'aria-describedby': De,
        'aria-autocomplete': 'list',
        defaultValue:
          (l =
            (u = e.defaultValue) != null
              ? u
              : d.defaultValue !== void 0
                ? x == null
                  ? void 0
                  : x(d.defaultValue)
                : null) != null
            ? l
            : d.defaultValue,
        disabled: C || void 0,
        autoFocus: _,
        onCompositionStart: Q,
        onCompositionEnd: ue,
        onKeyDown: se,
        onChange: we,
        onFocus: G,
        onBlur: he
      },
      ve,
      ot
    )
  return ba({ ourProps: Ue, theirProps: R, slot: Me, defaultTag: aq, name: 'Combobox.Input' })
}
let sq = 'button'
function lq(e, t) {
  var r
  let a = jc('Combobox.Button'),
    o = qh('Combobox.Button'),
    u = Do(t, o.setButtonElement),
    l = w.useId(),
    {
      id: d = `headlessui-combobox-button-${l}`,
      disabled: h = a.disabled || !1,
      autoFocus: p = !1,
      ...v
    } = e,
    g = CN(a.inputElement),
    E = Ct(H => {
      switch (H.key) {
        case Zr.Space:
        case Zr.Enter:
          H.preventDefault(),
            H.stopPropagation(),
            a.comboboxState === 1 && Pr.flushSync(() => o.openCombobox()),
            g()
          return
        case Zr.ArrowDown:
          H.preventDefault(),
            H.stopPropagation(),
            a.comboboxState === 1 &&
              (Pr.flushSync(() => o.openCombobox()), a.value || o.goToOption(Yn.First)),
            g()
          return
        case Zr.ArrowUp:
          H.preventDefault(),
            H.stopPropagation(),
            a.comboboxState === 1 &&
              (Pr.flushSync(() => o.openCombobox()), a.value || o.goToOption(Yn.Last)),
            g()
          return
        case Zr.Escape:
          if (a.comboboxState !== 0) return
          H.preventDefault(),
            a.optionsElement && !a.optionsPropsRef.current.static && H.stopPropagation(),
            Pr.flushSync(() => o.closeCombobox()),
            g()
          return
        default:
          return
      }
    }),
    x = Ct(H => {
      H.preventDefault(),
        !fH(H.currentTarget) &&
          (H.button === d1.Left && (a.comboboxState === 0 ? o.closeCombobox() : o.openCombobox()), g())
    }),
    C = bg([d]),
    { isFocusVisible: _, focusProps: k } = sN({ autoFocus: p }),
    { isHovered: R, hoverProps: D } = oN({ isDisabled: h }),
    { pressed: A, pressProps: L } = Qz({ disabled: h }),
    F = w.useMemo(
      () => ({
        open: a.comboboxState === 0,
        active: A || a.comboboxState === 0,
        disabled: h,
        value: a.value,
        hover: R,
        focus: _
      }),
      [a, R, _, A, h]
    ),
    z = r1(
      {
        ref: u,
        id: d,
        type: eW(e, a.buttonElement),
        tabIndex: -1,
        'aria-haspopup': 'listbox',
        'aria-controls': (r = a.optionsElement) == null ? void 0 : r.id,
        'aria-expanded': a.comboboxState === 0,
        'aria-labelledby': C,
        disabled: h || void 0,
        autoFocus: p,
        onMouseDown: x,
        onKeyDown: E
      },
      k,
      D,
      L
    )
  return ba({ ourProps: z, theirProps: v, slot: F, defaultTag: sq, name: 'Combobox.Button' })
}
let uq = 'div',
  cq = rS.RenderStrategy | rS.Static
function fq(e, t) {
  var r, a, o
  let u = w.useId(),
    {
      id: l = `headlessui-combobox-options-${u}`,
      hold: d = !1,
      anchor: h,
      portal: p = !1,
      modal: v = !0,
      transition: g = !1,
      ...E
    } = e,
    x = jc('Combobox.Options'),
    C = qh('Combobox.Options'),
    _ = TY(h)
  _ && (p = !0)
  let [k, R] = RY(_),
    [D, A] = w.useState(null),
    L = wY(),
    F = Do(t, _ ? k : null, C.setOptionsElement, A),
    z = Eg(x.optionsElement),
    H = DY(),
    [$, Q] = fW(g, D, H !== null ? (H & hh.Open) === hh.Open : x.comboboxState === 0)
  zH($, x.inputElement, C.closeCombobox)
  let ue = x.__demoMode ? !1 : v && x.comboboxState === 0
  oW(ue, z)
  let se = x.__demoMode ? !1 : v && x.comboboxState === 0
  BH(se, {
    allowed: w.useCallback(
      () => [x.inputElement, x.buttonElement, x.optionsElement],
      [x.inputElement, x.buttonElement, x.optionsElement]
    )
  }),
    An(() => {
      var Me
      x.optionsPropsRef.current.static = (Me = e.static) != null ? Me : !1
    }, [x.optionsPropsRef, e.static]),
    An(() => {
      x.optionsPropsRef.current.hold = d
    }, [x.optionsPropsRef, d]),
    mW(x.comboboxState === 0, {
      container: x.optionsElement,
      accept(Me) {
        return Me.getAttribute('role') === 'option'
          ? NodeFilter.FILTER_REJECT
          : Me.hasAttribute('role')
            ? NodeFilter.FILTER_SKIP
            : NodeFilter.FILTER_ACCEPT
      },
      walk(Me) {
        Me.setAttribute('role', 'none')
      }
    })
  let we = bg([(r = x.buttonElement) == null ? void 0 : r.id]),
    he = w.useMemo(() => ({ open: x.comboboxState === 0, option: void 0 }), [x.comboboxState]),
    G = Ct(() => {
      C.setActivationTrigger(0)
    }),
    ge = Ct(Me => {
      Me.preventDefault(), C.setActivationTrigger(0)
    }),
    De = r1(_ ? L() : {}, {
      'aria-labelledby': we,
      role: 'listbox',
      'aria-multiselectable': x.mode === 1 ? !0 : void 0,
      id: l,
      ref: F,
      style: {
        ...E.style,
        ...R,
        '--input-width': OO(x.inputElement, !0).width,
        '--button-width': OO(x.buttonElement, !0).width
      },
      onWheel: x.activationTrigger === 0 ? void 0 : G,
      onMouseDown: ge,
      ...cW(Q)
    }),
    de = $ && x.comboboxState === 1,
    ve = uS(de, (a = x.virtual) == null ? void 0 : a.options),
    Ke = uS(de, x.value),
    ot = Ct(Me => x.compare(Ke, Me))
  if (x.virtual) {
    if (ve === void 0) throw new Error('Missing `options` in virtual mode')
    Object.assign(E, {
      children: Gt.createElement(
        ph.Provider,
        { value: ve !== x.virtual.options ? { ...x, virtual: { ...x.virtual, options: ve } } : x },
        Gt.createElement(tq, { slot: he }, E.children)
      )
    })
  }
  return Gt.createElement(
    GY,
    { enabled: p ? e.static || $ : !1 },
    Gt.createElement(
      ph.Provider,
      { value: x.mode === 1 ? x : { ...x, isSelected: ot } },
      ba({
        ourProps: De,
        theirProps: {
          ...E,
          children: Gt.createElement(
            AY,
            { freeze: de },
            typeof E.children == 'function'
              ? (o = E.children) == null
                ? void 0
                : o.call(E, he)
              : E.children
          )
        },
        slot: he,
        defaultTag: uq,
        features: cq,
        visible: $,
        name: 'Combobox.Options'
      })
    )
  )
}
let dq = 'div'
function hq(e, t) {
  var r, a, o, u
  let l = jc('Combobox.Option'),
    d = qh('Combobox.Option'),
    h = w.useId(),
    {
      id: p = `headlessui-combobox-option-${h}`,
      value: v,
      disabled: g = (o =
        (a = (r = l.virtual) == null ? void 0 : r.disabled) == null ? void 0 : a.call(r, v)) != null
        ? o
        : !1,
      order: E = null,
      ...x
    } = e,
    C = CN(l.inputElement),
    _ = l.virtual
      ? l.activeOptionIndex === l.calculateIndex(v)
      : l.activeOptionIndex === null
        ? !1
        : ((u = l.options[l.activeOptionIndex]) == null ? void 0 : u.id) === p,
    k = l.isSelected(v),
    R = w.useRef(null),
    D = Hl({ disabled: g, value: v, domRef: R, order: E }),
    A = w.useContext(BN),
    L = Do(t, R, A ? A.measureElement : null),
    F = Ct(() => {
      d.setIsTyping(!1), d.onChange(v)
    })
  An(() => d.registerOption(p, D), [D, p])
  let z = w.useRef(!(l.virtual || l.__demoMode))
  An(() => {
    if (!l.virtual && !l.__demoMode)
      return Ha().requestAnimationFrame(() => {
        z.current = !0
      })
  }, [l.virtual, l.__demoMode]),
    An(() => {
      if (z.current && l.comboboxState === 0 && _ && l.activationTrigger !== 0)
        return Ha().requestAnimationFrame(() => {
          var G, ge
          ;(ge = (G = R.current) == null ? void 0 : G.scrollIntoView) == null ||
            ge.call(G, { block: 'nearest' })
        })
    }, [R, _, l.comboboxState, l.activationTrigger, l.activeOptionIndex])
  let H = Ct(G => {
      G.preventDefault(),
        G.button === d1.Left &&
          (g || (F(), TN() || requestAnimationFrame(() => C()), l.mode === 0 && d.closeCombobox()))
    }),
    $ = Ct(() => {
      if (g) return d.goToOption(Yn.Nothing)
      let G = l.calculateIndex(v)
      d.goToOption(Yn.Specific, G)
    }),
    Q = sW(),
    ue = Ct(G => Q.update(G)),
    se = Ct(G => {
      if (!Q.wasMoved(G) || g || _) return
      let ge = l.calculateIndex(v)
      d.goToOption(Yn.Specific, ge, 0)
    }),
    we = Ct(G => {
      Q.wasMoved(G) && (g || (_ && (l.optionsPropsRef.current.hold || d.goToOption(Yn.Nothing))))
    }),
    he = w.useMemo(() => ({ active: _, focus: _, selected: k, disabled: g }), [_, k, g])
  return ba({
    ourProps: {
      id: p,
      ref: L,
      role: 'option',
      tabIndex: g === !0 ? void 0 : -1,
      'aria-disabled': g === !0 ? !0 : void 0,
      'aria-selected': k,
      disabled: void 0,
      onMouseDown: H,
      onFocus: $,
      onPointerEnter: ue,
      onMouseEnter: ue,
      onPointerMove: se,
      onMouseMove: se,
      onPointerLeave: we,
      onMouseLeave: we
    },
    theirProps: x,
    slot: he,
    defaultTag: dq,
    name: 'Combobox.Option'
  })
}
let pq = Ea(iq),
  p1 = Ea(lq),
  m1 = Ea(oq),
  mq = SH,
  v1 = Ea(fq),
  g1 = Ea(hq),
  zN = Object.assign(pq, { Input: m1, Button: p1, Label: mq, Options: v1, Option: g1 })
const Av = [
  { name: 'None', value: void 0 },
  {
    name: 'Name Asc',
    value: 'name-asc',
    icon: le.jsxDEV(
      n_,
      { size: 14 },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
        lineNumber: 17,
        columnNumber: 48
      },
      void 0
    ),
    iconText: 'A->Z'
  },
  {
    name: 'Name Desc',
    value: 'name-desc',
    icon: le.jsxDEV(
      Fx,
      { size: 14 },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
        lineNumber: 18,
        columnNumber: 50
      },
      void 0
    ),
    iconText: 'Z->A'
  },
  {
    name: 'Height Asc',
    value: 'height-asc',
    icon: le.jsxDEV(
      n_,
      { size: 14 },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
        lineNumber: 19,
        columnNumber: 52
      },
      void 0
    ),
    iconText: 'S->B'
  },
  {
    name: 'Height Desc',
    value: 'height-desc',
    icon: le.jsxDEV(
      Fx,
      { size: 14 },
      void 0,
      !1,
      {
        fileName:
          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
        lineNumber: 20,
        columnNumber: 54
      },
      void 0
    ),
    iconText: 'B->S'
  }
]
function vq() {
  const { sort: e } = Mc({ from: '/' }),
    t = Av.find(l => l.value === e),
    [r, a] = w.useState(t || Av[0]),
    o = Lc(),
    u = l => {
      a(l), o({ search: d => ({ ...d, sort: l.value || void 0 }), resetScroll: !1 })
    }
  return le.jsxDEV(
    'div',
    {
      className: 'w-11 inline-block',
      children: le.jsxDEV(
        zN,
        {
          value: r,
          onChange: u,
          children: [
            le.jsxDEV(
              'div',
              {
                className: 'relative',
                children: [
                  le.jsxDEV(
                    m1,
                    {
                      readOnly: !0,
                      'aria-label': 'Sort pokemons',
                      className: Fl(
                        'rounded-full size-11',
                        'focus:outline-none data-[focus]:outline-2 data-[focus]:-outline-offset-0 data-[focus]:outline-yellow-500'
                      )
                    },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                      lineNumber: 45,
                      columnNumber: 11
                    },
                    this
                  ),
                  le.jsxDEV(
                    p1,
                    {
                      'aria-label': 'Open sort pokemons menu',
                      className:
                        'size-11 rounded-full flex items-center justify-center absolute inset-0 m-auto  dark:bg-slate-900 border dark:border-slate-800 dark:hover:bg-slate-800 bg-slate-50 hover:bg-slate-100 border-slate-300',
                      children: le.jsxDEV(
                        Fx,
                        { className: 'size-4 dark:text-slate-50' },
                        void 0,
                        !1,
                        {
                          fileName:
                            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                          lineNumber: 57,
                          columnNumber: 13
                        },
                        this
                      )
                    },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                      lineNumber: 53,
                      columnNumber: 11
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                lineNumber: 44,
                columnNumber: 9
              },
              this
            ),
            le.jsxDEV(
              v1,
              {
                anchor: 'bottom end',
                transition: !0,
                className: Fl(
                  'w-48 rounded-xl border bg-slate-800 border-slate-900 p-1 [--anchor-gap:var(--spacing-1)] empty:invisible',
                  'transition duration-100 ease-in data-[leave]:data-[closed]:opacity-0'
                ),
                children: Av.map(l =>
                  le.jsxDEV(
                    g1,
                    {
                      value: l,
                      className:
                        'group flex justify-between cursor-pointer items-center gap-2 rounded-lg text-white  hover:bg-slate-600 py-1.5 px-3 select-none data-[selected]:bg-slate-700',
                      children: [
                        le.jsxDEV(
                          'div',
                          {
                            className: 'flex gap-3 items-center',
                            children: [
                              le.jsxDEV(
                                vA,
                                {
                                  className:
                                    'invisible size-3 text-slate-50 group-data-[selected]:visible'
                                },
                                void 0,
                                !1,
                                {
                                  fileName:
                                    '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                                  lineNumber: 76,
                                  columnNumber: 17
                                },
                                this
                              ),
                              le.jsxDEV(
                                'div',
                                { className: 'text-sm/6 capitalize', children: l.name },
                                void 0,
                                !1,
                                {
                                  fileName:
                                    '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                                  lineNumber: 77,
                                  columnNumber: 17
                                },
                                this
                              )
                            ]
                          },
                          void 0,
                          !0,
                          {
                            fileName:
                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                            lineNumber: 75,
                            columnNumber: 15
                          },
                          this
                        ),
                        le.jsxDEV(
                          'div',
                          {
                            className: 'flex justify-center items-center gap-2 text-sm text-slate-500',
                            children: [l.iconText, l.icon]
                          },
                          void 0,
                          !0,
                          {
                            fileName:
                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                            lineNumber: 79,
                            columnNumber: 15
                          },
                          this
                        )
                      ]
                    },
                    l.name,
                    !0,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                      lineNumber: 70,
                      columnNumber: 13
                    },
                    this
                  )
                )
              },
              void 0,
              !1,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
                lineNumber: 61,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName:
            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
          lineNumber: 43,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName:
        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/sort-pokemons/sort-pokemons.tsx',
      lineNumber: 42,
      columnNumber: 5
    },
    this
  )
}
class uc extends Error {
  constructor(r, a) {
    const o = `${uc.extractMessage(r)}: ${JSON.stringify({ response: r, request: a })}`
    super(o)
    Hu(this, 'response')
    Hu(this, 'request')
    Object.setPrototypeOf(this, uc.prototype),
      (this.response = r),
      (this.request = a),
      typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, uc)
  }
  static extractMessage(r) {
    var a, o
    return (
      ((o = (a = r.errors) == null ? void 0 : a[0]) == null ? void 0 : o.message) ??
      `GraphQL Error (Code: ${String(r.status)})`
    )
  }
}
const KO = e => e.toUpperCase(),
  fx = e => (typeof e == 'function' ? e() : e),
  HN = (e, t) => e.map((r, a) => [r, t[a]]),
  qu = e => {
    let t = {}
    return (
      e instanceof Headers
        ? (t = gq(e))
        : Array.isArray(e)
          ? e.forEach(([r, a]) => {
              r && a !== void 0 && (t[r] = a)
            })
          : e && (t = e),
      t
    )
  },
  gq = e => {
    const t = {}
    return (
      e.forEach((r, a) => {
        t[a] = r
      }),
      t
    )
  },
  yq = e => {
    try {
      const t = e()
      return bq(t) ? t.catch(r => ZO(r)) : t
    } catch (t) {
      return ZO(t)
    }
  },
  ZO = e => (e instanceof Error ? e : new Error(String(e))),
  bq = e =>
    typeof e == 'object' &&
    e !== null &&
    'then' in e &&
    typeof e.then == 'function' &&
    'catch' in e &&
    typeof e.catch == 'function' &&
    'finally' in e &&
    typeof e.finally == 'function',
  y1 = e => {
    throw new Error(`Unhandled case: ${String(e)}`)
  },
  Dv = e => typeof e == 'object' && e !== null && !Array.isArray(e),
  Eq = (e, t) => (e.documents ? e : { documents: e, requestHeaders: t, signal: void 0 }),
  xq = (e, t, r) => (e.query ? e : { query: e, variables: t, requestHeaders: r, signal: void 0 })
function Nv(e, t) {
  if (!!!e) throw new Error(t)
}
function Sq(e) {
  return typeof e == 'object' && e !== null
}
function Tq(e, t) {
  if (!!!e) throw new Error('Unexpected invariant triggered.')
}
const Cq = /\r\n|[\n\r]/g
function cS(e, t) {
  let r = 0,
    a = 1
  for (const o of e.body.matchAll(Cq)) {
    if ((typeof o.index == 'number' || Tq(!1), o.index >= t)) break
    ;(r = o.index + o[0].length), (a += 1)
  }
  return { line: a, column: t + 1 - r }
}
function wq(e) {
  return WN(e.source, cS(e.source, e.start))
}
function WN(e, t) {
  const r = e.locationOffset.column - 1,
    a = ''.padStart(r) + e.body,
    o = t.line - 1,
    u = e.locationOffset.line - 1,
    l = t.line + u,
    d = t.line === 1 ? r : 0,
    h = t.column + d,
    p = `${e.name}:${l}:${h}
`,
    v = a.split(/\r\n|[\n\r]/g),
    g = v[o]
  if (g.length > 120) {
    const E = Math.floor(h / 80),
      x = h % 80,
      C = []
    for (let _ = 0; _ < g.length; _ += 80) C.push(g.slice(_, _ + 80))
    return (
      p +
      XO([
        [`${l} |`, C[0]],
        ...C.slice(1, E + 1).map(_ => ['|', _]),
        ['|', '^'.padStart(x)],
        ['|', C[E + 1]]
      ])
    )
  }
  return (
    p +
    XO([
      [`${l - 1} |`, v[o - 1]],
      [`${l} |`, g],
      ['|', '^'.padStart(h)],
      [`${l + 1} |`, v[o + 1]]
    ])
  )
}
function XO(e) {
  const t = e.filter(([a, o]) => o !== void 0),
    r = Math.max(...t.map(([a]) => a.length))
  return t.map(([a, o]) => a.padStart(r) + (o ? ' ' + o : '')).join(`
`)
}
function Rq(e) {
  const t = e[0]
  return t == null || 'kind' in t || 'length' in t
    ? { nodes: t, source: e[1], positions: e[2], path: e[3], originalError: e[4], extensions: e[5] }
    : t
}
class b1 extends Error {
  constructor(t, ...r) {
    var a, o, u
    const { nodes: l, source: d, positions: h, path: p, originalError: v, extensions: g } = Rq(r)
    super(t),
      (this.name = 'GraphQLError'),
      (this.path = p ?? void 0),
      (this.originalError = v ?? void 0),
      (this.nodes = QO(Array.isArray(l) ? l : l ? [l] : void 0))
    const E = QO(
      (a = this.nodes) === null || a === void 0 ? void 0 : a.map(C => C.loc).filter(C => C != null)
    )
    ;(this.source = d ?? (E == null || (o = E[0]) === null || o === void 0 ? void 0 : o.source)),
      (this.positions = h ?? (E == null ? void 0 : E.map(C => C.start))),
      (this.locations =
        h && d ? h.map(C => cS(d, C)) : E == null ? void 0 : E.map(C => cS(C.source, C.start)))
    const x = Sq(v == null ? void 0 : v.extensions) ? (v == null ? void 0 : v.extensions) : void 0
    ;(this.extensions = (u = g ?? x) !== null && u !== void 0 ? u : Object.create(null)),
      Object.defineProperties(this, {
        message: { writable: !0, enumerable: !0 },
        name: { enumerable: !1 },
        nodes: { enumerable: !1 },
        source: { enumerable: !1 },
        positions: { enumerable: !1 },
        originalError: { enumerable: !1 }
      }),
      v != null && v.stack
        ? Object.defineProperty(this, 'stack', { value: v.stack, writable: !0, configurable: !0 })
        : Error.captureStackTrace
          ? Error.captureStackTrace(this, b1)
          : Object.defineProperty(this, 'stack', {
              value: Error().stack,
              writable: !0,
              configurable: !0
            })
  }
  get [Symbol.toStringTag]() {
    return 'GraphQLError'
  }
  toString() {
    let t = this.message
    if (this.nodes)
      for (const r of this.nodes)
        r.loc &&
          (t +=
            `

` + wq(r.loc))
    else if (this.source && this.locations)
      for (const r of this.locations)
        t +=
          `

` + WN(this.source, r)
    return t
  }
  toJSON() {
    const t = { message: this.message }
    return (
      this.locations != null && (t.locations = this.locations),
      this.path != null && (t.path = this.path),
      this.extensions != null &&
        Object.keys(this.extensions).length > 0 &&
        (t.extensions = this.extensions),
      t
    )
  }
}
function QO(e) {
  return e === void 0 || e.length === 0 ? void 0 : e
}
function cr(e, t, r) {
  return new b1(`Syntax Error: ${r}`, { source: e, positions: [t] })
}
class _q {
  constructor(t, r, a) {
    ;(this.start = t.start),
      (this.end = r.end),
      (this.startToken = t),
      (this.endToken = r),
      (this.source = a)
  }
  get [Symbol.toStringTag]() {
    return 'Location'
  }
  toJSON() {
    return { start: this.start, end: this.end }
  }
}
class YN {
  constructor(t, r, a, o, u, l) {
    ;(this.kind = t),
      (this.start = r),
      (this.end = a),
      (this.line = o),
      (this.column = u),
      (this.value = l),
      (this.prev = null),
      (this.next = null)
  }
  get [Symbol.toStringTag]() {
    return 'Token'
  }
  toJSON() {
    return { kind: this.kind, value: this.value, line: this.line, column: this.column }
  }
}
const qN = {
    Name: [],
    Document: ['definitions'],
    OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
    VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
    Variable: ['name'],
    SelectionSet: ['selections'],
    Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
    Argument: ['name', 'value'],
    FragmentSpread: ['name', 'directives'],
    InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
    FragmentDefinition: ['name', 'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ['values'],
    ObjectValue: ['fields'],
    ObjectField: ['name', 'value'],
    Directive: ['name', 'arguments'],
    NamedType: ['name'],
    ListType: ['type'],
    NonNullType: ['type'],
    SchemaDefinition: ['description', 'directives', 'operationTypes'],
    OperationTypeDefinition: ['type'],
    ScalarTypeDefinition: ['description', 'name', 'directives'],
    ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
    InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
    InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
    EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
    EnumValueDefinition: ['description', 'name', 'directives'],
    InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
    DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
    SchemaExtension: ['directives', 'operationTypes'],
    ScalarTypeExtension: ['name', 'directives'],
    ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    UnionTypeExtension: ['name', 'directives', 'types'],
    EnumTypeExtension: ['name', 'directives', 'values'],
    InputObjectTypeExtension: ['name', 'directives', 'fields']
  },
  Oq = new Set(Object.keys(qN))
function JO(e) {
  const t = e == null ? void 0 : e.kind
  return typeof t == 'string' && Oq.has(t)
}
var wl
;(function (e) {
  ;(e.QUERY = 'query'), (e.MUTATION = 'mutation'), (e.SUBSCRIPTION = 'subscription')
})(wl || (wl = {}))
var fS
;(function (e) {
  ;(e.QUERY = 'QUERY'),
    (e.MUTATION = 'MUTATION'),
    (e.SUBSCRIPTION = 'SUBSCRIPTION'),
    (e.FIELD = 'FIELD'),
    (e.FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'),
    (e.FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'),
    (e.INLINE_FRAGMENT = 'INLINE_FRAGMENT'),
    (e.VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'),
    (e.SCHEMA = 'SCHEMA'),
    (e.SCALAR = 'SCALAR'),
    (e.OBJECT = 'OBJECT'),
    (e.FIELD_DEFINITION = 'FIELD_DEFINITION'),
    (e.ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'),
    (e.INTERFACE = 'INTERFACE'),
    (e.UNION = 'UNION'),
    (e.ENUM = 'ENUM'),
    (e.ENUM_VALUE = 'ENUM_VALUE'),
    (e.INPUT_OBJECT = 'INPUT_OBJECT'),
    (e.INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION')
})(fS || (fS = {}))
var rt
;(function (e) {
  ;(e.NAME = 'Name'),
    (e.DOCUMENT = 'Document'),
    (e.OPERATION_DEFINITION = 'OperationDefinition'),
    (e.VARIABLE_DEFINITION = 'VariableDefinition'),
    (e.SELECTION_SET = 'SelectionSet'),
    (e.FIELD = 'Field'),
    (e.ARGUMENT = 'Argument'),
    (e.FRAGMENT_SPREAD = 'FragmentSpread'),
    (e.INLINE_FRAGMENT = 'InlineFragment'),
    (e.FRAGMENT_DEFINITION = 'FragmentDefinition'),
    (e.VARIABLE = 'Variable'),
    (e.INT = 'IntValue'),
    (e.FLOAT = 'FloatValue'),
    (e.STRING = 'StringValue'),
    (e.BOOLEAN = 'BooleanValue'),
    (e.NULL = 'NullValue'),
    (e.ENUM = 'EnumValue'),
    (e.LIST = 'ListValue'),
    (e.OBJECT = 'ObjectValue'),
    (e.OBJECT_FIELD = 'ObjectField'),
    (e.DIRECTIVE = 'Directive'),
    (e.NAMED_TYPE = 'NamedType'),
    (e.LIST_TYPE = 'ListType'),
    (e.NON_NULL_TYPE = 'NonNullType'),
    (e.SCHEMA_DEFINITION = 'SchemaDefinition'),
    (e.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
    (e.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
    (e.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
    (e.FIELD_DEFINITION = 'FieldDefinition'),
    (e.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
    (e.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
    (e.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
    (e.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
    (e.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
    (e.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
    (e.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
    (e.SCHEMA_EXTENSION = 'SchemaExtension'),
    (e.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
    (e.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
    (e.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
    (e.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
    (e.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
    (e.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension')
})(rt || (rt = {}))
function dS(e) {
  return e === 9 || e === 32
}
function mh(e) {
  return e >= 48 && e <= 57
}
function GN(e) {
  return (e >= 97 && e <= 122) || (e >= 65 && e <= 90)
}
function KN(e) {
  return GN(e) || e === 95
}
function kq(e) {
  return GN(e) || mh(e) || e === 95
}
function Aq(e) {
  var t
  let r = Number.MAX_SAFE_INTEGER,
    a = null,
    o = -1
  for (let l = 0; l < e.length; ++l) {
    var u
    const d = e[l],
      h = Dq(d)
    h !== d.length &&
      ((a = (u = a) !== null && u !== void 0 ? u : l), (o = l), l !== 0 && h < r && (r = h))
  }
  return e
    .map((l, d) => (d === 0 ? l : l.slice(r)))
    .slice((t = a) !== null && t !== void 0 ? t : 0, o + 1)
}
function Dq(e) {
  let t = 0
  for (; t < e.length && dS(e.charCodeAt(t)); ) ++t
  return t
}
function Nq(e, t) {
  const r = e.replace(/"""/g, '\\"""'),
    a = r.split(/\r\n|[\n\r]/g),
    o = a.length === 1,
    u = a.length > 1 && a.slice(1).every(x => x.length === 0 || dS(x.charCodeAt(0))),
    l = r.endsWith('\\"""'),
    d = e.endsWith('"') && !l,
    h = e.endsWith('\\'),
    p = d || h,
    v = !o || e.length > 70 || p || u || l
  let g = ''
  const E = o && dS(e.charCodeAt(0))
  return (
    ((v && !E) || u) &&
      (g += `
`),
    (g += r),
    (v || p) &&
      (g += `
`),
    '"""' + g + '"""'
  )
}
var oe
;(function (e) {
  ;(e.SOF = '<SOF>'),
    (e.EOF = '<EOF>'),
    (e.BANG = '!'),
    (e.DOLLAR = '$'),
    (e.AMP = '&'),
    (e.PAREN_L = '('),
    (e.PAREN_R = ')'),
    (e.SPREAD = '...'),
    (e.COLON = ':'),
    (e.EQUALS = '='),
    (e.AT = '@'),
    (e.BRACKET_L = '['),
    (e.BRACKET_R = ']'),
    (e.BRACE_L = '{'),
    (e.PIPE = '|'),
    (e.BRACE_R = '}'),
    (e.NAME = 'Name'),
    (e.INT = 'Int'),
    (e.FLOAT = 'Float'),
    (e.STRING = 'String'),
    (e.BLOCK_STRING = 'BlockString'),
    (e.COMMENT = 'Comment')
})(oe || (oe = {}))
class Mq {
  constructor(t) {
    const r = new YN(oe.SOF, 0, 0, 0, 0)
    ;(this.source = t), (this.lastToken = r), (this.token = r), (this.line = 1), (this.lineStart = 0)
  }
  get [Symbol.toStringTag]() {
    return 'Lexer'
  }
  advance() {
    return (this.lastToken = this.token), (this.token = this.lookahead())
  }
  lookahead() {
    let t = this.token
    if (t.kind !== oe.EOF)
      do
        if (t.next) t = t.next
        else {
          const r = Pq(this, t.end)
          ;(t.next = r), (r.prev = t), (t = r)
        }
      while (t.kind === oe.COMMENT)
    return t
  }
}
function Lq(e) {
  return (
    e === oe.BANG ||
    e === oe.DOLLAR ||
    e === oe.AMP ||
    e === oe.PAREN_L ||
    e === oe.PAREN_R ||
    e === oe.SPREAD ||
    e === oe.COLON ||
    e === oe.EQUALS ||
    e === oe.AT ||
    e === oe.BRACKET_L ||
    e === oe.BRACKET_R ||
    e === oe.BRACE_L ||
    e === oe.PIPE ||
    e === oe.BRACE_R
  )
}
function Uc(e) {
  return (e >= 0 && e <= 55295) || (e >= 57344 && e <= 1114111)
}
function Cg(e, t) {
  return ZN(e.charCodeAt(t)) && XN(e.charCodeAt(t + 1))
}
function ZN(e) {
  return e >= 55296 && e <= 56319
}
function XN(e) {
  return e >= 56320 && e <= 57343
}
function $l(e, t) {
  const r = e.source.body.codePointAt(t)
  if (r === void 0) return oe.EOF
  if (r >= 32 && r <= 126) {
    const a = String.fromCodePoint(r)
    return a === '"' ? `'"'` : `"${a}"`
  }
  return 'U+' + r.toString(16).toUpperCase().padStart(4, '0')
}
function Wn(e, t, r, a, o) {
  const u = e.line,
    l = 1 + r - e.lineStart
  return new YN(t, r, a, u, l, o)
}
function Pq(e, t) {
  const r = e.source.body,
    a = r.length
  let o = t
  for (; o < a; ) {
    const u = r.charCodeAt(o)
    switch (u) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++o
        continue
      case 10:
        ++o, ++e.line, (e.lineStart = o)
        continue
      case 13:
        r.charCodeAt(o + 1) === 10 ? (o += 2) : ++o, ++e.line, (e.lineStart = o)
        continue
      case 35:
        return Iq(e, o)
      case 33:
        return Wn(e, oe.BANG, o, o + 1)
      case 36:
        return Wn(e, oe.DOLLAR, o, o + 1)
      case 38:
        return Wn(e, oe.AMP, o, o + 1)
      case 40:
        return Wn(e, oe.PAREN_L, o, o + 1)
      case 41:
        return Wn(e, oe.PAREN_R, o, o + 1)
      case 46:
        if (r.charCodeAt(o + 1) === 46 && r.charCodeAt(o + 2) === 46) return Wn(e, oe.SPREAD, o, o + 3)
        break
      case 58:
        return Wn(e, oe.COLON, o, o + 1)
      case 61:
        return Wn(e, oe.EQUALS, o, o + 1)
      case 64:
        return Wn(e, oe.AT, o, o + 1)
      case 91:
        return Wn(e, oe.BRACKET_L, o, o + 1)
      case 93:
        return Wn(e, oe.BRACKET_R, o, o + 1)
      case 123:
        return Wn(e, oe.BRACE_L, o, o + 1)
      case 124:
        return Wn(e, oe.PIPE, o, o + 1)
      case 125:
        return Wn(e, oe.BRACE_R, o, o + 1)
      case 34:
        return r.charCodeAt(o + 1) === 34 && r.charCodeAt(o + 2) === 34 ? Bq(e, o) : Vq(e, o)
    }
    if (mh(u) || u === 45) return Fq(e, o, u)
    if (KN(u)) return zq(e, o)
    throw cr(
      e.source,
      o,
      u === 39
        ? `Unexpected single quote character ('), did you mean to use a double quote (")?`
        : Uc(u) || Cg(r, o)
          ? `Unexpected character: ${$l(e, o)}.`
          : `Invalid character: ${$l(e, o)}.`
    )
  }
  return Wn(e, oe.EOF, a, a)
}
function Iq(e, t) {
  const r = e.source.body,
    a = r.length
  let o = t + 1
  for (; o < a; ) {
    const u = r.charCodeAt(o)
    if (u === 10 || u === 13) break
    if (Uc(u)) ++o
    else if (Cg(r, o)) o += 2
    else break
  }
  return Wn(e, oe.COMMENT, t, o, r.slice(t + 1, o))
}
function Fq(e, t, r) {
  const a = e.source.body
  let o = t,
    u = r,
    l = !1
  if ((u === 45 && (u = a.charCodeAt(++o)), u === 48)) {
    if (((u = a.charCodeAt(++o)), mh(u)))
      throw cr(e.source, o, `Invalid number, unexpected digit after 0: ${$l(e, o)}.`)
  } else (o = dx(e, o, u)), (u = a.charCodeAt(o))
  if (
    (u === 46 && ((l = !0), (u = a.charCodeAt(++o)), (o = dx(e, o, u)), (u = a.charCodeAt(o))),
    (u === 69 || u === 101) &&
      ((l = !0),
      (u = a.charCodeAt(++o)),
      (u === 43 || u === 45) && (u = a.charCodeAt(++o)),
      (o = dx(e, o, u)),
      (u = a.charCodeAt(o))),
    u === 46 || KN(u))
  )
    throw cr(e.source, o, `Invalid number, expected digit but got: ${$l(e, o)}.`)
  return Wn(e, l ? oe.FLOAT : oe.INT, t, o, a.slice(t, o))
}
function dx(e, t, r) {
  if (!mh(r)) throw cr(e.source, t, `Invalid number, expected digit but got: ${$l(e, t)}.`)
  const a = e.source.body
  let o = t + 1
  for (; mh(a.charCodeAt(o)); ) ++o
  return o
}
function Vq(e, t) {
  const r = e.source.body,
    a = r.length
  let o = t + 1,
    u = o,
    l = ''
  for (; o < a; ) {
    const d = r.charCodeAt(o)
    if (d === 34) return (l += r.slice(u, o)), Wn(e, oe.STRING, t, o + 1, l)
    if (d === 92) {
      l += r.slice(u, o)
      const h =
        r.charCodeAt(o + 1) === 117 ? (r.charCodeAt(o + 2) === 123 ? jq(e, o) : Uq(e, o)) : $q(e, o)
      ;(l += h.value), (o += h.size), (u = o)
      continue
    }
    if (d === 10 || d === 13) break
    if (Uc(d)) ++o
    else if (Cg(r, o)) o += 2
    else throw cr(e.source, o, `Invalid character within String: ${$l(e, o)}.`)
  }
  throw cr(e.source, o, 'Unterminated string.')
}
function jq(e, t) {
  const r = e.source.body
  let a = 0,
    o = 3
  for (; o < 12; ) {
    const u = r.charCodeAt(t + o++)
    if (u === 125) {
      if (o < 5 || !Uc(a)) break
      return { value: String.fromCodePoint(a), size: o }
    }
    if (((a = (a << 4) | Hd(u)), a < 0)) break
  }
  throw cr(e.source, t, `Invalid Unicode escape sequence: "${r.slice(t, t + o)}".`)
}
function Uq(e, t) {
  const r = e.source.body,
    a = ek(r, t + 2)
  if (Uc(a)) return { value: String.fromCodePoint(a), size: 6 }
  if (ZN(a) && r.charCodeAt(t + 6) === 92 && r.charCodeAt(t + 7) === 117) {
    const o = ek(r, t + 8)
    if (XN(o)) return { value: String.fromCodePoint(a, o), size: 12 }
  }
  throw cr(e.source, t, `Invalid Unicode escape sequence: "${r.slice(t, t + 6)}".`)
}
function ek(e, t) {
  return (
    (Hd(e.charCodeAt(t)) << 12) |
    (Hd(e.charCodeAt(t + 1)) << 8) |
    (Hd(e.charCodeAt(t + 2)) << 4) |
    Hd(e.charCodeAt(t + 3))
  )
}
function Hd(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1
}
function $q(e, t) {
  const r = e.source.body
  switch (r.charCodeAt(t + 1)) {
    case 34:
      return { value: '"', size: 2 }
    case 92:
      return { value: '\\', size: 2 }
    case 47:
      return { value: '/', size: 2 }
    case 98:
      return { value: '\b', size: 2 }
    case 102:
      return { value: '\f', size: 2 }
    case 110:
      return {
        value: `
`,
        size: 2
      }
    case 114:
      return { value: '\r', size: 2 }
    case 116:
      return { value: '	', size: 2 }
  }
  throw cr(e.source, t, `Invalid character escape sequence: "${r.slice(t, t + 2)}".`)
}
function Bq(e, t) {
  const r = e.source.body,
    a = r.length
  let o = e.lineStart,
    u = t + 3,
    l = u,
    d = ''
  const h = []
  for (; u < a; ) {
    const p = r.charCodeAt(u)
    if (p === 34 && r.charCodeAt(u + 1) === 34 && r.charCodeAt(u + 2) === 34) {
      ;(d += r.slice(l, u)), h.push(d)
      const v = Wn(
        e,
        oe.BLOCK_STRING,
        t,
        u + 3,
        Aq(h).join(`
`)
      )
      return (e.line += h.length - 1), (e.lineStart = o), v
    }
    if (
      p === 92 &&
      r.charCodeAt(u + 1) === 34 &&
      r.charCodeAt(u + 2) === 34 &&
      r.charCodeAt(u + 3) === 34
    ) {
      ;(d += r.slice(l, u)), (l = u + 1), (u += 4)
      continue
    }
    if (p === 10 || p === 13) {
      ;(d += r.slice(l, u)),
        h.push(d),
        p === 13 && r.charCodeAt(u + 1) === 10 ? (u += 2) : ++u,
        (d = ''),
        (l = u),
        (o = u)
      continue
    }
    if (Uc(p)) ++u
    else if (Cg(r, u)) u += 2
    else throw cr(e.source, u, `Invalid character within String: ${$l(e, u)}.`)
  }
  throw cr(e.source, u, 'Unterminated string.')
}
function zq(e, t) {
  const r = e.source.body,
    a = r.length
  let o = t + 1
  for (; o < a; ) {
    const u = r.charCodeAt(o)
    if (kq(u)) ++o
    else break
  }
  return Wn(e, oe.NAME, t, o, r.slice(t, o))
}
const Hq = 10,
  QN = 2
function E1(e) {
  return wg(e, [])
}
function wg(e, t) {
  switch (typeof e) {
    case 'string':
      return JSON.stringify(e)
    case 'function':
      return e.name ? `[function ${e.name}]` : '[function]'
    case 'object':
      return Wq(e, t)
    default:
      return String(e)
  }
}
function Wq(e, t) {
  if (e === null) return 'null'
  if (t.includes(e)) return '[Circular]'
  const r = [...t, e]
  if (Yq(e)) {
    const a = e.toJSON()
    if (a !== e) return typeof a == 'string' ? a : wg(a, r)
  } else if (Array.isArray(e)) return Gq(e, r)
  return qq(e, r)
}
function Yq(e) {
  return typeof e.toJSON == 'function'
}
function qq(e, t) {
  const r = Object.entries(e)
  return r.length === 0
    ? '{}'
    : t.length > QN
      ? '[' + Kq(e) + ']'
      : '{ ' + r.map(([o, u]) => o + ': ' + wg(u, t)).join(', ') + ' }'
}
function Gq(e, t) {
  if (e.length === 0) return '[]'
  if (t.length > QN) return '[Array]'
  const r = Math.min(Hq, e.length),
    a = e.length - r,
    o = []
  for (let u = 0; u < r; ++u) o.push(wg(e[u], t))
  return (
    a === 1 ? o.push('... 1 more item') : a > 1 && o.push(`... ${a} more items`),
    '[' + o.join(', ') + ']'
  )
}
function Kq(e) {
  const t = Object.prototype.toString
    .call(e)
    .replace(/^\[object /, '')
    .replace(/]$/, '')
  if (t === 'Object' && typeof e.constructor == 'function') {
    const r = e.constructor.name
    if (typeof r == 'string' && r !== '') return r
  }
  return t
}
const Zq = globalThis.process && !1,
  Xq = Zq
    ? function (t, r) {
        return t instanceof r
      }
    : function (t, r) {
        if (t instanceof r) return !0
        if (typeof t == 'object' && t !== null) {
          var a
          const o = r.prototype[Symbol.toStringTag],
            u =
              Symbol.toStringTag in t
                ? t[Symbol.toStringTag]
                : (a = t.constructor) === null || a === void 0
                  ? void 0
                  : a.name
          if (o === u) {
            const l = E1(t)
            throw new Error(`Cannot use ${o} "${l}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`)
          }
        }
        return !1
      }
class JN {
  constructor(t, r = 'GraphQL request', a = { line: 1, column: 1 }) {
    typeof t == 'string' || Nv(!1, `Body must be a string. Received: ${E1(t)}.`),
      (this.body = t),
      (this.name = r),
      (this.locationOffset = a),
      this.locationOffset.line > 0 ||
        Nv(!1, 'line in locationOffset is 1-indexed and must be positive.'),
      this.locationOffset.column > 0 ||
        Nv(!1, 'column in locationOffset is 1-indexed and must be positive.')
  }
  get [Symbol.toStringTag]() {
    return 'Source'
  }
}
function Qq(e) {
  return Xq(e, JN)
}
function Jq(e, t) {
  return new eG(e, t).parseDocument()
}
class eG {
  constructor(t, r = {}) {
    const a = Qq(t) ? t : new JN(t)
    ;(this._lexer = new Mq(a)), (this._options = r), (this._tokenCounter = 0)
  }
  parseName() {
    const t = this.expectToken(oe.NAME)
    return this.node(t, { kind: rt.NAME, value: t.value })
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: rt.DOCUMENT,
      definitions: this.many(oe.SOF, this.parseDefinition, oe.EOF)
    })
  }
  parseDefinition() {
    if (this.peek(oe.BRACE_L)) return this.parseOperationDefinition()
    const t = this.peekDescription(),
      r = t ? this._lexer.lookahead() : this._lexer.token
    if (r.kind === oe.NAME) {
      switch (r.value) {
        case 'schema':
          return this.parseSchemaDefinition()
        case 'scalar':
          return this.parseScalarTypeDefinition()
        case 'type':
          return this.parseObjectTypeDefinition()
        case 'interface':
          return this.parseInterfaceTypeDefinition()
        case 'union':
          return this.parseUnionTypeDefinition()
        case 'enum':
          return this.parseEnumTypeDefinition()
        case 'input':
          return this.parseInputObjectTypeDefinition()
        case 'directive':
          return this.parseDirectiveDefinition()
      }
      if (t)
        throw cr(
          this._lexer.source,
          this._lexer.token.start,
          'Unexpected description, descriptions are supported only on type definitions.'
        )
      switch (r.value) {
        case 'query':
        case 'mutation':
        case 'subscription':
          return this.parseOperationDefinition()
        case 'fragment':
          return this.parseFragmentDefinition()
        case 'extend':
          return this.parseTypeSystemExtension()
      }
    }
    throw this.unexpected(r)
  }
  parseOperationDefinition() {
    const t = this._lexer.token
    if (this.peek(oe.BRACE_L))
      return this.node(t, {
        kind: rt.OPERATION_DEFINITION,
        operation: wl.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      })
    const r = this.parseOperationType()
    let a
    return (
      this.peek(oe.NAME) && (a = this.parseName()),
      this.node(t, {
        kind: rt.OPERATION_DEFINITION,
        operation: r,
        name: a,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      })
    )
  }
  parseOperationType() {
    const t = this.expectToken(oe.NAME)
    switch (t.value) {
      case 'query':
        return wl.QUERY
      case 'mutation':
        return wl.MUTATION
      case 'subscription':
        return wl.SUBSCRIPTION
    }
    throw this.unexpected(t)
  }
  parseVariableDefinitions() {
    return this.optionalMany(oe.PAREN_L, this.parseVariableDefinition, oe.PAREN_R)
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: rt.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(oe.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(oe.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    })
  }
  parseVariable() {
    const t = this._lexer.token
    return this.expectToken(oe.DOLLAR), this.node(t, { kind: rt.VARIABLE, name: this.parseName() })
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: rt.SELECTION_SET,
      selections: this.many(oe.BRACE_L, this.parseSelection, oe.BRACE_R)
    })
  }
  parseSelection() {
    return this.peek(oe.SPREAD) ? this.parseFragment() : this.parseField()
  }
  parseField() {
    const t = this._lexer.token,
      r = this.parseName()
    let a, o
    return (
      this.expectOptionalToken(oe.COLON) ? ((a = r), (o = this.parseName())) : (o = r),
      this.node(t, {
        kind: rt.FIELD,
        alias: a,
        name: o,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(oe.BRACE_L) ? this.parseSelectionSet() : void 0
      })
    )
  }
  parseArguments(t) {
    const r = t ? this.parseConstArgument : this.parseArgument
    return this.optionalMany(oe.PAREN_L, r, oe.PAREN_R)
  }
  parseArgument(t = !1) {
    const r = this._lexer.token,
      a = this.parseName()
    return (
      this.expectToken(oe.COLON),
      this.node(r, { kind: rt.ARGUMENT, name: a, value: this.parseValueLiteral(t) })
    )
  }
  parseConstArgument() {
    return this.parseArgument(!0)
  }
  parseFragment() {
    const t = this._lexer.token
    this.expectToken(oe.SPREAD)
    const r = this.expectOptionalKeyword('on')
    return !r && this.peek(oe.NAME)
      ? this.node(t, {
          kind: rt.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(!1)
        })
      : this.node(t, {
          kind: rt.INLINE_FRAGMENT,
          typeCondition: r ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(!1),
          selectionSet: this.parseSelectionSet()
        })
  }
  parseFragmentDefinition() {
    const t = this._lexer.token
    return (
      this.expectKeyword('fragment'),
      this._options.allowLegacyFragmentVariables === !0
        ? this.node(t, {
            kind: rt.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
            directives: this.parseDirectives(!1),
            selectionSet: this.parseSelectionSet()
          })
        : this.node(t, {
            kind: rt.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
            directives: this.parseDirectives(!1),
            selectionSet: this.parseSelectionSet()
          })
    )
  }
  parseFragmentName() {
    if (this._lexer.token.value === 'on') throw this.unexpected()
    return this.parseName()
  }
  parseValueLiteral(t) {
    const r = this._lexer.token
    switch (r.kind) {
      case oe.BRACKET_L:
        return this.parseList(t)
      case oe.BRACE_L:
        return this.parseObject(t)
      case oe.INT:
        return this.advanceLexer(), this.node(r, { kind: rt.INT, value: r.value })
      case oe.FLOAT:
        return this.advanceLexer(), this.node(r, { kind: rt.FLOAT, value: r.value })
      case oe.STRING:
      case oe.BLOCK_STRING:
        return this.parseStringLiteral()
      case oe.NAME:
        switch ((this.advanceLexer(), r.value)) {
          case 'true':
            return this.node(r, { kind: rt.BOOLEAN, value: !0 })
          case 'false':
            return this.node(r, { kind: rt.BOOLEAN, value: !1 })
          case 'null':
            return this.node(r, { kind: rt.NULL })
          default:
            return this.node(r, { kind: rt.ENUM, value: r.value })
        }
      case oe.DOLLAR:
        if (t)
          if ((this.expectToken(oe.DOLLAR), this._lexer.token.kind === oe.NAME)) {
            const a = this._lexer.token.value
            throw cr(this._lexer.source, r.start, `Unexpected variable "$${a}" in constant value.`)
          } else throw this.unexpected(r)
        return this.parseVariable()
      default:
        throw this.unexpected()
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0)
  }
  parseStringLiteral() {
    const t = this._lexer.token
    return (
      this.advanceLexer(),
      this.node(t, { kind: rt.STRING, value: t.value, block: t.kind === oe.BLOCK_STRING })
    )
  }
  parseList(t) {
    const r = () => this.parseValueLiteral(t)
    return this.node(this._lexer.token, {
      kind: rt.LIST,
      values: this.any(oe.BRACKET_L, r, oe.BRACKET_R)
    })
  }
  parseObject(t) {
    const r = () => this.parseObjectField(t)
    return this.node(this._lexer.token, { kind: rt.OBJECT, fields: this.any(oe.BRACE_L, r, oe.BRACE_R) })
  }
  parseObjectField(t) {
    const r = this._lexer.token,
      a = this.parseName()
    return (
      this.expectToken(oe.COLON),
      this.node(r, { kind: rt.OBJECT_FIELD, name: a, value: this.parseValueLiteral(t) })
    )
  }
  parseDirectives(t) {
    const r = []
    for (; this.peek(oe.AT); ) r.push(this.parseDirective(t))
    return r
  }
  parseConstDirectives() {
    return this.parseDirectives(!0)
  }
  parseDirective(t) {
    const r = this._lexer.token
    return (
      this.expectToken(oe.AT),
      this.node(r, { kind: rt.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(t) })
    )
  }
  parseTypeReference() {
    const t = this._lexer.token
    let r
    if (this.expectOptionalToken(oe.BRACKET_L)) {
      const a = this.parseTypeReference()
      this.expectToken(oe.BRACKET_R), (r = this.node(t, { kind: rt.LIST_TYPE, type: a }))
    } else r = this.parseNamedType()
    return this.expectOptionalToken(oe.BANG) ? this.node(t, { kind: rt.NON_NULL_TYPE, type: r }) : r
  }
  parseNamedType() {
    return this.node(this._lexer.token, { kind: rt.NAMED_TYPE, name: this.parseName() })
  }
  peekDescription() {
    return this.peek(oe.STRING) || this.peek(oe.BLOCK_STRING)
  }
  parseDescription() {
    if (this.peekDescription()) return this.parseStringLiteral()
  }
  parseSchemaDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('schema')
    const a = this.parseConstDirectives(),
      o = this.many(oe.BRACE_L, this.parseOperationTypeDefinition, oe.BRACE_R)
    return this.node(t, { kind: rt.SCHEMA_DEFINITION, description: r, directives: a, operationTypes: o })
  }
  parseOperationTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseOperationType()
    this.expectToken(oe.COLON)
    const a = this.parseNamedType()
    return this.node(t, { kind: rt.OPERATION_TYPE_DEFINITION, operation: r, type: a })
  }
  parseScalarTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('scalar')
    const a = this.parseName(),
      o = this.parseConstDirectives()
    return this.node(t, { kind: rt.SCALAR_TYPE_DEFINITION, description: r, name: a, directives: o })
  }
  parseObjectTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('type')
    const a = this.parseName(),
      o = this.parseImplementsInterfaces(),
      u = this.parseConstDirectives(),
      l = this.parseFieldsDefinition()
    return this.node(t, {
      kind: rt.OBJECT_TYPE_DEFINITION,
      description: r,
      name: a,
      interfaces: o,
      directives: u,
      fields: l
    })
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword('implements')
      ? this.delimitedMany(oe.AMP, this.parseNamedType)
      : []
  }
  parseFieldsDefinition() {
    return this.optionalMany(oe.BRACE_L, this.parseFieldDefinition, oe.BRACE_R)
  }
  parseFieldDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription(),
      a = this.parseName(),
      o = this.parseArgumentDefs()
    this.expectToken(oe.COLON)
    const u = this.parseTypeReference(),
      l = this.parseConstDirectives()
    return this.node(t, {
      kind: rt.FIELD_DEFINITION,
      description: r,
      name: a,
      arguments: o,
      type: u,
      directives: l
    })
  }
  parseArgumentDefs() {
    return this.optionalMany(oe.PAREN_L, this.parseInputValueDef, oe.PAREN_R)
  }
  parseInputValueDef() {
    const t = this._lexer.token,
      r = this.parseDescription(),
      a = this.parseName()
    this.expectToken(oe.COLON)
    const o = this.parseTypeReference()
    let u
    this.expectOptionalToken(oe.EQUALS) && (u = this.parseConstValueLiteral())
    const l = this.parseConstDirectives()
    return this.node(t, {
      kind: rt.INPUT_VALUE_DEFINITION,
      description: r,
      name: a,
      type: o,
      defaultValue: u,
      directives: l
    })
  }
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('interface')
    const a = this.parseName(),
      o = this.parseImplementsInterfaces(),
      u = this.parseConstDirectives(),
      l = this.parseFieldsDefinition()
    return this.node(t, {
      kind: rt.INTERFACE_TYPE_DEFINITION,
      description: r,
      name: a,
      interfaces: o,
      directives: u,
      fields: l
    })
  }
  parseUnionTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('union')
    const a = this.parseName(),
      o = this.parseConstDirectives(),
      u = this.parseUnionMemberTypes()
    return this.node(t, {
      kind: rt.UNION_TYPE_DEFINITION,
      description: r,
      name: a,
      directives: o,
      types: u
    })
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(oe.EQUALS) ? this.delimitedMany(oe.PIPE, this.parseNamedType) : []
  }
  parseEnumTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('enum')
    const a = this.parseName(),
      o = this.parseConstDirectives(),
      u = this.parseEnumValuesDefinition()
    return this.node(t, {
      kind: rt.ENUM_TYPE_DEFINITION,
      description: r,
      name: a,
      directives: o,
      values: u
    })
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(oe.BRACE_L, this.parseEnumValueDefinition, oe.BRACE_R)
  }
  parseEnumValueDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription(),
      a = this.parseEnumValueName(),
      o = this.parseConstDirectives()
    return this.node(t, { kind: rt.ENUM_VALUE_DEFINITION, description: r, name: a, directives: o })
  }
  parseEnumValueName() {
    if (
      this._lexer.token.value === 'true' ||
      this._lexer.token.value === 'false' ||
      this._lexer.token.value === 'null'
    )
      throw cr(
        this._lexer.source,
        this._lexer.token.start,
        `${Ev(this._lexer.token)} is reserved and cannot be used for an enum value.`
      )
    return this.parseName()
  }
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('input')
    const a = this.parseName(),
      o = this.parseConstDirectives(),
      u = this.parseInputFieldsDefinition()
    return this.node(t, {
      kind: rt.INPUT_OBJECT_TYPE_DEFINITION,
      description: r,
      name: a,
      directives: o,
      fields: u
    })
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(oe.BRACE_L, this.parseInputValueDef, oe.BRACE_R)
  }
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead()
    if (t.kind === oe.NAME)
      switch (t.value) {
        case 'schema':
          return this.parseSchemaExtension()
        case 'scalar':
          return this.parseScalarTypeExtension()
        case 'type':
          return this.parseObjectTypeExtension()
        case 'interface':
          return this.parseInterfaceTypeExtension()
        case 'union':
          return this.parseUnionTypeExtension()
        case 'enum':
          return this.parseEnumTypeExtension()
        case 'input':
          return this.parseInputObjectTypeExtension()
      }
    throw this.unexpected(t)
  }
  parseSchemaExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('schema')
    const r = this.parseConstDirectives(),
      a = this.optionalMany(oe.BRACE_L, this.parseOperationTypeDefinition, oe.BRACE_R)
    if (r.length === 0 && a.length === 0) throw this.unexpected()
    return this.node(t, { kind: rt.SCHEMA_EXTENSION, directives: r, operationTypes: a })
  }
  parseScalarTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('scalar')
    const r = this.parseName(),
      a = this.parseConstDirectives()
    if (a.length === 0) throw this.unexpected()
    return this.node(t, { kind: rt.SCALAR_TYPE_EXTENSION, name: r, directives: a })
  }
  parseObjectTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('type')
    const r = this.parseName(),
      a = this.parseImplementsInterfaces(),
      o = this.parseConstDirectives(),
      u = this.parseFieldsDefinition()
    if (a.length === 0 && o.length === 0 && u.length === 0) throw this.unexpected()
    return this.node(t, {
      kind: rt.OBJECT_TYPE_EXTENSION,
      name: r,
      interfaces: a,
      directives: o,
      fields: u
    })
  }
  parseInterfaceTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('interface')
    const r = this.parseName(),
      a = this.parseImplementsInterfaces(),
      o = this.parseConstDirectives(),
      u = this.parseFieldsDefinition()
    if (a.length === 0 && o.length === 0 && u.length === 0) throw this.unexpected()
    return this.node(t, {
      kind: rt.INTERFACE_TYPE_EXTENSION,
      name: r,
      interfaces: a,
      directives: o,
      fields: u
    })
  }
  parseUnionTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('union')
    const r = this.parseName(),
      a = this.parseConstDirectives(),
      o = this.parseUnionMemberTypes()
    if (a.length === 0 && o.length === 0) throw this.unexpected()
    return this.node(t, { kind: rt.UNION_TYPE_EXTENSION, name: r, directives: a, types: o })
  }
  parseEnumTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('enum')
    const r = this.parseName(),
      a = this.parseConstDirectives(),
      o = this.parseEnumValuesDefinition()
    if (a.length === 0 && o.length === 0) throw this.unexpected()
    return this.node(t, { kind: rt.ENUM_TYPE_EXTENSION, name: r, directives: a, values: o })
  }
  parseInputObjectTypeExtension() {
    const t = this._lexer.token
    this.expectKeyword('extend'), this.expectKeyword('input')
    const r = this.parseName(),
      a = this.parseConstDirectives(),
      o = this.parseInputFieldsDefinition()
    if (a.length === 0 && o.length === 0) throw this.unexpected()
    return this.node(t, { kind: rt.INPUT_OBJECT_TYPE_EXTENSION, name: r, directives: a, fields: o })
  }
  parseDirectiveDefinition() {
    const t = this._lexer.token,
      r = this.parseDescription()
    this.expectKeyword('directive'), this.expectToken(oe.AT)
    const a = this.parseName(),
      o = this.parseArgumentDefs(),
      u = this.expectOptionalKeyword('repeatable')
    this.expectKeyword('on')
    const l = this.parseDirectiveLocations()
    return this.node(t, {
      kind: rt.DIRECTIVE_DEFINITION,
      description: r,
      name: a,
      arguments: o,
      repeatable: u,
      locations: l
    })
  }
  parseDirectiveLocations() {
    return this.delimitedMany(oe.PIPE, this.parseDirectiveLocation)
  }
  parseDirectiveLocation() {
    const t = this._lexer.token,
      r = this.parseName()
    if (Object.prototype.hasOwnProperty.call(fS, r.value)) return r
    throw this.unexpected(t)
  }
  node(t, r) {
    return (
      this._options.noLocation !== !0 && (r.loc = new _q(t, this._lexer.lastToken, this._lexer.source)),
      r
    )
  }
  peek(t) {
    return this._lexer.token.kind === t
  }
  expectToken(t) {
    const r = this._lexer.token
    if (r.kind === t) return this.advanceLexer(), r
    throw cr(this._lexer.source, r.start, `Expected ${eM(t)}, found ${Ev(r)}.`)
  }
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1
  }
  expectKeyword(t) {
    const r = this._lexer.token
    if (r.kind === oe.NAME && r.value === t) this.advanceLexer()
    else throw cr(this._lexer.source, r.start, `Expected "${t}", found ${Ev(r)}.`)
  }
  expectOptionalKeyword(t) {
    const r = this._lexer.token
    return r.kind === oe.NAME && r.value === t ? (this.advanceLexer(), !0) : !1
  }
  unexpected(t) {
    const r = t ?? this._lexer.token
    return cr(this._lexer.source, r.start, `Unexpected ${Ev(r)}.`)
  }
  any(t, r, a) {
    this.expectToken(t)
    const o = []
    for (; !this.expectOptionalToken(a); ) o.push(r.call(this))
    return o
  }
  optionalMany(t, r, a) {
    if (this.expectOptionalToken(t)) {
      const o = []
      do o.push(r.call(this))
      while (!this.expectOptionalToken(a))
      return o
    }
    return []
  }
  many(t, r, a) {
    this.expectToken(t)
    const o = []
    do o.push(r.call(this))
    while (!this.expectOptionalToken(a))
    return o
  }
  delimitedMany(t, r) {
    this.expectOptionalToken(t)
    const a = []
    do a.push(r.call(this))
    while (this.expectOptionalToken(t))
    return a
  }
  advanceLexer() {
    const { maxTokens: t } = this._options,
      r = this._lexer.advance()
    if (t !== void 0 && r.kind !== oe.EOF && (++this._tokenCounter, this._tokenCounter > t))
      throw cr(this._lexer.source, r.start, `Document contains more that ${t} tokens. Parsing aborted.`)
  }
}
function Ev(e) {
  const t = e.value
  return eM(e.kind) + (t != null ? ` "${t}"` : '')
}
function eM(e) {
  return Lq(e) ? `"${e}"` : e
}
function tG(e) {
  return `"${e.replace(nG, rG)}"`
}
const nG = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g
function rG(e) {
  return iG[e.charCodeAt(0)]
}
const iG = [
    '\\u0000',
    '\\u0001',
    '\\u0002',
    '\\u0003',
    '\\u0004',
    '\\u0005',
    '\\u0006',
    '\\u0007',
    '\\b',
    '\\t',
    '\\n',
    '\\u000B',
    '\\f',
    '\\r',
    '\\u000E',
    '\\u000F',
    '\\u0010',
    '\\u0011',
    '\\u0012',
    '\\u0013',
    '\\u0014',
    '\\u0015',
    '\\u0016',
    '\\u0017',
    '\\u0018',
    '\\u0019',
    '\\u001A',
    '\\u001B',
    '\\u001C',
    '\\u001D',
    '\\u001E',
    '\\u001F',
    '',
    '',
    '\\"',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\u007F',
    '\\u0080',
    '\\u0081',
    '\\u0082',
    '\\u0083',
    '\\u0084',
    '\\u0085',
    '\\u0086',
    '\\u0087',
    '\\u0088',
    '\\u0089',
    '\\u008A',
    '\\u008B',
    '\\u008C',
    '\\u008D',
    '\\u008E',
    '\\u008F',
    '\\u0090',
    '\\u0091',
    '\\u0092',
    '\\u0093',
    '\\u0094',
    '\\u0095',
    '\\u0096',
    '\\u0097',
    '\\u0098',
    '\\u0099',
    '\\u009A',
    '\\u009B',
    '\\u009C',
    '\\u009D',
    '\\u009E',
    '\\u009F'
  ],
  aG = Object.freeze({})
function oG(e, t, r = qN) {
  const a = new Map()
  for (const R of Object.values(rt)) a.set(R, sG(t, R))
  let o,
    u = Array.isArray(e),
    l = [e],
    d = -1,
    h = [],
    p = e,
    v,
    g
  const E = [],
    x = []
  do {
    d++
    const R = d === l.length,
      D = R && h.length !== 0
    if (R) {
      if (((v = x.length === 0 ? void 0 : E[E.length - 1]), (p = g), (g = x.pop()), D))
        if (u) {
          p = p.slice()
          let L = 0
          for (const [F, z] of h) {
            const H = F - L
            z === null ? (p.splice(H, 1), L++) : (p[H] = z)
          }
        } else {
          p = Object.defineProperties({}, Object.getOwnPropertyDescriptors(p))
          for (const [L, F] of h) p[L] = F
        }
      ;(d = o.index), (l = o.keys), (h = o.edits), (u = o.inArray), (o = o.prev)
    } else if (g) {
      if (((v = u ? d : l[d]), (p = g[v]), p == null)) continue
      E.push(v)
    }
    let A
    if (!Array.isArray(p)) {
      var C, _
      JO(p) || Nv(!1, `Invalid AST Node: ${E1(p)}.`)
      const L = R
        ? (C = a.get(p.kind)) === null || C === void 0
          ? void 0
          : C.leave
        : (_ = a.get(p.kind)) === null || _ === void 0
          ? void 0
          : _.enter
      if (((A = L == null ? void 0 : L.call(t, p, v, g, E, x)), A === aG)) break
      if (A === !1) {
        if (!R) {
          E.pop()
          continue
        }
      } else if (A !== void 0 && (h.push([v, A]), !R))
        if (JO(A)) p = A
        else {
          E.pop()
          continue
        }
    }
    if ((A === void 0 && D && h.push([v, p]), R)) E.pop()
    else {
      var k
      ;(o = { inArray: u, index: d, keys: l, edits: h, prev: o }),
        (u = Array.isArray(p)),
        (l = u ? p : (k = r[p.kind]) !== null && k !== void 0 ? k : []),
        (d = -1),
        (h = []),
        g && x.push(g),
        (g = p)
    }
  } while (o !== void 0)
  return h.length !== 0 ? h[h.length - 1][1] : e
}
function sG(e, t) {
  const r = e[t]
  return typeof r == 'object'
    ? r
    : typeof r == 'function'
      ? { enter: r, leave: void 0 }
      : { enter: e.enter, leave: e.leave }
}
function lG(e) {
  return oG(e, cG)
}
const uG = 80,
  cG = {
    Name: { leave: e => e.value },
    Variable: { leave: e => '$' + e.name },
    Document: {
      leave: e =>
        ze(
          e.definitions,
          `

`
        )
    },
    OperationDefinition: {
      leave(e) {
        const t = Ut('(', ze(e.variableDefinitions, ', '), ')'),
          r = ze([e.operation, ze([e.name, t]), ze(e.directives, ' ')], ' ')
        return (r === 'query' ? '' : r + ' ') + e.selectionSet
      }
    },
    VariableDefinition: {
      leave: ({ variable: e, type: t, defaultValue: r, directives: a }) =>
        e + ': ' + t + Ut(' = ', r) + Ut(' ', ze(a, ' '))
    },
    SelectionSet: { leave: ({ selections: e }) => ua(e) },
    Field: {
      leave({ alias: e, name: t, arguments: r, directives: a, selectionSet: o }) {
        const u = Ut('', e, ': ') + t
        let l = u + Ut('(', ze(r, ', '), ')')
        return (
          l.length > uG &&
            (l =
              u +
              Ut(
                `(
`,
                Mv(
                  ze(
                    r,
                    `
`
                  )
                ),
                `
)`
              )),
          ze([l, ze(a, ' '), o], ' ')
        )
      }
    },
    Argument: { leave: ({ name: e, value: t }) => e + ': ' + t },
    FragmentSpread: { leave: ({ name: e, directives: t }) => '...' + e + Ut(' ', ze(t, ' ')) },
    InlineFragment: {
      leave: ({ typeCondition: e, directives: t, selectionSet: r }) =>
        ze(['...', Ut('on ', e), ze(t, ' '), r], ' ')
    },
    FragmentDefinition: {
      leave: ({ name: e, typeCondition: t, variableDefinitions: r, directives: a, selectionSet: o }) =>
        `fragment ${e}${Ut('(', ze(r, ', '), ')')} on ${t} ${Ut('', ze(a, ' '), ' ')}` + o
    },
    IntValue: { leave: ({ value: e }) => e },
    FloatValue: { leave: ({ value: e }) => e },
    StringValue: { leave: ({ value: e, block: t }) => (t ? Nq(e) : tG(e)) },
    BooleanValue: { leave: ({ value: e }) => (e ? 'true' : 'false') },
    NullValue: { leave: () => 'null' },
    EnumValue: { leave: ({ value: e }) => e },
    ListValue: { leave: ({ values: e }) => '[' + ze(e, ', ') + ']' },
    ObjectValue: { leave: ({ fields: e }) => '{' + ze(e, ', ') + '}' },
    ObjectField: { leave: ({ name: e, value: t }) => e + ': ' + t },
    Directive: { leave: ({ name: e, arguments: t }) => '@' + e + Ut('(', ze(t, ', '), ')') },
    NamedType: { leave: ({ name: e }) => e },
    ListType: { leave: ({ type: e }) => '[' + e + ']' },
    NonNullType: { leave: ({ type: e }) => e + '!' },
    SchemaDefinition: {
      leave: ({ description: e, directives: t, operationTypes: r }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['schema', ze(t, ' '), ua(r)], ' ')
    },
    OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ': ' + t },
    ScalarTypeDefinition: {
      leave: ({ description: e, name: t, directives: r }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['scalar', t, ze(r, ' ')], ' ')
    },
    ObjectTypeDefinition: {
      leave: ({ description: e, name: t, interfaces: r, directives: a, fields: o }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['type', t, Ut('implements ', ze(r, ' & ')), ze(a, ' '), ua(o)], ' ')
    },
    FieldDefinition: {
      leave: ({ description: e, name: t, arguments: r, type: a, directives: o }) =>
        Ut(
          '',
          e,
          `
`
        ) +
        t +
        (tk(r)
          ? Ut(
              `(
`,
              Mv(
                ze(
                  r,
                  `
`
                )
              ),
              `
)`
            )
          : Ut('(', ze(r, ', '), ')')) +
        ': ' +
        a +
        Ut(' ', ze(o, ' '))
    },
    InputValueDefinition: {
      leave: ({ description: e, name: t, type: r, defaultValue: a, directives: o }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze([t + ': ' + r, Ut('= ', a), ze(o, ' ')], ' ')
    },
    InterfaceTypeDefinition: {
      leave: ({ description: e, name: t, interfaces: r, directives: a, fields: o }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['interface', t, Ut('implements ', ze(r, ' & ')), ze(a, ' '), ua(o)], ' ')
    },
    UnionTypeDefinition: {
      leave: ({ description: e, name: t, directives: r, types: a }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['union', t, ze(r, ' '), Ut('= ', ze(a, ' | '))], ' ')
    },
    EnumTypeDefinition: {
      leave: ({ description: e, name: t, directives: r, values: a }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['enum', t, ze(r, ' '), ua(a)], ' ')
    },
    EnumValueDefinition: {
      leave: ({ description: e, name: t, directives: r }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze([t, ze(r, ' ')], ' ')
    },
    InputObjectTypeDefinition: {
      leave: ({ description: e, name: t, directives: r, fields: a }) =>
        Ut(
          '',
          e,
          `
`
        ) + ze(['input', t, ze(r, ' '), ua(a)], ' ')
    },
    DirectiveDefinition: {
      leave: ({ description: e, name: t, arguments: r, repeatable: a, locations: o }) =>
        Ut(
          '',
          e,
          `
`
        ) +
        'directive @' +
        t +
        (tk(r)
          ? Ut(
              `(
`,
              Mv(
                ze(
                  r,
                  `
`
                )
              ),
              `
)`
            )
          : Ut('(', ze(r, ', '), ')')) +
        (a ? ' repeatable' : '') +
        ' on ' +
        ze(o, ' | ')
    },
    SchemaExtension: {
      leave: ({ directives: e, operationTypes: t }) => ze(['extend schema', ze(e, ' '), ua(t)], ' ')
    },
    ScalarTypeExtension: {
      leave: ({ name: e, directives: t }) => ze(['extend scalar', e, ze(t, ' ')], ' ')
    },
    ObjectTypeExtension: {
      leave: ({ name: e, interfaces: t, directives: r, fields: a }) =>
        ze(['extend type', e, Ut('implements ', ze(t, ' & ')), ze(r, ' '), ua(a)], ' ')
    },
    InterfaceTypeExtension: {
      leave: ({ name: e, interfaces: t, directives: r, fields: a }) =>
        ze(['extend interface', e, Ut('implements ', ze(t, ' & ')), ze(r, ' '), ua(a)], ' ')
    },
    UnionTypeExtension: {
      leave: ({ name: e, directives: t, types: r }) =>
        ze(['extend union', e, ze(t, ' '), Ut('= ', ze(r, ' | '))], ' ')
    },
    EnumTypeExtension: {
      leave: ({ name: e, directives: t, values: r }) => ze(['extend enum', e, ze(t, ' '), ua(r)], ' ')
    },
    InputObjectTypeExtension: {
      leave: ({ name: e, directives: t, fields: r }) => ze(['extend input', e, ze(t, ' '), ua(r)], ' ')
    }
  }
function ze(e, t = '') {
  var r
  return (r = e == null ? void 0 : e.filter(a => a).join(t)) !== null && r !== void 0 ? r : ''
}
function ua(e) {
  return Ut(
    `{
`,
    Mv(
      ze(
        e,
        `
`
      )
    ),
    `
}`
  )
}
function Ut(e, t, r = '') {
  return t != null && t !== '' ? e + t + r : ''
}
function Mv(e) {
  return Ut(
    '  ',
    e.replace(
      /\n/g,
      `
  `
    )
  )
}
function tk(e) {
  var t
  return (t =
    e == null
      ? void 0
      : e.some(r =>
          r.includes(`
`)
        )) !== null && t !== void 0
    ? t
    : !1
}
const nk = 'Accept',
  hS = 'Content-Type',
  pS = 'application/json',
  tM = 'application/graphql-response+json',
  rk = e => e.replace(/([\s,]|#[^\n\r]+)+/g, ' ').trim(),
  fG = e => {
    const t = e.toLowerCase()
    return t.includes(tM) || t.includes(pS)
  },
  ik = e => {
    try {
      if (Array.isArray(e)) return { _tag: 'Batch', executionResults: e.map(ak) }
      if (Dv(e)) return { _tag: 'Single', executionResult: ak(e) }
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(e)}`)
    } catch (t) {
      return t
    }
  },
  ak = e => {
    if (typeof e != 'object' || e === null)
      throw new Error('Invalid execution result: result is not object')
    let t, r, a
    if ('errors' in e) {
      if (!Dv(e.errors) && !Array.isArray(e.errors))
        throw new Error('Invalid execution result: errors is not plain object OR array')
      t = e.errors
    }
    if ('data' in e) {
      if (!Dv(e.data) && e.data !== null)
        throw new Error('Invalid execution result: data is not plain object')
      r = e.data
    }
    if ('extensions' in e) {
      if (!Dv(e.extensions)) throw new Error('Invalid execution result: extensions is not plain object')
      a = e.extensions
    }
    return { data: r, errors: t, extensions: a }
  },
  dG = e => (e._tag === 'Batch' ? e.executionResults.some(ok) : ok(e.executionResult)),
  ok = e => (Array.isArray(e.errors) ? e.errors.length > 0 : !!e.errors),
  nM = e => typeof e == 'object' && e !== null && 'kind' in e && e.kind === rt.OPERATION_DEFINITION,
  hG = e => {
    var a
    let t
    const r = e.definitions.filter(nM)
    return r.length === 1 && (t = (a = r[0].name) == null ? void 0 : a.value), t
  },
  pG = e => {
    let t = !1
    const r = e.definitions.filter(nM)
    return r.length === 1 && (t = r[0].operation === wl.MUTATION), t
  },
  hx = (e, t) => {
    const r = typeof e == 'string' ? e : lG(e)
    let a = !1,
      o
    if (t) return { expression: r, isMutation: a, operationName: o }
    const u = yq(() => (typeof e == 'string' ? Jq(e) : e))
    return u instanceof Error
      ? { expression: r, isMutation: a, operationName: o }
      : ((o = hG(u)), (a = pG(u)), { expression: r, operationName: o, isMutation: a })
  },
  x1 = JSON,
  px = async e => {
    const t = {
        ...e,
        method:
          e.request._tag === 'Single'
            ? e.request.document.isMutation
              ? 'POST'
              : KO(e.method ?? 'post')
            : e.request.hasMutations
              ? 'POST'
              : KO(e.method ?? 'post'),
        fetchOptions: { ...e.fetchOptions, errorPolicy: e.fetchOptions.errorPolicy ?? 'none' }
      },
      a = await vG(t.method)(t)
    if (!a.ok)
      return new uc(
        { status: a.status, headers: a.headers },
        {
          query: e.request._tag === 'Single' ? e.request.document.expression : e.request.query,
          variables: e.request.variables
        }
      )
    const o = await mG(a, e.fetchOptions.jsonSerializer ?? x1)
    if (o instanceof Error) throw o
    const u = { status: a.status, headers: a.headers }
    if (dG(o) && t.fetchOptions.errorPolicy === 'none') {
      const l = o._tag === 'Batch' ? { ...o.executionResults, ...u } : { ...o.executionResult, ...u }
      return new uc(l, {
        query: e.request._tag === 'Single' ? e.request.document.expression : e.request.query,
        variables: e.request.variables
      })
    }
    switch (o._tag) {
      case 'Single':
        return { ...u, ...sk(t)(o.executionResult) }
      case 'Batch':
        return { ...u, data: o.executionResults.map(sk(t)) }
      default:
        y1(o)
    }
  },
  sk = e => t => ({
    extensions: t.extensions,
    data: t.data,
    errors: e.fetchOptions.errorPolicy === 'all' ? t.errors : void 0
  }),
  mG = async (e, t) => {
    const r = e.headers.get(hS),
      a = await e.text()
    return r && fG(r) ? ik(t.parse(a)) : ik(a)
  },
  vG = e => async t => {
    const r = new Headers(t.headers)
    let a = null,
      o
    r.has(nk) || r.set(nk, [tM, pS].join(', ')),
      e === 'POST'
        ? ((o = (t.fetchOptions.jsonSerializer ?? x1).stringify(gG(t))),
          typeof o == 'string' && !r.has(hS) && r.set(hS, pS))
        : (a = yG(t))
    const u = { method: e, headers: r, body: o, ...t.fetchOptions }
    let l = new URL(t.url),
      d = u
    if (t.middleware) {
      const p = await Promise.resolve(
          t.middleware({
            ...u,
            url: t.url,
            operationName: t.request._tag === 'Single' ? t.request.document.operationName : void 0,
            variables: t.request.variables
          })
        ),
        { url: v, ...g } = p
      ;(l = new URL(v)), (d = g)
    }
    return (
      a &&
        a.forEach((p, v) => {
          l.searchParams.append(v, p)
        }),
      await (t.fetch ?? fetch)(l, d)
    )
  },
  gG = e => {
    switch (e.request._tag) {
      case 'Single':
        return {
          query: e.request.document.expression,
          variables: e.request.variables,
          operationName: e.request.document.operationName
        }
      case 'Batch':
        return HN(e.request.query, e.request.variables ?? []).map(([t, r]) => ({
          query: t,
          variables: r
        }))
      default:
        throw y1(e.request)
    }
  },
  yG = e => {
    var a
    const t = e.fetchOptions.jsonSerializer ?? x1,
      r = new URLSearchParams()
    switch (e.request._tag) {
      case 'Single':
        return (
          r.append('query', rk(e.request.document.expression)),
          e.request.variables && r.append('variables', t.stringify(e.request.variables)),
          e.request.document.operationName &&
            r.append('operationName', e.request.document.operationName),
          r
        )
      case 'Batch': {
        const o = ((a = e.request.variables) == null ? void 0 : a.map(d => t.stringify(d))) ?? [],
          u = e.request.query.map(rk),
          l = HN(u, o).map(([d, h]) => ({ query: d, variables: h }))
        return r.append('query', t.stringify(l)), r
      }
      default:
        throw y1(e.request)
    }
  }
class bG {
  constructor(t, r = {}) {
    Hu(this, 'url')
    Hu(this, 'requestConfig')
    Hu(this, 'rawRequest', async (...t) => {
      const [r, a, o] = t,
        u = xq(r, a, o),
        {
          headers: l,
          fetch: d = globalThis.fetch,
          method: h = 'POST',
          requestMiddleware: p,
          responseMiddleware: v,
          excludeOperationName: g,
          ...E
        } = this.requestConfig,
        { url: x } = this
      u.signal !== void 0 && (E.signal = u.signal)
      const C = hx(u.query, g),
        _ = await px({
          url: x,
          request: { _tag: 'Single', document: C, variables: u.variables },
          headers: { ...qu(fx(l)), ...qu(u.requestHeaders) },
          fetch: d,
          method: h,
          fetchOptions: E,
          middleware: p
        })
      if (
        (v && (await v(_, { operationName: C.operationName, variables: a, url: this.url })),
        _ instanceof Error)
      )
        throw _
      return _
    })
    ;(this.url = t), (this.requestConfig = r)
  }
  async request(t, ...r) {
    const [a, o] = r,
      u = EG(t, a, o),
      {
        headers: l,
        fetch: d = globalThis.fetch,
        method: h = 'POST',
        requestMiddleware: p,
        responseMiddleware: v,
        excludeOperationName: g,
        ...E
      } = this.requestConfig,
      { url: x } = this
    u.signal !== void 0 && (E.signal = u.signal)
    const C = hx(u.document, g),
      _ = await px({
        url: x,
        request: { _tag: 'Single', document: C, variables: u.variables },
        headers: { ...qu(fx(l)), ...qu(u.requestHeaders) },
        fetch: d,
        method: h,
        fetchOptions: E,
        middleware: p
      })
    if (
      (v && (await v(_, { operationName: C.operationName, variables: u.variables, url: this.url })),
      _ instanceof Error)
    )
      throw _
    return _.data
  }
  async batchRequests(t, r) {
    const a = Eq(t, r),
      { headers: o, excludeOperationName: u, ...l } = this.requestConfig
    a.signal !== void 0 && (l.signal = a.signal)
    const d = a.documents.map(({ document: E }) => hx(E, u)),
      h = d.map(({ expression: E }) => E),
      p = d.some(({ isMutation: E }) => E),
      v = a.documents.map(({ variables: E }) => E),
      g = await px({
        url: this.url,
        request: { _tag: 'Batch', operationName: void 0, query: h, hasMutations: p, variables: v },
        headers: { ...qu(fx(o)), ...qu(a.requestHeaders) },
        fetch: this.requestConfig.fetch ?? globalThis.fetch,
        method: this.requestConfig.method || 'POST',
        fetchOptions: l,
        middleware: this.requestConfig.requestMiddleware
      })
    if (
      (this.requestConfig.responseMiddleware &&
        (await this.requestConfig.responseMiddleware(g, {
          operationName: void 0,
          variables: v,
          url: this.url
        })),
      g instanceof Error)
    )
      throw g
    return g.data
  }
  setHeaders(t) {
    return (this.requestConfig.headers = t), this
  }
  setHeader(t, r) {
    const { headers: a } = this.requestConfig
    return a ? (a[t] = r) : (this.requestConfig.headers = { [t]: r }), this
  }
  setEndpoint(t) {
    return (this.url = t), this
  }
}
async function rM(e, t, ...r) {
  const a = xG(e, t, ...r)
  return new bG(a.url).request({ ...a })
}
const EG = (e, t, r) =>
    e.document ? e : { document: e, variables: t, requestHeaders: r, signal: void 0 },
  xG = (e, t, ...r) => {
    const [a, o] = r
    return typeof e == 'string'
      ? { url: e, document: t, variables: a, requestHeaders: o, signal: void 0 }
      : e
  },
  iM = (e, ...t) => e.reduce((r, a, o) => `${r}${a}${o in t ? String(t[o]) : ''}`, ''),
  aM = 'https://beta.pokeapi.co/graphql/v1beta',
  SG = ({ types: e, nameOrder: t, heightOrder: r }) => iM`
  query getPokemonByNameAndType(
    $name: String
    $limit: Int!
    $offset: Int!
    $types: [String]
    $nameOrder: order_by
    $heightOrder: order_by
  ) {
    pokemon_aggregate: pokemon_v2_pokemon_aggregate(
      where: {
        name: { _like: $name }
        ${e ? 'pokemon_v2_pokemontypes: { pokemon_v2_type: { name: { _in: $types } } }' : ''}
      }
    ) {
      aggregate {
        count
      }
    }
    pokemons: pokemon_v2_pokemon(
      where: {
        name: { _like: $name }
        ${e ? 'pokemon_v2_pokemontypes: { pokemon_v2_type: { name: { _in: $types } } }' : ''}
      }
      limit: $limit
      offset: $offset
      ${t ? 'order_by: { name: $nameOrder }' : ''}
      ${r ? 'order_by: { height: $heightOrder }' : ''}
    ) {
      name
      sprites: pokemon_v2_pokemonsprites {
        sprites
      }
      types: pokemon_v2_pokemontypes {
        pokemon_v2_type {
          name
        }
      }
    }
  }
  `,
  TG = iM`
  query getPokemonTypes {
    pokemon_v2_type {
      name
    }
  }
`,
  CG = async ({ name: e, limit: t, offset: r, types: a, sort: o }) => {
    const u = {
      name: e ? `%${e}%` : '%%',
      limit: t,
      offset: r,
      types: (a == null ? void 0 : a.split('-')) || void 0,
      nameOrder: void 0,
      heightOrder: void 0
    }
    switch (o) {
      case 'name-asc':
        u.nameOrder = 'asc'
        break
      case 'name-desc':
        u.nameOrder = 'desc'
        break
      case 'height-asc':
        u.heightOrder = 'asc'
        break
      case 'height-desc':
        u.heightOrder = 'desc'
        break
    }
    return rM(aM, SG(u), u)
  },
  wG = async () => rM(aM, TG)
function RG() {
  const {
    data: e,
    isLoading: t,
    isError: r,
    error: a
  } = qk({ queryKey: ['pokemon-types'], queryFn: wG, staleTime: KD })
  return {
    types: e == null ? void 0 : e.pokemon_v2_type.sort((o, u) => o.name.localeCompare(u.name)),
    isLoading: t,
    isError: r,
    error: a
  }
}
function _G() {
  const { type: e } = Mc({ from: '/' }),
    t = e ? (e == null ? void 0 : e.split('-')) : [],
    [r, a] = w.useState(t),
    { types: o, isLoading: u, error: l, isError: d } = RG(),
    h = Lc()
  d && console.error({ error: l })
  const p = v => {
    a(v), h({ search: g => ({ ...g, types: v.join('-') || void 0, offset: jh }), resetScroll: !1 })
  }
  return le.jsxDEV(
    'div',
    {
      className: 'w-44 inline-block',
      children: le.jsxDEV(
        zN,
        {
          multiple: !0,
          value: r,
          onChange: p,
          children: [
            le.jsxDEV(
              'div',
              {
                className: 'relative',
                children: [
                  le.jsxDEV(
                    m1,
                    {
                      readOnly: !0,
                      'aria-label': 'Type filter',
                      className: Fl(
                        'w-full rounded-full border py-1.5 pr-8 pl-3 h-11 text-sm/6 dark:text-white dark:border-slate-800 border-slate-300 bg-slate-50 dark:bg-slate-900 select-none',
                        'focus:outline-none data-[focus]:outline-2 data-[focus]:-outline-offset-1 data-[focus]:outline-yellow-500'
                      ),
                      displayValue: () => `Filter by types (${r.length})`
                    },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                      lineNumber: 49,
                      columnNumber: 11
                    },
                    this
                  ),
                  le.jsxDEV(
                    p1,
                    {
                      'aria-label': 'Open type filter menu',
                      disabled: u || d,
                      className:
                        'group rounded-full w-full h-11 flex justify-end items-center dark:text-slate-400 inset-y-0 my-auto absolute px-3',
                      children: le.jsxDEV(
                        ZV,
                        { className: 'size-4 dark:text-slate-50' },
                        void 0,
                        !1,
                        {
                          fileName:
                            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                          lineNumber: 63,
                          columnNumber: 13
                        },
                        this
                      )
                    },
                    void 0,
                    !1,
                    {
                      fileName:
                        '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                      lineNumber: 58,
                      columnNumber: 11
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                lineNumber: 48,
                columnNumber: 9
              },
              this
            ),
            le.jsxDEV(
              v1,
              {
                anchor: 'bottom start',
                transition: !0,
                className: Fl(
                  'w-52 rounded-xl border bg-slate-800 border-slate-900 p-1 [--anchor-gap:var(--spacing-1)] empty:invisible',
                  'transition duration-100 ease-in data-[leave]:data-[closed]:opacity-0'
                ),
                children:
                  o == null
                    ? void 0
                    : o.map(v =>
                        le.jsxDEV(
                          g1,
                          {
                            value: v.name,
                            className:
                              'group flex justify-between cursor-pointer items-center gap-2 rounded-lg text-white  hover:bg-slate-600 py-1.5 px-3 select-none data-[selected]:bg-slate-700',
                            children: [
                              le.jsxDEV(
                                'div',
                                {
                                  className: 'flex gap-3 items-center',
                                  children: [
                                    Object.prototype.hasOwnProperty.call(Qx, v.name)
                                      ? le.jsxDEV(
                                          'div',
                                          {
                                            className: 'rounded-full p-2 bg-slate-400',
                                            style: { background: ZD[v.name] },
                                            children: le.jsxDEV(
                                              'img',
                                              {
                                                height: 20,
                                                width: 20,
                                                alt: `Type ${v.name} icon`,
                                                src: Qx[v.name] || ''
                                              },
                                              void 0,
                                              !1,
                                              {
                                                fileName:
                                                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                                lineNumber: 87,
                                                columnNumber: 21
                                              },
                                              this
                                            )
                                          },
                                          void 0,
                                          !1,
                                          {
                                            fileName:
                                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                            lineNumber: 83,
                                            columnNumber: 19
                                          },
                                          this
                                        )
                                      : le.jsxDEV(
                                          'div',
                                          { className: 'size-9 bg-slate-50 rounded-full' },
                                          void 0,
                                          !1,
                                          {
                                            fileName:
                                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                            lineNumber: 95,
                                            columnNumber: 19
                                          },
                                          this
                                        ),
                                    le.jsxDEV(
                                      'div',
                                      { className: 'text-sm/6 capitalize', children: v.name },
                                      void 0,
                                      !1,
                                      {
                                        fileName:
                                          '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                        lineNumber: 98,
                                        columnNumber: 17
                                      },
                                      this
                                    )
                                  ]
                                },
                                void 0,
                                !0,
                                {
                                  fileName:
                                    '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                  lineNumber: 81,
                                  columnNumber: 15
                                },
                                this
                              ),
                              le.jsxDEV(
                                vA,
                                {
                                  className:
                                    'invisible size-4  text-slate-50 group-data-[selected]:visible'
                                },
                                void 0,
                                !1,
                                {
                                  fileName:
                                    '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                                  lineNumber: 100,
                                  columnNumber: 15
                                },
                                this
                              )
                            ]
                          },
                          v.name,
                          !0,
                          {
                            fileName:
                              '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                            lineNumber: 76,
                            columnNumber: 13
                          },
                          this
                        )
                      )
              },
              void 0,
              !1,
              {
                fileName:
                  '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
                lineNumber: 67,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName:
            '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
          lineNumber: 47,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/pokemon/type-filter/type-filter.tsx',
      lineNumber: 46,
      columnNumber: 5
    },
    this
  )
}
const OG = 300
function kG() {
  const { name: e } = Mc({ from: '/' }),
    [t, r] = w.useState(e || ''),
    [a, o] = w.useState(''),
    u = Lc(),
    l = w.useRef(!0)
  w.useEffect(() => {
    ;(l.current && !a) ||
      (u({
        search: h => ({ ...h, name: (a == null ? void 0 : a.toLowerCase()) || void 0, offset: jh }),
        resetScroll: !1
      }),
      (l.current = !1))
  }, [a, u]),
    v8(() => o(t), OG, [t])
  const d = h => {
    r(h.target.value)
  }
  return le.jsxDEV(
    'div',
    {
      className: 'relative focus-within:text-yellow-500 dark:text-white inline-block',
      children: [
        le.jsxDEV(
          'input',
          {
            className: Fl(
              'h-11 inline-block rounded-full px-4 w-64 pl-10',
              'border border-slate-300 dark:border-slate-800 bg-slate-50 dark:bg-slate-900 text-slate-950 dark:text-white',
              'focus:outline-none focus:ring-2 ring-yellow-500  focus:bg-white focus:dark:bg-slate-800'
            ),
            onChange: d,
            type: 'search',
            value: t,
            placeholder: 'Search for a Pokmon...'
          },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/search/search.tsx',
            lineNumber: 40,
            columnNumber: 7
          },
          this
        ),
        le.jsxDEV(
          n8,
          { size: 18, className: 'absolute inset-y-0 my-auto left-4' },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/components/search/search.tsx',
            lineNumber: 51,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: '/Volumes/workspace/pokemon-frontend/src/components/search/search.tsx',
      lineNumber: 39,
      columnNumber: 5
    },
    this
  )
}
const AG = ({ name: e, limit: t = th, offset: r = jh, types: a, sort: o }) => {
  const {
    data: u,
    isLoading: l,
    isError: d,
    error: h,
    isFetching: p
  } = qk({
    queryKey: ['pokemon', e, t, r, a, o],
    queryFn: () => CG({ name: e, limit: t, offset: r, types: a, sort: o }),
    staleTime: KD,
    placeholderData: v => v
  })
  return {
    pokemons: u == null ? void 0 : u.pokemons,
    totalItems: u == null ? void 0 : u.pokemon_aggregate.aggregate.count,
    isLoading: l,
    isError: d,
    error: h,
    isFetching: p
  }
}
function DG() {
  const e = w.useRef(0),
    { limit: t, offset: r, ...a } = Mc({ from: '/' }),
    o = Lc(),
    {
      pokemons: u,
      totalItems: l,
      isLoading: d,
      isError: h,
      error: p,
      isFetching: v
    } = AG({ limit: t, offset: r, ...a })
  !d && e.current !== l && (e.current = l || 0)
  const g = x => {
      o({ search: C => ({ ...C, offset: x }), resetScroll: !1 }),
        window.scrollTo({ top: 0, behavior: 'smooth' })
    },
    E = x => {
      o({ search: C => ({ ...C, limit: x }) })
    }
  return h
    ? le.jsxDEV(
        'div',
        {
          children: [
            le.jsxDEV(
              'h2',
              { children: 'Error occurred:' },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                lineNumber: 42,
                columnNumber: 9
              },
              this
            ),
            le.jsxDEV(
              'p',
              { children: p == null ? void 0 : p.message },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                lineNumber: 43,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
          lineNumber: 41,
          columnNumber: 7
        },
        this
      )
    : le.jsxDEV(
        'div',
        {
          children: [
            v &&
              le.jsxDEV(
                e8,
                {
                  'aria-label': 'Loading...',
                  className: Fl(
                    'z-50',
                    'dark:bg-slate-900 dark:text-white border dark:border-slate-800',
                    'mx-auto mt-40 sm:mt-24 animate-spin bg-slate-50 p-3 absolute inset-0 m-auto -top-3  rounded-full border-slate-200'
                  ),
                  size: 52
                },
                void 0,
                !1,
                {
                  fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                  lineNumber: 51,
                  columnNumber: 9
                },
                this
              ),
            le.jsxDEV(
              'div',
              {
                className: 'flex items-center justify-between mt-40 sm:mt-28 px-6 sm:flex-col sm:gap-3',
                children: [
                  le.jsxDEV(
                    kG,
                    {},
                    void 0,
                    !1,
                    {
                      fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                      lineNumber: 62,
                      columnNumber: 9
                    },
                    this
                  ),
                  le.jsxDEV(
                    'div',
                    {
                      className: 'flex gap-2',
                      children: [
                        le.jsxDEV(
                          _G,
                          {},
                          void 0,
                          !1,
                          {
                            fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                            lineNumber: 65,
                            columnNumber: 11
                          },
                          this
                        ),
                        le.jsxDEV(
                          vq,
                          {},
                          void 0,
                          !1,
                          {
                            fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                            lineNumber: 66,
                            columnNumber: 11
                          },
                          this
                        )
                      ]
                    },
                    void 0,
                    !0,
                    {
                      fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                      lineNumber: 64,
                      columnNumber: 9
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                lineNumber: 61,
                columnNumber: 7
              },
              this
            ),
            le.jsxDEV(
              Az,
              { pokemons: u, limit: t || th, isLoading: d },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                lineNumber: 70,
                columnNumber: 7
              },
              this
            ),
            le.jsxDEV(
              'div',
              {
                className: 'flex gap-6 justify-center items-center flex-col my-24',
                children: [
                  le.jsxDEV(
                    S8,
                    { totalItems: e.current, itemsPerPage: t || th, offset: r || jh, onOffsetChange: g },
                    void 0,
                    !1,
                    {
                      fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                      lineNumber: 77,
                      columnNumber: 9
                    },
                    this
                  ),
                  le.jsxDEV(
                    x8,
                    { itemsPerPage: t || th, onItemsPerPageChange: E },
                    void 0,
                    !1,
                    {
                      fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                      lineNumber: 83,
                      columnNumber: 9
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
                lineNumber: 76,
                columnNumber: 7
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName: '/Volumes/workspace/pokemon-frontend/src/pages/home/home.tsx',
          lineNumber: 49,
          columnNumber: 5
        },
        this
      )
}
/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */ const {
  entries: oM,
  setPrototypeOf: lk,
  isFrozen: NG,
  getPrototypeOf: MG,
  getOwnPropertyDescriptor: LG
} = Object
let { freeze: Xr, seal: qi, create: sM } = Object,
  { apply: mS, construct: vS } = typeof Reflect < 'u' && Reflect
Xr ||
  (Xr = function (t) {
    return t
  })
qi ||
  (qi = function (t) {
    return t
  })
mS ||
  (mS = function (t, r, a) {
    return t.apply(r, a)
  })
vS ||
  (vS = function (t, r) {
    return new t(...r)
  })
const xv = Ai(Array.prototype.forEach),
  uk = Ai(Array.prototype.pop),
  Id = Ai(Array.prototype.push),
  Lv = Ai(String.prototype.toLowerCase),
  mx = Ai(String.prototype.toString),
  ck = Ai(String.prototype.match),
  Fd = Ai(String.prototype.replace),
  PG = Ai(String.prototype.indexOf),
  IG = Ai(String.prototype.trim),
  ca = Ai(Object.prototype.hasOwnProperty),
  qr = Ai(RegExp.prototype.test),
  Vd = FG(TypeError)
function Ai(e) {
  return function (t) {
    for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      a[o - 1] = arguments[o]
    return mS(e, t, a)
  }
}
function FG(e) {
  return function () {
    for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++) r[a] = arguments[a]
    return vS(e, r)
  }
}
function Ft(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Lv
  lk && lk(e, null)
  let a = t.length
  for (; a--; ) {
    let o = t[a]
    if (typeof o == 'string') {
      const u = r(o)
      u !== o && (NG(t) || (t[a] = u), (o = u))
    }
    e[o] = !0
  }
  return e
}
function VG(e) {
  for (let t = 0; t < e.length; t++) ca(e, t) || (e[t] = null)
  return e
}
function yl(e) {
  const t = sM(null)
  for (const [r, a] of oM(e))
    ca(e, r) &&
      (Array.isArray(a)
        ? (t[r] = VG(a))
        : a && typeof a == 'object' && a.constructor === Object
          ? (t[r] = yl(a))
          : (t[r] = a))
  return t
}
function jd(e, t) {
  for (; e !== null; ) {
    const a = LG(e, t)
    if (a) {
      if (a.get) return Ai(a.get)
      if (typeof a.value == 'function') return Ai(a.value)
    }
    e = MG(e)
  }
  function r() {
    return null
  }
  return r
}
const fk = Xr([
    'a',
    'abbr',
    'acronym',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'bdi',
    'bdo',
    'big',
    'blink',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'center',
    'cite',
    'code',
    'col',
    'colgroup',
    'content',
    'data',
    'datalist',
    'dd',
    'decorator',
    'del',
    'details',
    'dfn',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'element',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meter',
    'nav',
    'nobr',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'section',
    'select',
    'shadow',
    'small',
    'source',
    'spacer',
    'span',
    'strike',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'track',
    'tt',
    'u',
    'ul',
    'var',
    'video',
    'wbr'
  ]),
  vx = Xr([
    'svg',
    'a',
    'altglyph',
    'altglyphdef',
    'altglyphitem',
    'animatecolor',
    'animatemotion',
    'animatetransform',
    'circle',
    'clippath',
    'defs',
    'desc',
    'ellipse',
    'filter',
    'font',
    'g',
    'glyph',
    'glyphref',
    'hkern',
    'image',
    'line',
    'lineargradient',
    'marker',
    'mask',
    'metadata',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialgradient',
    'rect',
    'stop',
    'style',
    'switch',
    'symbol',
    'text',
    'textpath',
    'title',
    'tref',
    'tspan',
    'view',
    'vkern'
  ]),
  gx = Xr([
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence'
  ]),
  jG = Xr([
    'animate',
    'color-profile',
    'cursor',
    'discard',
    'font-face',
    'font-face-format',
    'font-face-name',
    'font-face-src',
    'font-face-uri',
    'foreignobject',
    'hatch',
    'hatchpath',
    'mesh',
    'meshgradient',
    'meshpatch',
    'meshrow',
    'missing-glyph',
    'script',
    'set',
    'solidcolor',
    'unknown',
    'use'
  ]),
  yx = Xr([
    'math',
    'menclose',
    'merror',
    'mfenced',
    'mfrac',
    'mglyph',
    'mi',
    'mlabeledtr',
    'mmultiscripts',
    'mn',
    'mo',
    'mover',
    'mpadded',
    'mphantom',
    'mroot',
    'mrow',
    'ms',
    'mspace',
    'msqrt',
    'mstyle',
    'msub',
    'msup',
    'msubsup',
    'mtable',
    'mtd',
    'mtext',
    'mtr',
    'munder',
    'munderover',
    'mprescripts'
  ]),
  UG = Xr([
    'maction',
    'maligngroup',
    'malignmark',
    'mlongdiv',
    'mscarries',
    'mscarry',
    'msgroup',
    'mstack',
    'msline',
    'msrow',
    'semantics',
    'annotation',
    'annotation-xml',
    'mprescripts',
    'none'
  ]),
  dk = Xr(['#text']),
  hk = Xr([
    'accept',
    'action',
    'align',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autopictureinpicture',
    'autoplay',
    'background',
    'bgcolor',
    'border',
    'capture',
    'cellpadding',
    'cellspacing',
    'checked',
    'cite',
    'class',
    'clear',
    'color',
    'cols',
    'colspan',
    'controls',
    'controlslist',
    'coords',
    'crossorigin',
    'datetime',
    'decoding',
    'default',
    'dir',
    'disabled',
    'disablepictureinpicture',
    'disableremoteplayback',
    'download',
    'draggable',
    'enctype',
    'enterkeyhint',
    'face',
    'for',
    'headers',
    'height',
    'hidden',
    'high',
    'href',
    'hreflang',
    'id',
    'inputmode',
    'integrity',
    'ismap',
    'kind',
    'label',
    'lang',
    'list',
    'loading',
    'loop',
    'low',
    'max',
    'maxlength',
    'media',
    'method',
    'min',
    'minlength',
    'multiple',
    'muted',
    'name',
    'nonce',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'optimum',
    'pattern',
    'placeholder',
    'playsinline',
    'popover',
    'popovertarget',
    'popovertargetaction',
    'poster',
    'preload',
    'pubdate',
    'radiogroup',
    'readonly',
    'rel',
    'required',
    'rev',
    'reversed',
    'role',
    'rows',
    'rowspan',
    'spellcheck',
    'scope',
    'selected',
    'shape',
    'size',
    'sizes',
    'span',
    'srclang',
    'start',
    'src',
    'srcset',
    'step',
    'style',
    'summary',
    'tabindex',
    'title',
    'translate',
    'type',
    'usemap',
    'valign',
    'value',
    'width',
    'wrap',
    'xmlns',
    'slot'
  ]),
  bx = Xr([
    'accent-height',
    'accumulate',
    'additive',
    'alignment-baseline',
    'ascent',
    'attributename',
    'attributetype',
    'azimuth',
    'basefrequency',
    'baseline-shift',
    'begin',
    'bias',
    'by',
    'class',
    'clip',
    'clippathunits',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cx',
    'cy',
    'd',
    'dx',
    'dy',
    'diffuseconstant',
    'direction',
    'display',
    'divisor',
    'dur',
    'edgemode',
    'elevation',
    'end',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'filterunits',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'fx',
    'fy',
    'g1',
    'g2',
    'glyph-name',
    'glyphref',
    'gradientunits',
    'gradienttransform',
    'height',
    'href',
    'id',
    'image-rendering',
    'in',
    'in2',
    'k',
    'k1',
    'k2',
    'k3',
    'k4',
    'kerning',
    'keypoints',
    'keysplines',
    'keytimes',
    'lang',
    'lengthadjust',
    'letter-spacing',
    'kernelmatrix',
    'kernelunitlength',
    'lighting-color',
    'local',
    'marker-end',
    'marker-mid',
    'marker-start',
    'markerheight',
    'markerunits',
    'markerwidth',
    'maskcontentunits',
    'maskunits',
    'max',
    'mask',
    'media',
    'method',
    'mode',
    'min',
    'name',
    'numoctaves',
    'offset',
    'operator',
    'opacity',
    'order',
    'orient',
    'orientation',
    'origin',
    'overflow',
    'paint-order',
    'path',
    'pathlength',
    'patterncontentunits',
    'patterntransform',
    'patternunits',
    'points',
    'preservealpha',
    'preserveaspectratio',
    'primitiveunits',
    'r',
    'rx',
    'ry',
    'radius',
    'refx',
    'refy',
    'repeatcount',
    'repeatdur',
    'restart',
    'result',
    'rotate',
    'scale',
    'seed',
    'shape-rendering',
    'specularconstant',
    'specularexponent',
    'spreadmethod',
    'startoffset',
    'stddeviation',
    'stitchtiles',
    'stop-color',
    'stop-opacity',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke',
    'stroke-width',
    'style',
    'surfacescale',
    'systemlanguage',
    'tabindex',
    'targetx',
    'targety',
    'transform',
    'transform-origin',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'textlength',
    'type',
    'u1',
    'u2',
    'unicode',
    'values',
    'viewbox',
    'visibility',
    'version',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'width',
    'word-spacing',
    'wrap',
    'writing-mode',
    'xchannelselector',
    'ychannelselector',
    'x',
    'x1',
    'x2',
    'xmlns',
    'y',
    'y1',
    'y2',
    'z',
    'zoomandpan'
  ]),
  pk = Xr([
    'accent',
    'accentunder',
    'align',
    'bevelled',
    'close',
    'columnsalign',
    'columnlines',
    'columnspan',
    'denomalign',
    'depth',
    'dir',
    'display',
    'displaystyle',
    'encoding',
    'fence',
    'frame',
    'height',
    'href',
    'id',
    'largeop',
    'length',
    'linethickness',
    'lspace',
    'lquote',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'numalign',
    'open',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'rquote',
    'scriptlevel',
    'scriptminsize',
    'scriptsizemultiplier',
    'selection',
    'separator',
    'separators',
    'stretchy',
    'subscriptshift',
    'supscriptshift',
    'symmetric',
    'voffset',
    'width',
    'xmlns'
  ]),
  Sv = Xr(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']),
  $G = qi(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
  BG = qi(/<%[\w\W]*|[\w\W]*%>/gm),
  zG = qi(/\${[\w\W]*}/gm),
  HG = qi(/^data-[\-\w.\u00B7-\uFFFF]/),
  WG = qi(/^aria-[\-\w]+$/),
  lM = qi(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
  YG = qi(/^(?:\w+script|data):/i),
  qG = qi(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
  uM = qi(/^html$/i),
  GG = qi(/^[a-z][.\w]*(-[.\w]+)+$/i)
var mk = Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: $G,
  ERB_EXPR: BG,
  TMPLIT_EXPR: zG,
  DATA_ATTR: HG,
  ARIA_ATTR: WG,
  IS_ALLOWED_URI: lM,
  IS_SCRIPT_OR_DATA: YG,
  ATTR_WHITESPACE: qG,
  DOCTYPE_NAME: uM,
  CUSTOM_ELEMENT: GG
})
const Ud = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    entityNode: 6,
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
  },
  KG = function () {
    return typeof window > 'u' ? null : window
  },
  ZG = function (t, r) {
    if (typeof t != 'object' || typeof t.createPolicy != 'function') return null
    let a = null
    const o = 'data-tt-policy-suffix'
    r && r.hasAttribute(o) && (a = r.getAttribute(o))
    const u = 'dompurify' + (a ? '#' + a : '')
    try {
      return t.createPolicy(u, {
        createHTML(l) {
          return l
        },
        createScriptURL(l) {
          return l
        }
      })
    } catch {
      return console.warn('TrustedTypes policy ' + u + ' could not be created.'), null
    }
  }
function cM() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : KG()
  const t = ae => cM(ae)
  if (
    ((t.version = '3.1.6'), (t.removed = []), !e || !e.document || e.document.nodeType !== Ud.document)
  )
    return (t.isSupported = !1), t
  let { document: r } = e
  const a = r,
    o = a.currentScript,
    {
      DocumentFragment: u,
      HTMLTemplateElement: l,
      Node: d,
      Element: h,
      NodeFilter: p,
      NamedNodeMap: v = e.NamedNodeMap || e.MozNamedAttrMap,
      HTMLFormElement: g,
      DOMParser: E,
      trustedTypes: x
    } = e,
    C = h.prototype,
    _ = jd(C, 'cloneNode'),
    k = jd(C, 'remove'),
    R = jd(C, 'nextSibling'),
    D = jd(C, 'childNodes'),
    A = jd(C, 'parentNode')
  if (typeof l == 'function') {
    const ae = r.createElement('template')
    ae.content && ae.content.ownerDocument && (r = ae.content.ownerDocument)
  }
  let L,
    F = ''
  const {
      implementation: z,
      createNodeIterator: H,
      createDocumentFragment: $,
      getElementsByTagName: Q
    } = r,
    { importNode: ue } = a
  let se = {}
  t.isSupported =
    typeof oM == 'function' && typeof A == 'function' && z && z.createHTMLDocument !== void 0
  const {
    MUSTACHE_EXPR: we,
    ERB_EXPR: he,
    TMPLIT_EXPR: G,
    DATA_ATTR: ge,
    ARIA_ATTR: De,
    IS_SCRIPT_OR_DATA: de,
    ATTR_WHITESPACE: ve,
    CUSTOM_ELEMENT: Ke
  } = mk
  let { IS_ALLOWED_URI: ot } = mk,
    Me = null
  const Ue = Ft({}, [...fk, ...vx, ...gx, ...yx, ...dk])
  let pe = null
  const xt = Ft({}, [...hk, ...bx, ...pk, ...Sv])
  let Ye = Object.seal(
      sM(null, {
        tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
        attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
        allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 }
      })
    ),
    kt = null,
    yt = null,
    Et = !0,
    st = !0,
    At = !1,
    en = !0,
    nn = !1,
    Re = !0,
    Oe = !1,
    Xe = !1,
    Dt = !1,
    Vt = !1,
    Cn = !1,
    xn = !1,
    Pn = !0,
    tr = !1
  const Un = 'user-content-'
  let In = !0,
    $n = !1,
    mn = {},
    wn = null
  const rn = Ft({}, [
    'annotation-xml',
    'audio',
    'colgroup',
    'desc',
    'foreignobject',
    'head',
    'iframe',
    'math',
    'mi',
    'mn',
    'mo',
    'ms',
    'mtext',
    'noembed',
    'noframes',
    'noscript',
    'plaintext',
    'script',
    'style',
    'svg',
    'template',
    'thead',
    'title',
    'video',
    'xmp'
  ])
  let fr = null
  const jr = Ft({}, ['audio', 'video', 'img', 'source', 'image', 'track'])
  let Cr = null
  const Se = Ft({}, [
      'alt',
      'class',
      'for',
      'id',
      'label',
      'name',
      'pattern',
      'placeholder',
      'role',
      'summary',
      'title',
      'value',
      'style',
      'xmlns'
    ]),
    $e = 'http://www.w3.org/1998/Math/MathML',
    pt = 'http://www.w3.org/2000/svg',
    St = 'http://www.w3.org/1999/xhtml'
  let _t = St,
    gn = !1,
    fn = null
  const nr = Ft({}, [$e, pt, St], mx)
  let Nt = null
  const rr = ['application/xhtml+xml', 'text/html'],
    Wt = 'text/html'
  let lt = null,
    Fn = null
  const wr = r.createElement('form'),
    Ni = function (V) {
      return V instanceof RegExp || V instanceof Function
    },
    ci = function () {
      let V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      if (!(Fn && Fn === V)) {
        if (
          ((!V || typeof V != 'object') && (V = {}),
          (V = yl(V)),
          (Nt = rr.indexOf(V.PARSER_MEDIA_TYPE) === -1 ? Wt : V.PARSER_MEDIA_TYPE),
          (lt = Nt === 'application/xhtml+xml' ? mx : Lv),
          (Me = ca(V, 'ALLOWED_TAGS') ? Ft({}, V.ALLOWED_TAGS, lt) : Ue),
          (pe = ca(V, 'ALLOWED_ATTR') ? Ft({}, V.ALLOWED_ATTR, lt) : xt),
          (fn = ca(V, 'ALLOWED_NAMESPACES') ? Ft({}, V.ALLOWED_NAMESPACES, mx) : nr),
          (Cr = ca(V, 'ADD_URI_SAFE_ATTR') ? Ft(yl(Se), V.ADD_URI_SAFE_ATTR, lt) : Se),
          (fr = ca(V, 'ADD_DATA_URI_TAGS') ? Ft(yl(jr), V.ADD_DATA_URI_TAGS, lt) : jr),
          (wn = ca(V, 'FORBID_CONTENTS') ? Ft({}, V.FORBID_CONTENTS, lt) : rn),
          (kt = ca(V, 'FORBID_TAGS') ? Ft({}, V.FORBID_TAGS, lt) : {}),
          (yt = ca(V, 'FORBID_ATTR') ? Ft({}, V.FORBID_ATTR, lt) : {}),
          (mn = ca(V, 'USE_PROFILES') ? V.USE_PROFILES : !1),
          (Et = V.ALLOW_ARIA_ATTR !== !1),
          (st = V.ALLOW_DATA_ATTR !== !1),
          (At = V.ALLOW_UNKNOWN_PROTOCOLS || !1),
          (en = V.ALLOW_SELF_CLOSE_IN_ATTR !== !1),
          (nn = V.SAFE_FOR_TEMPLATES || !1),
          (Re = V.SAFE_FOR_XML !== !1),
          (Oe = V.WHOLE_DOCUMENT || !1),
          (Vt = V.RETURN_DOM || !1),
          (Cn = V.RETURN_DOM_FRAGMENT || !1),
          (xn = V.RETURN_TRUSTED_TYPE || !1),
          (Dt = V.FORCE_BODY || !1),
          (Pn = V.SANITIZE_DOM !== !1),
          (tr = V.SANITIZE_NAMED_PROPS || !1),
          (In = V.KEEP_CONTENT !== !1),
          ($n = V.IN_PLACE || !1),
          (ot = V.ALLOWED_URI_REGEXP || lM),
          (_t = V.NAMESPACE || St),
          (Ye = V.CUSTOM_ELEMENT_HANDLING || {}),
          V.CUSTOM_ELEMENT_HANDLING &&
            Ni(V.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
            (Ye.tagNameCheck = V.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
          V.CUSTOM_ELEMENT_HANDLING &&
            Ni(V.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
            (Ye.attributeNameCheck = V.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
          V.CUSTOM_ELEMENT_HANDLING &&
            typeof V.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == 'boolean' &&
            (Ye.allowCustomizedBuiltInElements =
              V.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
          nn && (st = !1),
          Cn && (Vt = !0),
          mn &&
            ((Me = Ft({}, dk)),
            (pe = []),
            mn.html === !0 && (Ft(Me, fk), Ft(pe, hk)),
            mn.svg === !0 && (Ft(Me, vx), Ft(pe, bx), Ft(pe, Sv)),
            mn.svgFilters === !0 && (Ft(Me, gx), Ft(pe, bx), Ft(pe, Sv)),
            mn.mathMl === !0 && (Ft(Me, yx), Ft(pe, pk), Ft(pe, Sv))),
          V.ADD_TAGS && (Me === Ue && (Me = yl(Me)), Ft(Me, V.ADD_TAGS, lt)),
          V.ADD_ATTR && (pe === xt && (pe = yl(pe)), Ft(pe, V.ADD_ATTR, lt)),
          V.ADD_URI_SAFE_ATTR && Ft(Cr, V.ADD_URI_SAFE_ATTR, lt),
          V.FORBID_CONTENTS && (wn === rn && (wn = yl(wn)), Ft(wn, V.FORBID_CONTENTS, lt)),
          In && (Me['#text'] = !0),
          Oe && Ft(Me, ['html', 'head', 'body']),
          Me.table && (Ft(Me, ['tbody']), delete kt.tbody),
          V.TRUSTED_TYPES_POLICY)
        ) {
          if (typeof V.TRUSTED_TYPES_POLICY.createHTML != 'function')
            throw Vd('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.')
          if (typeof V.TRUSTED_TYPES_POLICY.createScriptURL != 'function')
            throw Vd('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.')
          ;(L = V.TRUSTED_TYPES_POLICY), (F = L.createHTML(''))
        } else
          L === void 0 && (L = ZG(x, o)), L !== null && typeof F == 'string' && (F = L.createHTML(''))
        Xr && Xr(V), (Fn = V)
      }
    },
    xa = Ft({}, ['mi', 'mo', 'mn', 'ms', 'mtext']),
    fi = Ft({}, ['foreignobject', 'annotation-xml']),
    Mi = Ft({}, ['title', 'style', 'font', 'a', 'script']),
    Jr = Ft({}, [...vx, ...gx, ...jG]),
    di = Ft({}, [...yx, ...UG]),
    ei = function (V) {
      let re = A(V)
      ;(!re || !re.tagName) && (re = { namespaceURI: _t, tagName: 'template' })
      const ye = Lv(V.tagName),
        qe = Lv(re.tagName)
      return fn[V.namespaceURI]
        ? V.namespaceURI === pt
          ? re.namespaceURI === St
            ? ye === 'svg'
            : re.namespaceURI === $e
              ? ye === 'svg' && (qe === 'annotation-xml' || xa[qe])
              : !!Jr[ye]
          : V.namespaceURI === $e
            ? re.namespaceURI === St
              ? ye === 'math'
              : re.namespaceURI === pt
                ? ye === 'math' && fi[qe]
                : !!di[ye]
            : V.namespaceURI === St
              ? (re.namespaceURI === pt && !fi[qe]) || (re.namespaceURI === $e && !xa[qe])
                ? !1
                : !di[ye] && (Mi[ye] || !Jr[ye])
              : !!(Nt === 'application/xhtml+xml' && fn[V.namespaceURI])
        : !1
    },
    Sn = function (V) {
      Id(t.removed, { element: V })
      try {
        A(V).removeChild(V)
      } catch {
        k(V)
      }
    },
    ir = function (V, re) {
      try {
        Id(t.removed, { attribute: re.getAttributeNode(V), from: re })
      } catch {
        Id(t.removed, { attribute: null, from: re })
      }
      if ((re.removeAttribute(V), V === 'is' && !pe[V]))
        if (Vt || Cn)
          try {
            Sn(re)
          } catch {}
        else
          try {
            re.setAttribute(V, '')
          } catch {}
    },
    P = function (V) {
      let re = null,
        ye = null
      if (Dt) V = '<remove></remove>' + V
      else {
        const Qt = ck(V, /^[\r\n\t ]+/)
        ye = Qt && Qt[0]
      }
      Nt === 'application/xhtml+xml' &&
        _t === St &&
        (V = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + V + '</body></html>')
      const qe = L ? L.createHTML(V) : V
      if (_t === St)
        try {
          re = new E().parseFromString(qe, Nt)
        } catch {}
      if (!re || !re.documentElement) {
        re = z.createDocument(_t, 'template', null)
        try {
          re.documentElement.innerHTML = gn ? F : qe
        } catch {}
      }
      const tn = re.body || re.documentElement
      return (
        V && ye && tn.insertBefore(r.createTextNode(ye), tn.childNodes[0] || null),
        _t === St ? Q.call(re, Oe ? 'html' : 'body')[0] : Oe ? re.documentElement : tn
      )
    },
    ce = function (V) {
      return H.call(
        V.ownerDocument || V,
        V,
        p.SHOW_ELEMENT |
          p.SHOW_COMMENT |
          p.SHOW_TEXT |
          p.SHOW_PROCESSING_INSTRUCTION |
          p.SHOW_CDATA_SECTION,
        null
      )
    },
    Te = function (V) {
      return (
        V instanceof g &&
        (typeof V.nodeName != 'string' ||
          typeof V.textContent != 'string' ||
          typeof V.removeChild != 'function' ||
          !(V.attributes instanceof v) ||
          typeof V.removeAttribute != 'function' ||
          typeof V.setAttribute != 'function' ||
          typeof V.namespaceURI != 'string' ||
          typeof V.insertBefore != 'function' ||
          typeof V.hasChildNodes != 'function')
      )
    },
    M = function (V) {
      return typeof d == 'function' && V instanceof d
    },
    X = function (V, re, ye) {
      se[V] &&
        xv(se[V], qe => {
          qe.call(t, re, ye, Fn)
        })
    },
    ne = function (V) {
      let re = null
      if ((X('beforeSanitizeElements', V, null), Te(V))) return Sn(V), !0
      const ye = lt(V.nodeName)
      if (
        (X('uponSanitizeElement', V, { tagName: ye, allowedTags: Me }),
        (V.hasChildNodes() &&
          !M(V.firstElementChild) &&
          qr(/<[/\w]/g, V.innerHTML) &&
          qr(/<[/\w]/g, V.textContent)) ||
          V.nodeType === Ud.progressingInstruction ||
          (Re && V.nodeType === Ud.comment && qr(/<[/\w]/g, V.data)))
      )
        return Sn(V), !0
      if (!Me[ye] || kt[ye]) {
        if (
          !kt[ye] &&
          _e(ye) &&
          ((Ye.tagNameCheck instanceof RegExp && qr(Ye.tagNameCheck, ye)) ||
            (Ye.tagNameCheck instanceof Function && Ye.tagNameCheck(ye)))
        )
          return !1
        if (In && !wn[ye]) {
          const qe = A(V) || V.parentNode,
            tn = D(V) || V.childNodes
          if (tn && qe) {
            const Qt = tn.length
            for (let $t = Qt - 1; $t >= 0; --$t) {
              const Tn = _(tn[$t], !0)
              ;(Tn.__removalCount = (V.__removalCount || 0) + 1), qe.insertBefore(Tn, R(V))
            }
          }
        }
        return Sn(V), !0
      }
      return (V instanceof h && !ei(V)) ||
        ((ye === 'noscript' || ye === 'noembed' || ye === 'noframes') &&
          qr(/<\/no(script|embed|frames)/i, V.innerHTML))
        ? (Sn(V), !0)
        : (nn &&
            V.nodeType === Ud.text &&
            ((re = V.textContent),
            xv([we, he, G], qe => {
              re = Fd(re, qe, ' ')
            }),
            V.textContent !== re && (Id(t.removed, { element: V.cloneNode() }), (V.textContent = re))),
          X('afterSanitizeElements', V, null),
          !1)
    },
    Ee = function (V, re, ye) {
      if (Pn && (re === 'id' || re === 'name') && (ye in r || ye in wr)) return !1
      if (!(st && !yt[re] && qr(ge, re))) {
        if (!(Et && qr(De, re))) {
          if (!pe[re] || yt[re]) {
            if (
              !(
                (_e(V) &&
                  ((Ye.tagNameCheck instanceof RegExp && qr(Ye.tagNameCheck, V)) ||
                    (Ye.tagNameCheck instanceof Function && Ye.tagNameCheck(V))) &&
                  ((Ye.attributeNameCheck instanceof RegExp && qr(Ye.attributeNameCheck, re)) ||
                    (Ye.attributeNameCheck instanceof Function && Ye.attributeNameCheck(re)))) ||
                (re === 'is' &&
                  Ye.allowCustomizedBuiltInElements &&
                  ((Ye.tagNameCheck instanceof RegExp && qr(Ye.tagNameCheck, ye)) ||
                    (Ye.tagNameCheck instanceof Function && Ye.tagNameCheck(ye))))
              )
            )
              return !1
          } else if (!Cr[re]) {
            if (!qr(ot, Fd(ye, ve, ''))) {
              if (
                !(
                  (re === 'src' || re === 'xlink:href' || re === 'href') &&
                  V !== 'script' &&
                  PG(ye, 'data:') === 0 &&
                  fr[V]
                )
              ) {
                if (!(At && !qr(de, Fd(ye, ve, '')))) {
                  if (ye) return !1
                }
              }
            }
          }
        }
      }
      return !0
    },
    _e = function (V) {
      return V !== 'annotation-xml' && ck(V, Ke)
    },
    Qe = function (V) {
      X('beforeSanitizeAttributes', V, null)
      const { attributes: re } = V
      if (!re) return
      const ye = { attrName: '', attrValue: '', keepAttr: !0, allowedAttributes: pe }
      let qe = re.length
      for (; qe--; ) {
        const tn = re[qe],
          { name: Qt, namespaceURI: $t, value: Tn } = tn,
          vt = lt(Qt)
        let yn = Qt === 'value' ? Tn : IG(Tn)
        if (
          ((ye.attrName = vt),
          (ye.attrValue = yn),
          (ye.keepAttr = !0),
          (ye.forceKeepAttr = void 0),
          X('uponSanitizeAttribute', V, ye),
          (yn = ye.attrValue),
          Re && qr(/((--!?|])>)|<\/(style|title)/i, yn))
        ) {
          ir(Qt, V)
          continue
        }
        if (ye.forceKeepAttr || (ir(Qt, V), !ye.keepAttr)) continue
        if (!en && qr(/\/>/i, yn)) {
          ir(Qt, V)
          continue
        }
        nn &&
          xv([we, he, G], Mo => {
            yn = Fd(yn, Mo, ' ')
          })
        const Gi = lt(V.nodeName)
        if (Ee(Gi, vt, yn)) {
          if (
            (tr && (vt === 'id' || vt === 'name') && (ir(Qt, V), (yn = Un + yn)),
            L && typeof x == 'object' && typeof x.getAttributeType == 'function' && !$t)
          )
            switch (x.getAttributeType(Gi, vt)) {
              case 'TrustedHTML': {
                yn = L.createHTML(yn)
                break
              }
              case 'TrustedScriptURL': {
                yn = L.createScriptURL(yn)
                break
              }
            }
          try {
            $t ? V.setAttributeNS($t, Qt, yn) : V.setAttribute(Qt, yn), Te(V) ? Sn(V) : uk(t.removed)
          } catch {}
        }
      }
      X('afterSanitizeAttributes', V, null)
    },
    ke = function ae(V) {
      let re = null
      const ye = ce(V)
      for (X('beforeSanitizeShadowDOM', V, null); (re = ye.nextNode()); )
        X('uponSanitizeShadowNode', re, null),
          !ne(re) && (re.content instanceof u && ae(re.content), Qe(re))
      X('afterSanitizeShadowDOM', V, null)
    }
  return (
    (t.sanitize = function (ae) {
      let V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        re = null,
        ye = null,
        qe = null,
        tn = null
      if (((gn = !ae), gn && (ae = '<!-->'), typeof ae != 'string' && !M(ae)))
        if (typeof ae.toString == 'function') {
          if (((ae = ae.toString()), typeof ae != 'string')) throw Vd('dirty is not a string, aborting')
        } else throw Vd('toString is not a function')
      if (!t.isSupported) return ae
      if ((Xe || ci(V), (t.removed = []), typeof ae == 'string' && ($n = !1), $n)) {
        if (ae.nodeName) {
          const Tn = lt(ae.nodeName)
          if (!Me[Tn] || kt[Tn]) throw Vd('root node is forbidden and cannot be sanitized in-place')
        }
      } else if (ae instanceof d)
        (re = P('<!---->')),
          (ye = re.ownerDocument.importNode(ae, !0)),
          (ye.nodeType === Ud.element && ye.nodeName === 'BODY') || ye.nodeName === 'HTML'
            ? (re = ye)
            : re.appendChild(ye)
      else {
        if (!Vt && !nn && !Oe && ae.indexOf('<') === -1) return L && xn ? L.createHTML(ae) : ae
        if (((re = P(ae)), !re)) return Vt ? null : xn ? F : ''
      }
      re && Dt && Sn(re.firstChild)
      const Qt = ce($n ? ae : re)
      for (; (qe = Qt.nextNode()); ) ne(qe) || (qe.content instanceof u && ke(qe.content), Qe(qe))
      if ($n) return ae
      if (Vt) {
        if (Cn) for (tn = $.call(re.ownerDocument); re.firstChild; ) tn.appendChild(re.firstChild)
        else tn = re
        return (pe.shadowroot || pe.shadowrootmode) && (tn = ue.call(a, tn, !0)), tn
      }
      let $t = Oe ? re.outerHTML : re.innerHTML
      return (
        Oe &&
          Me['!doctype'] &&
          re.ownerDocument &&
          re.ownerDocument.doctype &&
          re.ownerDocument.doctype.name &&
          qr(uM, re.ownerDocument.doctype.name) &&
          ($t =
            '<!DOCTYPE ' +
            re.ownerDocument.doctype.name +
            `>
` +
            $t),
        nn &&
          xv([we, he, G], Tn => {
            $t = Fd($t, Tn, ' ')
          }),
        L && xn ? L.createHTML($t) : $t
      )
    }),
    (t.setConfig = function () {
      let ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      ci(ae), (Xe = !0)
    }),
    (t.clearConfig = function () {
      ;(Fn = null), (Xe = !1)
    }),
    (t.isValidAttribute = function (ae, V, re) {
      Fn || ci({})
      const ye = lt(ae),
        qe = lt(V)
      return Ee(ye, qe, re)
    }),
    (t.addHook = function (ae, V) {
      typeof V == 'function' && ((se[ae] = se[ae] || []), Id(se[ae], V))
    }),
    (t.removeHook = function (ae) {
      if (se[ae]) return uk(se[ae])
    }),
    (t.removeHooks = function (ae) {
      se[ae] && (se[ae] = [])
    }),
    (t.removeAllHooks = function () {
      se = {}
    }),
    t
  )
}
var vk = cM(),
  Kt
;(function (e) {
  e.assertEqual = o => o
  function t(o) {}
  e.assertIs = t
  function r(o) {
    throw new Error()
  }
  ;(e.assertNever = r),
    (e.arrayToEnum = o => {
      const u = {}
      for (const l of o) u[l] = l
      return u
    }),
    (e.getValidEnumValues = o => {
      const u = e.objectKeys(o).filter(d => typeof o[o[d]] != 'number'),
        l = {}
      for (const d of u) l[d] = o[d]
      return e.objectValues(l)
    }),
    (e.objectValues = o =>
      e.objectKeys(o).map(function (u) {
        return o[u]
      })),
    (e.objectKeys =
      typeof Object.keys == 'function'
        ? o => Object.keys(o)
        : o => {
            const u = []
            for (const l in o) Object.prototype.hasOwnProperty.call(o, l) && u.push(l)
            return u
          }),
    (e.find = (o, u) => {
      for (const l of o) if (u(l)) return l
    }),
    (e.isInteger =
      typeof Number.isInteger == 'function'
        ? o => Number.isInteger(o)
        : o => typeof o == 'number' && isFinite(o) && Math.floor(o) === o)
  function a(o, u = ' | ') {
    return o.map(l => (typeof l == 'string' ? `'${l}'` : l)).join(u)
  }
  ;(e.joinValues = a), (e.jsonStringifyReplacer = (o, u) => (typeof u == 'bigint' ? u.toString() : u))
})(Kt || (Kt = {}))
var gS
;(function (e) {
  e.mergeShapes = (t, r) => ({ ...t, ...r })
})(gS || (gS = {}))
const Ve = Kt.arrayToEnum([
    'string',
    'nan',
    'number',
    'integer',
    'float',
    'boolean',
    'date',
    'bigint',
    'symbol',
    'function',
    'undefined',
    'null',
    'array',
    'object',
    'unknown',
    'promise',
    'void',
    'never',
    'map',
    'set'
  ]),
  ds = e => {
    switch (typeof e) {
      case 'undefined':
        return Ve.undefined
      case 'string':
        return Ve.string
      case 'number':
        return isNaN(e) ? Ve.nan : Ve.number
      case 'boolean':
        return Ve.boolean
      case 'function':
        return Ve.function
      case 'bigint':
        return Ve.bigint
      case 'symbol':
        return Ve.symbol
      case 'object':
        return Array.isArray(e)
          ? Ve.array
          : e === null
            ? Ve.null
            : e.then && typeof e.then == 'function' && e.catch && typeof e.catch == 'function'
              ? Ve.promise
              : typeof Map < 'u' && e instanceof Map
                ? Ve.map
                : typeof Set < 'u' && e instanceof Set
                  ? Ve.set
                  : typeof Date < 'u' && e instanceof Date
                    ? Ve.date
                    : Ve.object
      default:
        return Ve.unknown
    }
  },
  be = Kt.arrayToEnum([
    'invalid_type',
    'invalid_literal',
    'custom',
    'invalid_union',
    'invalid_union_discriminator',
    'invalid_enum_value',
    'unrecognized_keys',
    'invalid_arguments',
    'invalid_return_type',
    'invalid_date',
    'invalid_string',
    'too_small',
    'too_big',
    'invalid_intersection_types',
    'not_multiple_of',
    'not_finite'
  ]),
  XG = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, '$1:')
class Oi extends Error {
  constructor(t) {
    super(),
      (this.issues = []),
      (this.addIssue = a => {
        this.issues = [...this.issues, a]
      }),
      (this.addIssues = (a = []) => {
        this.issues = [...this.issues, ...a]
      })
    const r = new.target.prototype
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : (this.__proto__ = r),
      (this.name = 'ZodError'),
      (this.issues = t)
  }
  get errors() {
    return this.issues
  }
  format(t) {
    const r =
        t ||
        function (u) {
          return u.message
        },
      a = { _errors: [] },
      o = u => {
        for (const l of u.issues)
          if (l.code === 'invalid_union') l.unionErrors.map(o)
          else if (l.code === 'invalid_return_type') o(l.returnTypeError)
          else if (l.code === 'invalid_arguments') o(l.argumentsError)
          else if (l.path.length === 0) a._errors.push(r(l))
          else {
            let d = a,
              h = 0
            for (; h < l.path.length; ) {
              const p = l.path[h]
              h === l.path.length - 1
                ? ((d[p] = d[p] || { _errors: [] }), d[p]._errors.push(r(l)))
                : (d[p] = d[p] || { _errors: [] }),
                (d = d[p]),
                h++
            }
          }
      }
    return o(this), a
  }
  static assert(t) {
    if (!(t instanceof Oi)) throw new Error(`Not a ZodError: ${t}`)
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, Kt.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(t = r => r.message) {
    const r = {},
      a = []
    for (const o of this.issues)
      o.path.length > 0 ? ((r[o.path[0]] = r[o.path[0]] || []), r[o.path[0]].push(t(o))) : a.push(t(o))
    return { formErrors: a, fieldErrors: r }
  }
  get formErrors() {
    return this.flatten()
  }
}
Oi.create = e => new Oi(e)
const Ac = (e, t) => {
  let r
  switch (e.code) {
    case be.invalid_type:
      e.received === Ve.undefined
        ? (r = 'Required')
        : (r = `Expected ${e.expected}, received ${e.received}`)
      break
    case be.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Kt.jsonStringifyReplacer)}`
      break
    case be.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Kt.joinValues(e.keys, ', ')}`
      break
    case be.invalid_union:
      r = 'Invalid input'
      break
    case be.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Kt.joinValues(e.options)}`
      break
    case be.invalid_enum_value:
      r = `Invalid enum value. Expected ${Kt.joinValues(e.options)}, received '${e.received}'`
      break
    case be.invalid_arguments:
      r = 'Invalid function arguments'
      break
    case be.invalid_return_type:
      r = 'Invalid function return type'
      break
    case be.invalid_date:
      r = 'Invalid date'
      break
    case be.invalid_string:
      typeof e.validation == 'object'
        ? 'includes' in e.validation
          ? ((r = `Invalid input: must include "${e.validation.includes}"`),
            typeof e.validation.position == 'number' &&
              (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
          : 'startsWith' in e.validation
            ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
            : 'endsWith' in e.validation
              ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
              : Kt.assertNever(e.validation)
        : e.validation !== 'regex'
          ? (r = `Invalid ${e.validation}`)
          : (r = 'Invalid')
      break
    case be.too_small:
      e.type === 'array'
        ? (r = `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'more than'} ${e.minimum} element(s)`)
        : e.type === 'string'
          ? (r = `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at least' : 'over'} ${e.minimum} character(s)`)
          : e.type === 'number'
            ? (r = `Number must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${e.minimum}`)
            : e.type === 'date'
              ? (r = `Date must be ${e.exact ? 'exactly equal to ' : e.inclusive ? 'greater than or equal to ' : 'greater than '}${new Date(Number(e.minimum))}`)
              : (r = 'Invalid input')
      break
    case be.too_big:
      e.type === 'array'
        ? (r = `Array must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'less than'} ${e.maximum} element(s)`)
        : e.type === 'string'
          ? (r = `String must contain ${e.exact ? 'exactly' : e.inclusive ? 'at most' : 'under'} ${e.maximum} character(s)`)
          : e.type === 'number'
            ? (r = `Number must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`)
            : e.type === 'bigint'
              ? (r = `BigInt must be ${e.exact ? 'exactly' : e.inclusive ? 'less than or equal to' : 'less than'} ${e.maximum}`)
              : e.type === 'date'
                ? (r = `Date must be ${e.exact ? 'exactly' : e.inclusive ? 'smaller than or equal to' : 'smaller than'} ${new Date(Number(e.maximum))}`)
                : (r = 'Invalid input')
      break
    case be.custom:
      r = 'Invalid input'
      break
    case be.invalid_intersection_types:
      r = 'Intersection results could not be merged'
      break
    case be.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`
      break
    case be.not_finite:
      r = 'Number must be finite'
      break
    default:
      ;(r = t.defaultError), Kt.assertNever(e)
  }
  return { message: r }
}
let fM = Ac
function QG(e) {
  fM = e
}
function Jv() {
  return fM
}
const eg = e => {
    const { data: t, path: r, errorMaps: a, issueData: o } = e,
      u = [...r, ...(o.path || [])],
      l = { ...o, path: u }
    if (o.message !== void 0) return { ...o, path: u, message: o.message }
    let d = ''
    const h = a
      .filter(p => !!p)
      .slice()
      .reverse()
    for (const p of h) d = p(l, { data: t, defaultError: d }).message
    return { ...o, path: u, message: d }
  },
  JG = []
function Ie(e, t) {
  const r = Jv(),
    a = eg({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, r, r === Ac ? void 0 : Ac].filter(
        o => !!o
      )
    })
  e.common.issues.push(a)
}
class Vr {
  constructor() {
    this.value = 'valid'
  }
  dirty() {
    this.value === 'valid' && (this.value = 'dirty')
  }
  abort() {
    this.value !== 'aborted' && (this.value = 'aborted')
  }
  static mergeArray(t, r) {
    const a = []
    for (const o of r) {
      if (o.status === 'aborted') return ht
      o.status === 'dirty' && t.dirty(), a.push(o.value)
    }
    return { status: t.value, value: a }
  }
  static async mergeObjectAsync(t, r) {
    const a = []
    for (const o of r) {
      const u = await o.key,
        l = await o.value
      a.push({ key: u, value: l })
    }
    return Vr.mergeObjectSync(t, a)
  }
  static mergeObjectSync(t, r) {
    const a = {}
    for (const o of r) {
      const { key: u, value: l } = o
      if (u.status === 'aborted' || l.status === 'aborted') return ht
      u.status === 'dirty' && t.dirty(),
        l.status === 'dirty' && t.dirty(),
        u.value !== '__proto__' && (typeof l.value < 'u' || o.alwaysSet) && (a[u.value] = l.value)
    }
    return { status: t.value, value: a }
  }
}
const ht = Object.freeze({ status: 'aborted' }),
  rc = e => ({ status: 'dirty', value: e }),
  Qr = e => ({ status: 'valid', value: e }),
  yS = e => e.status === 'aborted',
  bS = e => e.status === 'dirty',
  vh = e => e.status === 'valid',
  gh = e => typeof Promise < 'u' && e instanceof Promise
function tg(e, t, r, a) {
  if (typeof t == 'function' ? e !== t || !a : !t.has(e))
    throw new TypeError('Cannot read private member from an object whose class did not declare it')
  return t.get(e)
}
function dM(e, t, r, a, o) {
  if (typeof t == 'function' ? e !== t || !o : !t.has(e))
    throw new TypeError('Cannot write private member to an object whose class did not declare it')
  return t.set(e, r), r
}
var Ge
;(function (e) {
  ;(e.errToObj = t => (typeof t == 'string' ? { message: t } : t || {})),
    (e.toString = t => (typeof t == 'string' ? t : t == null ? void 0 : t.message))
})(Ge || (Ge = {}))
var Wd, Yd
class Ya {
  constructor(t, r, a, o) {
    ;(this._cachedPath = []), (this.parent = t), (this.data = r), (this._path = a), (this._key = o)
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    )
  }
}
const gk = (e, t) => {
  if (vh(t)) return { success: !0, data: t.value }
  if (!e.common.issues.length) throw new Error('Validation failed but no issues detected.')
  return {
    success: !1,
    get error() {
      if (this._error) return this._error
      const r = new Oi(e.common.issues)
      return (this._error = r), this._error
    }
  }
}
function wt(e) {
  if (!e) return {}
  const { errorMap: t, invalid_type_error: r, required_error: a, description: o } = e
  if (t && (r || a))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    )
  return t
    ? { errorMap: t, description: o }
    : {
        errorMap: (l, d) => {
          var h, p
          const { message: v } = e
          return l.code === 'invalid_enum_value'
            ? { message: v ?? d.defaultError }
            : typeof d.data > 'u'
              ? { message: (h = v ?? a) !== null && h !== void 0 ? h : d.defaultError }
              : l.code !== 'invalid_type'
                ? { message: d.defaultError }
                : { message: (p = v ?? r) !== null && p !== void 0 ? p : d.defaultError }
        },
        description: o
      }
}
class Rt {
  constructor(t) {
    ;(this.spa = this.safeParseAsync),
      (this._def = t),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this))
  }
  get description() {
    return this._def.description
  }
  _getType(t) {
    return ds(t.data)
  }
  _getOrReturnCtx(t, r) {
    return (
      r || {
        common: t.parent.common,
        data: t.data,
        parsedType: ds(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    )
  }
  _processInputParams(t) {
    return {
      status: new Vr(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ds(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    }
  }
  _parseSync(t) {
    const r = this._parse(t)
    if (gh(r)) throw new Error('Synchronous parse encountered promise.')
    return r
  }
  _parseAsync(t) {
    const r = this._parse(t)
    return Promise.resolve(r)
  }
  parse(t, r) {
    const a = this.safeParse(t, r)
    if (a.success) return a.data
    throw a.error
  }
  safeParse(t, r) {
    var a
    const o = {
        common: {
          issues: [],
          async: (a = r == null ? void 0 : r.async) !== null && a !== void 0 ? a : !1,
          contextualErrorMap: r == null ? void 0 : r.errorMap
        },
        path: (r == null ? void 0 : r.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: ds(t)
      },
      u = this._parseSync({ data: t, path: o.path, parent: o })
    return gk(o, u)
  }
  async parseAsync(t, r) {
    const a = await this.safeParseAsync(t, r)
    if (a.success) return a.data
    throw a.error
  }
  async safeParseAsync(t, r) {
    const a = {
        common: { issues: [], contextualErrorMap: r == null ? void 0 : r.errorMap, async: !0 },
        path: (r == null ? void 0 : r.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: ds(t)
      },
      o = this._parse({ data: t, path: a.path, parent: a }),
      u = await (gh(o) ? o : Promise.resolve(o))
    return gk(a, u)
  }
  refine(t, r) {
    const a = o =>
      typeof r == 'string' || typeof r > 'u' ? { message: r } : typeof r == 'function' ? r(o) : r
    return this._refinement((o, u) => {
      const l = t(o),
        d = () => u.addIssue({ code: be.custom, ...a(o) })
      return typeof Promise < 'u' && l instanceof Promise
        ? l.then(h => (h ? !0 : (d(), !1)))
        : l
          ? !0
          : (d(), !1)
    })
  }
  refinement(t, r) {
    return this._refinement((a, o) =>
      t(a) ? !0 : (o.addIssue(typeof r == 'function' ? r(a, o) : r), !1)
    )
  }
  _refinement(t) {
    return new ya({
      schema: this,
      typeName: at.ZodEffects,
      effect: { type: 'refinement', refinement: t }
    })
  }
  superRefine(t) {
    return this._refinement(t)
  }
  optional() {
    return za.create(this, this._def)
  }
  nullable() {
    return Ds.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return va.create(this, this._def)
  }
  promise() {
    return Nc.create(this, this._def)
  }
  or(t) {
    return xh.create([this, t], this._def)
  }
  and(t) {
    return Sh.create(this, t, this._def)
  }
  transform(t) {
    return new ya({
      ...wt(this._def),
      schema: this,
      typeName: at.ZodEffects,
      effect: { type: 'transform', transform: t }
    })
  }
  default(t) {
    const r = typeof t == 'function' ? t : () => t
    return new _h({ ...wt(this._def), innerType: this, defaultValue: r, typeName: at.ZodDefault })
  }
  brand() {
    return new S1({ typeName: at.ZodBranded, type: this, ...wt(this._def) })
  }
  catch(t) {
    const r = typeof t == 'function' ? t : () => t
    return new Oh({ ...wt(this._def), innerType: this, catchValue: r, typeName: at.ZodCatch })
  }
  describe(t) {
    const r = this.constructor
    return new r({ ...this._def, description: t })
  }
  pipe(t) {
    return Gh.create(this, t)
  }
  readonly() {
    return kh.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const eK = /^c[^\s-]{8,}$/i,
  tK = /^[0-9a-z]+$/,
  nK = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  rK = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  iK = /^[a-z0-9_-]{21}$/i,
  aK =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  oK = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  sK = '^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$'
let Ex
const lK =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  uK =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  cK = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  hM =
    '((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))',
  fK = new RegExp(`^${hM}$`)
function pM(e) {
  let t = '([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d'
  return (
    e.precision ? (t = `${t}\\.\\d{${e.precision}}`) : e.precision == null && (t = `${t}(\\.\\d+)?`), t
  )
}
function dK(e) {
  return new RegExp(`^${pM(e)}$`)
}
function mM(e) {
  let t = `${hM}T${pM(e)}`
  const r = []
  return (
    r.push(e.local ? 'Z?' : 'Z'),
    e.offset && r.push('([+-]\\d{2}:?\\d{2})'),
    (t = `${t}(${r.join('|')})`),
    new RegExp(`^${t}$`)
  )
}
function hK(e, t) {
  return !!(((t === 'v4' || !t) && lK.test(e)) || ((t === 'v6' || !t) && uK.test(e)))
}
class ma extends Rt {
  _parse(t) {
    if ((this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ve.string)) {
      const u = this._getOrReturnCtx(t)
      return Ie(u, { code: be.invalid_type, expected: Ve.string, received: u.parsedType }), ht
    }
    const a = new Vr()
    let o
    for (const u of this._def.checks)
      if (u.kind === 'min')
        t.data.length < u.value &&
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, {
            code: be.too_small,
            minimum: u.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: u.message
          }),
          a.dirty())
      else if (u.kind === 'max')
        t.data.length > u.value &&
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, {
            code: be.too_big,
            maximum: u.value,
            type: 'string',
            inclusive: !0,
            exact: !1,
            message: u.message
          }),
          a.dirty())
      else if (u.kind === 'length') {
        const l = t.data.length > u.value,
          d = t.data.length < u.value
        ;(l || d) &&
          ((o = this._getOrReturnCtx(t, o)),
          l
            ? Ie(o, {
                code: be.too_big,
                maximum: u.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: u.message
              })
            : d &&
              Ie(o, {
                code: be.too_small,
                minimum: u.value,
                type: 'string',
                inclusive: !0,
                exact: !0,
                message: u.message
              }),
          a.dirty())
      } else if (u.kind === 'email')
        oK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'email', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'emoji')
        Ex || (Ex = new RegExp(sK, 'u')),
          Ex.test(t.data) ||
            ((o = this._getOrReturnCtx(t, o)),
            Ie(o, { validation: 'emoji', code: be.invalid_string, message: u.message }),
            a.dirty())
      else if (u.kind === 'uuid')
        rK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'uuid', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'nanoid')
        iK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'nanoid', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'cuid')
        eK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'cuid', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'cuid2')
        tK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'cuid2', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'ulid')
        nK.test(t.data) ||
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, { validation: 'ulid', code: be.invalid_string, message: u.message }),
          a.dirty())
      else if (u.kind === 'url')
        try {
          new URL(t.data)
        } catch {
          ;(o = this._getOrReturnCtx(t, o)),
            Ie(o, { validation: 'url', code: be.invalid_string, message: u.message }),
            a.dirty()
        }
      else
        u.kind === 'regex'
          ? ((u.regex.lastIndex = 0),
            u.regex.test(t.data) ||
              ((o = this._getOrReturnCtx(t, o)),
              Ie(o, { validation: 'regex', code: be.invalid_string, message: u.message }),
              a.dirty()))
          : u.kind === 'trim'
            ? (t.data = t.data.trim())
            : u.kind === 'includes'
              ? t.data.includes(u.value, u.position) ||
                ((o = this._getOrReturnCtx(t, o)),
                Ie(o, {
                  code: be.invalid_string,
                  validation: { includes: u.value, position: u.position },
                  message: u.message
                }),
                a.dirty())
              : u.kind === 'toLowerCase'
                ? (t.data = t.data.toLowerCase())
                : u.kind === 'toUpperCase'
                  ? (t.data = t.data.toUpperCase())
                  : u.kind === 'startsWith'
                    ? t.data.startsWith(u.value) ||
                      ((o = this._getOrReturnCtx(t, o)),
                      Ie(o, {
                        code: be.invalid_string,
                        validation: { startsWith: u.value },
                        message: u.message
                      }),
                      a.dirty())
                    : u.kind === 'endsWith'
                      ? t.data.endsWith(u.value) ||
                        ((o = this._getOrReturnCtx(t, o)),
                        Ie(o, {
                          code: be.invalid_string,
                          validation: { endsWith: u.value },
                          message: u.message
                        }),
                        a.dirty())
                      : u.kind === 'datetime'
                        ? mM(u).test(t.data) ||
                          ((o = this._getOrReturnCtx(t, o)),
                          Ie(o, { code: be.invalid_string, validation: 'datetime', message: u.message }),
                          a.dirty())
                        : u.kind === 'date'
                          ? fK.test(t.data) ||
                            ((o = this._getOrReturnCtx(t, o)),
                            Ie(o, { code: be.invalid_string, validation: 'date', message: u.message }),
                            a.dirty())
                          : u.kind === 'time'
                            ? dK(u).test(t.data) ||
                              ((o = this._getOrReturnCtx(t, o)),
                              Ie(o, { code: be.invalid_string, validation: 'time', message: u.message }),
                              a.dirty())
                            : u.kind === 'duration'
                              ? aK.test(t.data) ||
                                ((o = this._getOrReturnCtx(t, o)),
                                Ie(o, {
                                  validation: 'duration',
                                  code: be.invalid_string,
                                  message: u.message
                                }),
                                a.dirty())
                              : u.kind === 'ip'
                                ? hK(t.data, u.version) ||
                                  ((o = this._getOrReturnCtx(t, o)),
                                  Ie(o, {
                                    validation: 'ip',
                                    code: be.invalid_string,
                                    message: u.message
                                  }),
                                  a.dirty())
                                : u.kind === 'base64'
                                  ? cK.test(t.data) ||
                                    ((o = this._getOrReturnCtx(t, o)),
                                    Ie(o, {
                                      validation: 'base64',
                                      code: be.invalid_string,
                                      message: u.message
                                    }),
                                    a.dirty())
                                  : Kt.assertNever(u)
    return { status: a.value, value: t.data }
  }
  _regex(t, r, a) {
    return this.refinement(o => t.test(o), { validation: r, code: be.invalid_string, ...Ge.errToObj(a) })
  }
  _addCheck(t) {
    return new ma({ ...this._def, checks: [...this._def.checks, t] })
  }
  email(t) {
    return this._addCheck({ kind: 'email', ...Ge.errToObj(t) })
  }
  url(t) {
    return this._addCheck({ kind: 'url', ...Ge.errToObj(t) })
  }
  emoji(t) {
    return this._addCheck({ kind: 'emoji', ...Ge.errToObj(t) })
  }
  uuid(t) {
    return this._addCheck({ kind: 'uuid', ...Ge.errToObj(t) })
  }
  nanoid(t) {
    return this._addCheck({ kind: 'nanoid', ...Ge.errToObj(t) })
  }
  cuid(t) {
    return this._addCheck({ kind: 'cuid', ...Ge.errToObj(t) })
  }
  cuid2(t) {
    return this._addCheck({ kind: 'cuid2', ...Ge.errToObj(t) })
  }
  ulid(t) {
    return this._addCheck({ kind: 'ulid', ...Ge.errToObj(t) })
  }
  base64(t) {
    return this._addCheck({ kind: 'base64', ...Ge.errToObj(t) })
  }
  ip(t) {
    return this._addCheck({ kind: 'ip', ...Ge.errToObj(t) })
  }
  datetime(t) {
    var r, a
    return typeof t == 'string'
      ? this._addCheck({ kind: 'datetime', precision: null, offset: !1, local: !1, message: t })
      : this._addCheck({
          kind: 'datetime',
          precision:
            typeof (t == null ? void 0 : t.precision) > 'u' ? null : t == null ? void 0 : t.precision,
          offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
          local: (a = t == null ? void 0 : t.local) !== null && a !== void 0 ? a : !1,
          ...Ge.errToObj(t == null ? void 0 : t.message)
        })
  }
  date(t) {
    return this._addCheck({ kind: 'date', message: t })
  }
  time(t) {
    return typeof t == 'string'
      ? this._addCheck({ kind: 'time', precision: null, message: t })
      : this._addCheck({
          kind: 'time',
          precision:
            typeof (t == null ? void 0 : t.precision) > 'u' ? null : t == null ? void 0 : t.precision,
          ...Ge.errToObj(t == null ? void 0 : t.message)
        })
  }
  duration(t) {
    return this._addCheck({ kind: 'duration', ...Ge.errToObj(t) })
  }
  regex(t, r) {
    return this._addCheck({ kind: 'regex', regex: t, ...Ge.errToObj(r) })
  }
  includes(t, r) {
    return this._addCheck({
      kind: 'includes',
      value: t,
      position: r == null ? void 0 : r.position,
      ...Ge.errToObj(r == null ? void 0 : r.message)
    })
  }
  startsWith(t, r) {
    return this._addCheck({ kind: 'startsWith', value: t, ...Ge.errToObj(r) })
  }
  endsWith(t, r) {
    return this._addCheck({ kind: 'endsWith', value: t, ...Ge.errToObj(r) })
  }
  min(t, r) {
    return this._addCheck({ kind: 'min', value: t, ...Ge.errToObj(r) })
  }
  max(t, r) {
    return this._addCheck({ kind: 'max', value: t, ...Ge.errToObj(r) })
  }
  length(t, r) {
    return this._addCheck({ kind: 'length', value: t, ...Ge.errToObj(r) })
  }
  nonempty(t) {
    return this.min(1, Ge.errToObj(t))
  }
  trim() {
    return new ma({ ...this._def, checks: [...this._def.checks, { kind: 'trim' }] })
  }
  toLowerCase() {
    return new ma({ ...this._def, checks: [...this._def.checks, { kind: 'toLowerCase' }] })
  }
  toUpperCase() {
    return new ma({ ...this._def, checks: [...this._def.checks, { kind: 'toUpperCase' }] })
  }
  get isDatetime() {
    return !!this._def.checks.find(t => t.kind === 'datetime')
  }
  get isDate() {
    return !!this._def.checks.find(t => t.kind === 'date')
  }
  get isTime() {
    return !!this._def.checks.find(t => t.kind === 'time')
  }
  get isDuration() {
    return !!this._def.checks.find(t => t.kind === 'duration')
  }
  get isEmail() {
    return !!this._def.checks.find(t => t.kind === 'email')
  }
  get isURL() {
    return !!this._def.checks.find(t => t.kind === 'url')
  }
  get isEmoji() {
    return !!this._def.checks.find(t => t.kind === 'emoji')
  }
  get isUUID() {
    return !!this._def.checks.find(t => t.kind === 'uuid')
  }
  get isNANOID() {
    return !!this._def.checks.find(t => t.kind === 'nanoid')
  }
  get isCUID() {
    return !!this._def.checks.find(t => t.kind === 'cuid')
  }
  get isCUID2() {
    return !!this._def.checks.find(t => t.kind === 'cuid2')
  }
  get isULID() {
    return !!this._def.checks.find(t => t.kind === 'ulid')
  }
  get isIP() {
    return !!this._def.checks.find(t => t.kind === 'ip')
  }
  get isBase64() {
    return !!this._def.checks.find(t => t.kind === 'base64')
  }
  get minLength() {
    let t = null
    for (const r of this._def.checks) r.kind === 'min' && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxLength() {
    let t = null
    for (const r of this._def.checks) r.kind === 'max' && (t === null || r.value < t) && (t = r.value)
    return t
  }
}
ma.create = e => {
  var t
  return new ma({
    checks: [],
    typeName: at.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...wt(e)
  })
}
function pK(e, t) {
  const r = (e.toString().split('.')[1] || '').length,
    a = (t.toString().split('.')[1] || '').length,
    o = r > a ? r : a,
    u = parseInt(e.toFixed(o).replace('.', '')),
    l = parseInt(t.toFixed(o).replace('.', ''))
  return (u % l) / Math.pow(10, o)
}
class Os extends Rt {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf)
  }
  _parse(t) {
    if ((this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ve.number)) {
      const u = this._getOrReturnCtx(t)
      return Ie(u, { code: be.invalid_type, expected: Ve.number, received: u.parsedType }), ht
    }
    let a
    const o = new Vr()
    for (const u of this._def.checks)
      u.kind === 'int'
        ? Kt.isInteger(t.data) ||
          ((a = this._getOrReturnCtx(t, a)),
          Ie(a, { code: be.invalid_type, expected: 'integer', received: 'float', message: u.message }),
          o.dirty())
        : u.kind === 'min'
          ? (u.inclusive ? t.data < u.value : t.data <= u.value) &&
            ((a = this._getOrReturnCtx(t, a)),
            Ie(a, {
              code: be.too_small,
              minimum: u.value,
              type: 'number',
              inclusive: u.inclusive,
              exact: !1,
              message: u.message
            }),
            o.dirty())
          : u.kind === 'max'
            ? (u.inclusive ? t.data > u.value : t.data >= u.value) &&
              ((a = this._getOrReturnCtx(t, a)),
              Ie(a, {
                code: be.too_big,
                maximum: u.value,
                type: 'number',
                inclusive: u.inclusive,
                exact: !1,
                message: u.message
              }),
              o.dirty())
            : u.kind === 'multipleOf'
              ? pK(t.data, u.value) !== 0 &&
                ((a = this._getOrReturnCtx(t, a)),
                Ie(a, { code: be.not_multiple_of, multipleOf: u.value, message: u.message }),
                o.dirty())
              : u.kind === 'finite'
                ? Number.isFinite(t.data) ||
                  ((a = this._getOrReturnCtx(t, a)),
                  Ie(a, { code: be.not_finite, message: u.message }),
                  o.dirty())
                : Kt.assertNever(u)
    return { status: o.value, value: t.data }
  }
  gte(t, r) {
    return this.setLimit('min', t, !0, Ge.toString(r))
  }
  gt(t, r) {
    return this.setLimit('min', t, !1, Ge.toString(r))
  }
  lte(t, r) {
    return this.setLimit('max', t, !0, Ge.toString(r))
  }
  lt(t, r) {
    return this.setLimit('max', t, !1, Ge.toString(r))
  }
  setLimit(t, r, a, o) {
    return new Os({
      ...this._def,
      checks: [...this._def.checks, { kind: t, value: r, inclusive: a, message: Ge.toString(o) }]
    })
  }
  _addCheck(t) {
    return new Os({ ...this._def, checks: [...this._def.checks, t] })
  }
  int(t) {
    return this._addCheck({ kind: 'int', message: Ge.toString(t) })
  }
  positive(t) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !1, message: Ge.toString(t) })
  }
  negative(t) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !1, message: Ge.toString(t) })
  }
  nonpositive(t) {
    return this._addCheck({ kind: 'max', value: 0, inclusive: !0, message: Ge.toString(t) })
  }
  nonnegative(t) {
    return this._addCheck({ kind: 'min', value: 0, inclusive: !0, message: Ge.toString(t) })
  }
  multipleOf(t, r) {
    return this._addCheck({ kind: 'multipleOf', value: t, message: Ge.toString(r) })
  }
  finite(t) {
    return this._addCheck({ kind: 'finite', message: Ge.toString(t) })
  }
  safe(t) {
    return this._addCheck({
      kind: 'min',
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ge.toString(t)
    })._addCheck({ kind: 'max', inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: Ge.toString(t) })
  }
  get minValue() {
    let t = null
    for (const r of this._def.checks) r.kind === 'min' && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxValue() {
    let t = null
    for (const r of this._def.checks) r.kind === 'max' && (t === null || r.value < t) && (t = r.value)
    return t
  }
  get isInt() {
    return !!this._def.checks.find(
      t => t.kind === 'int' || (t.kind === 'multipleOf' && Kt.isInteger(t.value))
    )
  }
  get isFinite() {
    let t = null,
      r = null
    for (const a of this._def.checks) {
      if (a.kind === 'finite' || a.kind === 'int' || a.kind === 'multipleOf') return !0
      a.kind === 'min'
        ? (r === null || a.value > r) && (r = a.value)
        : a.kind === 'max' && (t === null || a.value < t) && (t = a.value)
    }
    return Number.isFinite(r) && Number.isFinite(t)
  }
}
Os.create = e =>
  new Os({ checks: [], typeName: at.ZodNumber, coerce: (e == null ? void 0 : e.coerce) || !1, ...wt(e) })
class ks extends Rt {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte)
  }
  _parse(t) {
    if ((this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Ve.bigint)) {
      const u = this._getOrReturnCtx(t)
      return Ie(u, { code: be.invalid_type, expected: Ve.bigint, received: u.parsedType }), ht
    }
    let a
    const o = new Vr()
    for (const u of this._def.checks)
      u.kind === 'min'
        ? (u.inclusive ? t.data < u.value : t.data <= u.value) &&
          ((a = this._getOrReturnCtx(t, a)),
          Ie(a, {
            code: be.too_small,
            type: 'bigint',
            minimum: u.value,
            inclusive: u.inclusive,
            message: u.message
          }),
          o.dirty())
        : u.kind === 'max'
          ? (u.inclusive ? t.data > u.value : t.data >= u.value) &&
            ((a = this._getOrReturnCtx(t, a)),
            Ie(a, {
              code: be.too_big,
              type: 'bigint',
              maximum: u.value,
              inclusive: u.inclusive,
              message: u.message
            }),
            o.dirty())
          : u.kind === 'multipleOf'
            ? t.data % u.value !== BigInt(0) &&
              ((a = this._getOrReturnCtx(t, a)),
              Ie(a, { code: be.not_multiple_of, multipleOf: u.value, message: u.message }),
              o.dirty())
            : Kt.assertNever(u)
    return { status: o.value, value: t.data }
  }
  gte(t, r) {
    return this.setLimit('min', t, !0, Ge.toString(r))
  }
  gt(t, r) {
    return this.setLimit('min', t, !1, Ge.toString(r))
  }
  lte(t, r) {
    return this.setLimit('max', t, !0, Ge.toString(r))
  }
  lt(t, r) {
    return this.setLimit('max', t, !1, Ge.toString(r))
  }
  setLimit(t, r, a, o) {
    return new ks({
      ...this._def,
      checks: [...this._def.checks, { kind: t, value: r, inclusive: a, message: Ge.toString(o) }]
    })
  }
  _addCheck(t) {
    return new ks({ ...this._def, checks: [...this._def.checks, t] })
  }
  positive(t) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !1, message: Ge.toString(t) })
  }
  negative(t) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !1, message: Ge.toString(t) })
  }
  nonpositive(t) {
    return this._addCheck({ kind: 'max', value: BigInt(0), inclusive: !0, message: Ge.toString(t) })
  }
  nonnegative(t) {
    return this._addCheck({ kind: 'min', value: BigInt(0), inclusive: !0, message: Ge.toString(t) })
  }
  multipleOf(t, r) {
    return this._addCheck({ kind: 'multipleOf', value: t, message: Ge.toString(r) })
  }
  get minValue() {
    let t = null
    for (const r of this._def.checks) r.kind === 'min' && (t === null || r.value > t) && (t = r.value)
    return t
  }
  get maxValue() {
    let t = null
    for (const r of this._def.checks) r.kind === 'max' && (t === null || r.value < t) && (t = r.value)
    return t
  }
}
ks.create = e => {
  var t
  return new ks({
    checks: [],
    typeName: at.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...wt(e)
  })
}
class yh extends Rt {
  _parse(t) {
    if ((this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ve.boolean)) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.boolean, received: a.parsedType }), ht
    }
    return Qr(t.data)
  }
}
yh.create = e =>
  new yh({ typeName: at.ZodBoolean, coerce: (e == null ? void 0 : e.coerce) || !1, ...wt(e) })
class Bl extends Rt {
  _parse(t) {
    if ((this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ve.date)) {
      const u = this._getOrReturnCtx(t)
      return Ie(u, { code: be.invalid_type, expected: Ve.date, received: u.parsedType }), ht
    }
    if (isNaN(t.data.getTime())) {
      const u = this._getOrReturnCtx(t)
      return Ie(u, { code: be.invalid_date }), ht
    }
    const a = new Vr()
    let o
    for (const u of this._def.checks)
      u.kind === 'min'
        ? t.data.getTime() < u.value &&
          ((o = this._getOrReturnCtx(t, o)),
          Ie(o, {
            code: be.too_small,
            message: u.message,
            inclusive: !0,
            exact: !1,
            minimum: u.value,
            type: 'date'
          }),
          a.dirty())
        : u.kind === 'max'
          ? t.data.getTime() > u.value &&
            ((o = this._getOrReturnCtx(t, o)),
            Ie(o, {
              code: be.too_big,
              message: u.message,
              inclusive: !0,
              exact: !1,
              maximum: u.value,
              type: 'date'
            }),
            a.dirty())
          : Kt.assertNever(u)
    return { status: a.value, value: new Date(t.data.getTime()) }
  }
  _addCheck(t) {
    return new Bl({ ...this._def, checks: [...this._def.checks, t] })
  }
  min(t, r) {
    return this._addCheck({ kind: 'min', value: t.getTime(), message: Ge.toString(r) })
  }
  max(t, r) {
    return this._addCheck({ kind: 'max', value: t.getTime(), message: Ge.toString(r) })
  }
  get minDate() {
    let t = null
    for (const r of this._def.checks) r.kind === 'min' && (t === null || r.value > t) && (t = r.value)
    return t != null ? new Date(t) : null
  }
  get maxDate() {
    let t = null
    for (const r of this._def.checks) r.kind === 'max' && (t === null || r.value < t) && (t = r.value)
    return t != null ? new Date(t) : null
  }
}
Bl.create = e =>
  new Bl({ checks: [], coerce: (e == null ? void 0 : e.coerce) || !1, typeName: at.ZodDate, ...wt(e) })
class ng extends Rt {
  _parse(t) {
    if (this._getType(t) !== Ve.symbol) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.symbol, received: a.parsedType }), ht
    }
    return Qr(t.data)
  }
}
ng.create = e => new ng({ typeName: at.ZodSymbol, ...wt(e) })
class bh extends Rt {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.undefined, received: a.parsedType }), ht
    }
    return Qr(t.data)
  }
}
bh.create = e => new bh({ typeName: at.ZodUndefined, ...wt(e) })
class Eh extends Rt {
  _parse(t) {
    if (this._getType(t) !== Ve.null) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.null, received: a.parsedType }), ht
    }
    return Qr(t.data)
  }
}
Eh.create = e => new Eh({ typeName: at.ZodNull, ...wt(e) })
class Dc extends Rt {
  constructor() {
    super(...arguments), (this._any = !0)
  }
  _parse(t) {
    return Qr(t.data)
  }
}
Dc.create = e => new Dc({ typeName: at.ZodAny, ...wt(e) })
class Pl extends Rt {
  constructor() {
    super(...arguments), (this._unknown = !0)
  }
  _parse(t) {
    return Qr(t.data)
  }
}
Pl.create = e => new Pl({ typeName: at.ZodUnknown, ...wt(e) })
class ko extends Rt {
  _parse(t) {
    const r = this._getOrReturnCtx(t)
    return Ie(r, { code: be.invalid_type, expected: Ve.never, received: r.parsedType }), ht
  }
}
ko.create = e => new ko({ typeName: at.ZodNever, ...wt(e) })
class rg extends Rt {
  _parse(t) {
    if (this._getType(t) !== Ve.undefined) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.void, received: a.parsedType }), ht
    }
    return Qr(t.data)
  }
}
rg.create = e => new rg({ typeName: at.ZodVoid, ...wt(e) })
class va extends Rt {
  _parse(t) {
    const { ctx: r, status: a } = this._processInputParams(t),
      o = this._def
    if (r.parsedType !== Ve.array)
      return Ie(r, { code: be.invalid_type, expected: Ve.array, received: r.parsedType }), ht
    if (o.exactLength !== null) {
      const l = r.data.length > o.exactLength.value,
        d = r.data.length < o.exactLength.value
      ;(l || d) &&
        (Ie(r, {
          code: l ? be.too_big : be.too_small,
          minimum: d ? o.exactLength.value : void 0,
          maximum: l ? o.exactLength.value : void 0,
          type: 'array',
          inclusive: !0,
          exact: !0,
          message: o.exactLength.message
        }),
        a.dirty())
    }
    if (
      (o.minLength !== null &&
        r.data.length < o.minLength.value &&
        (Ie(r, {
          code: be.too_small,
          minimum: o.minLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: o.minLength.message
        }),
        a.dirty()),
      o.maxLength !== null &&
        r.data.length > o.maxLength.value &&
        (Ie(r, {
          code: be.too_big,
          maximum: o.maxLength.value,
          type: 'array',
          inclusive: !0,
          exact: !1,
          message: o.maxLength.message
        }),
        a.dirty()),
      r.common.async)
    )
      return Promise.all([...r.data].map((l, d) => o.type._parseAsync(new Ya(r, l, r.path, d)))).then(
        l => Vr.mergeArray(a, l)
      )
    const u = [...r.data].map((l, d) => o.type._parseSync(new Ya(r, l, r.path, d)))
    return Vr.mergeArray(a, u)
  }
  get element() {
    return this._def.type
  }
  min(t, r) {
    return new va({ ...this._def, minLength: { value: t, message: Ge.toString(r) } })
  }
  max(t, r) {
    return new va({ ...this._def, maxLength: { value: t, message: Ge.toString(r) } })
  }
  length(t, r) {
    return new va({ ...this._def, exactLength: { value: t, message: Ge.toString(r) } })
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
va.create = (e, t) =>
  new va({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: at.ZodArray,
    ...wt(t)
  })
function Xu(e) {
  if (e instanceof On) {
    const t = {}
    for (const r in e.shape) {
      const a = e.shape[r]
      t[r] = za.create(Xu(a))
    }
    return new On({ ...e._def, shape: () => t })
  } else
    return e instanceof va
      ? new va({ ...e._def, type: Xu(e.element) })
      : e instanceof za
        ? za.create(Xu(e.unwrap()))
        : e instanceof Ds
          ? Ds.create(Xu(e.unwrap()))
          : e instanceof qa
            ? qa.create(e.items.map(t => Xu(t)))
            : e
}
class On extends Rt {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend)
  }
  _getCached() {
    if (this._cached !== null) return this._cached
    const t = this._def.shape(),
      r = Kt.objectKeys(t)
    return (this._cached = { shape: t, keys: r })
  }
  _parse(t) {
    if (this._getType(t) !== Ve.object) {
      const p = this._getOrReturnCtx(t)
      return Ie(p, { code: be.invalid_type, expected: Ve.object, received: p.parsedType }), ht
    }
    const { status: a, ctx: o } = this._processInputParams(t),
      { shape: u, keys: l } = this._getCached(),
      d = []
    if (!(this._def.catchall instanceof ko && this._def.unknownKeys === 'strip'))
      for (const p in o.data) l.includes(p) || d.push(p)
    const h = []
    for (const p of l) {
      const v = u[p],
        g = o.data[p]
      h.push({
        key: { status: 'valid', value: p },
        value: v._parse(new Ya(o, g, o.path, p)),
        alwaysSet: p in o.data
      })
    }
    if (this._def.catchall instanceof ko) {
      const p = this._def.unknownKeys
      if (p === 'passthrough')
        for (const v of d)
          h.push({ key: { status: 'valid', value: v }, value: { status: 'valid', value: o.data[v] } })
      else if (p === 'strict')
        d.length > 0 && (Ie(o, { code: be.unrecognized_keys, keys: d }), a.dirty())
      else if (p !== 'strip') throw new Error('Internal ZodObject error: invalid unknownKeys value.')
    } else {
      const p = this._def.catchall
      for (const v of d) {
        const g = o.data[v]
        h.push({
          key: { status: 'valid', value: v },
          value: p._parse(new Ya(o, g, o.path, v)),
          alwaysSet: v in o.data
        })
      }
    }
    return o.common.async
      ? Promise.resolve()
          .then(async () => {
            const p = []
            for (const v of h) {
              const g = await v.key,
                E = await v.value
              p.push({ key: g, value: E, alwaysSet: v.alwaysSet })
            }
            return p
          })
          .then(p => Vr.mergeObjectSync(a, p))
      : Vr.mergeObjectSync(a, h)
  }
  get shape() {
    return this._def.shape()
  }
  strict(t) {
    return (
      Ge.errToObj,
      new On({
        ...this._def,
        unknownKeys: 'strict',
        ...(t !== void 0
          ? {
              errorMap: (r, a) => {
                var o, u, l, d
                const h =
                  (l =
                    (u = (o = this._def).errorMap) === null || u === void 0
                      ? void 0
                      : u.call(o, r, a).message) !== null && l !== void 0
                    ? l
                    : a.defaultError
                return r.code === 'unrecognized_keys'
                  ? { message: (d = Ge.errToObj(t).message) !== null && d !== void 0 ? d : h }
                  : { message: h }
              }
            }
          : {})
      })
    )
  }
  strip() {
    return new On({ ...this._def, unknownKeys: 'strip' })
  }
  passthrough() {
    return new On({ ...this._def, unknownKeys: 'passthrough' })
  }
  extend(t) {
    return new On({ ...this._def, shape: () => ({ ...this._def.shape(), ...t }) })
  }
  merge(t) {
    return new On({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
      typeName: at.ZodObject
    })
  }
  setKey(t, r) {
    return this.augment({ [t]: r })
  }
  catchall(t) {
    return new On({ ...this._def, catchall: t })
  }
  pick(t) {
    const r = {}
    return (
      Kt.objectKeys(t).forEach(a => {
        t[a] && this.shape[a] && (r[a] = this.shape[a])
      }),
      new On({ ...this._def, shape: () => r })
    )
  }
  omit(t) {
    const r = {}
    return (
      Kt.objectKeys(this.shape).forEach(a => {
        t[a] || (r[a] = this.shape[a])
      }),
      new On({ ...this._def, shape: () => r })
    )
  }
  deepPartial() {
    return Xu(this)
  }
  partial(t) {
    const r = {}
    return (
      Kt.objectKeys(this.shape).forEach(a => {
        const o = this.shape[a]
        t && !t[a] ? (r[a] = o) : (r[a] = o.optional())
      }),
      new On({ ...this._def, shape: () => r })
    )
  }
  required(t) {
    const r = {}
    return (
      Kt.objectKeys(this.shape).forEach(a => {
        if (t && !t[a]) r[a] = this.shape[a]
        else {
          let u = this.shape[a]
          for (; u instanceof za; ) u = u._def.innerType
          r[a] = u
        }
      }),
      new On({ ...this._def, shape: () => r })
    )
  }
  keyof() {
    return vM(Kt.objectKeys(this.shape))
  }
}
On.create = (e, t) =>
  new On({
    shape: () => e,
    unknownKeys: 'strip',
    catchall: ko.create(),
    typeName: at.ZodObject,
    ...wt(t)
  })
On.strictCreate = (e, t) =>
  new On({
    shape: () => e,
    unknownKeys: 'strict',
    catchall: ko.create(),
    typeName: at.ZodObject,
    ...wt(t)
  })
On.lazycreate = (e, t) =>
  new On({ shape: e, unknownKeys: 'strip', catchall: ko.create(), typeName: at.ZodObject, ...wt(t) })
class xh extends Rt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t),
      a = this._def.options
    function o(u) {
      for (const d of u) if (d.result.status === 'valid') return d.result
      for (const d of u)
        if (d.result.status === 'dirty') return r.common.issues.push(...d.ctx.common.issues), d.result
      const l = u.map(d => new Oi(d.ctx.common.issues))
      return Ie(r, { code: be.invalid_union, unionErrors: l }), ht
    }
    if (r.common.async)
      return Promise.all(
        a.map(async u => {
          const l = { ...r, common: { ...r.common, issues: [] }, parent: null }
          return { result: await u._parseAsync({ data: r.data, path: r.path, parent: l }), ctx: l }
        })
      ).then(o)
    {
      let u
      const l = []
      for (const h of a) {
        const p = { ...r, common: { ...r.common, issues: [] }, parent: null },
          v = h._parseSync({ data: r.data, path: r.path, parent: p })
        if (v.status === 'valid') return v
        v.status === 'dirty' && !u && (u = { result: v, ctx: p }),
          p.common.issues.length && l.push(p.common.issues)
      }
      if (u) return r.common.issues.push(...u.ctx.common.issues), u.result
      const d = l.map(h => new Oi(h))
      return Ie(r, { code: be.invalid_union, unionErrors: d }), ht
    }
  }
  get options() {
    return this._def.options
  }
}
xh.create = (e, t) => new xh({ options: e, typeName: at.ZodUnion, ...wt(t) })
const Eo = e =>
  e instanceof Ch
    ? Eo(e.schema)
    : e instanceof ya
      ? Eo(e.innerType())
      : e instanceof wh
        ? [e.value]
        : e instanceof As
          ? e.options
          : e instanceof Rh
            ? Kt.objectValues(e.enum)
            : e instanceof _h
              ? Eo(e._def.innerType)
              : e instanceof bh
                ? [void 0]
                : e instanceof Eh
                  ? [null]
                  : e instanceof za
                    ? [void 0, ...Eo(e.unwrap())]
                    : e instanceof Ds
                      ? [null, ...Eo(e.unwrap())]
                      : e instanceof S1 || e instanceof kh
                        ? Eo(e.unwrap())
                        : e instanceof Oh
                          ? Eo(e._def.innerType)
                          : []
class Rg extends Rt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t)
    if (r.parsedType !== Ve.object)
      return Ie(r, { code: be.invalid_type, expected: Ve.object, received: r.parsedType }), ht
    const a = this.discriminator,
      o = r.data[a],
      u = this.optionsMap.get(o)
    return u
      ? r.common.async
        ? u._parseAsync({ data: r.data, path: r.path, parent: r })
        : u._parseSync({ data: r.data, path: r.path, parent: r })
      : (Ie(r, {
          code: be.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [a]
        }),
        ht)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(t, r, a) {
    const o = new Map()
    for (const u of r) {
      const l = Eo(u.shape[t])
      if (!l.length)
        throw new Error(
          `A discriminator value for key \`${t}\` could not be extracted from all schema options`
        )
      for (const d of l) {
        if (o.has(d))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(d)}`)
        o.set(d, u)
      }
    }
    return new Rg({
      typeName: at.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: o,
      ...wt(a)
    })
  }
}
function ES(e, t) {
  const r = ds(e),
    a = ds(t)
  if (e === t) return { valid: !0, data: e }
  if (r === Ve.object && a === Ve.object) {
    const o = Kt.objectKeys(t),
      u = Kt.objectKeys(e).filter(d => o.indexOf(d) !== -1),
      l = { ...e, ...t }
    for (const d of u) {
      const h = ES(e[d], t[d])
      if (!h.valid) return { valid: !1 }
      l[d] = h.data
    }
    return { valid: !0, data: l }
  } else if (r === Ve.array && a === Ve.array) {
    if (e.length !== t.length) return { valid: !1 }
    const o = []
    for (let u = 0; u < e.length; u++) {
      const l = e[u],
        d = t[u],
        h = ES(l, d)
      if (!h.valid) return { valid: !1 }
      o.push(h.data)
    }
    return { valid: !0, data: o }
  } else return r === Ve.date && a === Ve.date && +e == +t ? { valid: !0, data: e } : { valid: !1 }
}
class Sh extends Rt {
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t),
      o = (u, l) => {
        if (yS(u) || yS(l)) return ht
        const d = ES(u.value, l.value)
        return d.valid
          ? ((bS(u) || bS(l)) && r.dirty(), { status: r.value, value: d.data })
          : (Ie(a, { code: be.invalid_intersection_types }), ht)
      }
    return a.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: a.data, path: a.path, parent: a }),
          this._def.right._parseAsync({ data: a.data, path: a.path, parent: a })
        ]).then(([u, l]) => o(u, l))
      : o(
          this._def.left._parseSync({ data: a.data, path: a.path, parent: a }),
          this._def.right._parseSync({ data: a.data, path: a.path, parent: a })
        )
  }
}
Sh.create = (e, t, r) => new Sh({ left: e, right: t, typeName: at.ZodIntersection, ...wt(r) })
class qa extends Rt {
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t)
    if (a.parsedType !== Ve.array)
      return Ie(a, { code: be.invalid_type, expected: Ve.array, received: a.parsedType }), ht
    if (a.data.length < this._def.items.length)
      return (
        Ie(a, {
          code: be.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: 'array'
        }),
        ht
      )
    !this._def.rest &&
      a.data.length > this._def.items.length &&
      (Ie(a, {
        code: be.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: 'array'
      }),
      r.dirty())
    const u = [...a.data]
      .map((l, d) => {
        const h = this._def.items[d] || this._def.rest
        return h ? h._parse(new Ya(a, l, a.path, d)) : null
      })
      .filter(l => !!l)
    return a.common.async ? Promise.all(u).then(l => Vr.mergeArray(r, l)) : Vr.mergeArray(r, u)
  }
  get items() {
    return this._def.items
  }
  rest(t) {
    return new qa({ ...this._def, rest: t })
  }
}
qa.create = (e, t) => {
  if (!Array.isArray(e)) throw new Error('You must pass an array of schemas to z.tuple([ ... ])')
  return new qa({ items: e, typeName: at.ZodTuple, rest: null, ...wt(t) })
}
class Th extends Rt {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t)
    if (a.parsedType !== Ve.object)
      return Ie(a, { code: be.invalid_type, expected: Ve.object, received: a.parsedType }), ht
    const o = [],
      u = this._def.keyType,
      l = this._def.valueType
    for (const d in a.data)
      o.push({
        key: u._parse(new Ya(a, d, a.path, d)),
        value: l._parse(new Ya(a, a.data[d], a.path, d)),
        alwaysSet: d in a.data
      })
    return a.common.async ? Vr.mergeObjectAsync(r, o) : Vr.mergeObjectSync(r, o)
  }
  get element() {
    return this._def.valueType
  }
  static create(t, r, a) {
    return r instanceof Rt
      ? new Th({ keyType: t, valueType: r, typeName: at.ZodRecord, ...wt(a) })
      : new Th({ keyType: ma.create(), valueType: t, typeName: at.ZodRecord, ...wt(r) })
  }
}
class ig extends Rt {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t)
    if (a.parsedType !== Ve.map)
      return Ie(a, { code: be.invalid_type, expected: Ve.map, received: a.parsedType }), ht
    const o = this._def.keyType,
      u = this._def.valueType,
      l = [...a.data.entries()].map(([d, h], p) => ({
        key: o._parse(new Ya(a, d, a.path, [p, 'key'])),
        value: u._parse(new Ya(a, h, a.path, [p, 'value']))
      }))
    if (a.common.async) {
      const d = new Map()
      return Promise.resolve().then(async () => {
        for (const h of l) {
          const p = await h.key,
            v = await h.value
          if (p.status === 'aborted' || v.status === 'aborted') return ht
          ;(p.status === 'dirty' || v.status === 'dirty') && r.dirty(), d.set(p.value, v.value)
        }
        return { status: r.value, value: d }
      })
    } else {
      const d = new Map()
      for (const h of l) {
        const p = h.key,
          v = h.value
        if (p.status === 'aborted' || v.status === 'aborted') return ht
        ;(p.status === 'dirty' || v.status === 'dirty') && r.dirty(), d.set(p.value, v.value)
      }
      return { status: r.value, value: d }
    }
  }
}
ig.create = (e, t, r) => new ig({ valueType: t, keyType: e, typeName: at.ZodMap, ...wt(r) })
class zl extends Rt {
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t)
    if (a.parsedType !== Ve.set)
      return Ie(a, { code: be.invalid_type, expected: Ve.set, received: a.parsedType }), ht
    const o = this._def
    o.minSize !== null &&
      a.data.size < o.minSize.value &&
      (Ie(a, {
        code: be.too_small,
        minimum: o.minSize.value,
        type: 'set',
        inclusive: !0,
        exact: !1,
        message: o.minSize.message
      }),
      r.dirty()),
      o.maxSize !== null &&
        a.data.size > o.maxSize.value &&
        (Ie(a, {
          code: be.too_big,
          maximum: o.maxSize.value,
          type: 'set',
          inclusive: !0,
          exact: !1,
          message: o.maxSize.message
        }),
        r.dirty())
    const u = this._def.valueType
    function l(h) {
      const p = new Set()
      for (const v of h) {
        if (v.status === 'aborted') return ht
        v.status === 'dirty' && r.dirty(), p.add(v.value)
      }
      return { status: r.value, value: p }
    }
    const d = [...a.data.values()].map((h, p) => u._parse(new Ya(a, h, a.path, p)))
    return a.common.async ? Promise.all(d).then(h => l(h)) : l(d)
  }
  min(t, r) {
    return new zl({ ...this._def, minSize: { value: t, message: Ge.toString(r) } })
  }
  max(t, r) {
    return new zl({ ...this._def, maxSize: { value: t, message: Ge.toString(r) } })
  }
  size(t, r) {
    return this.min(t, r).max(t, r)
  }
  nonempty(t) {
    return this.min(1, t)
  }
}
zl.create = (e, t) =>
  new zl({ valueType: e, minSize: null, maxSize: null, typeName: at.ZodSet, ...wt(t) })
class cc extends Rt {
  constructor() {
    super(...arguments), (this.validate = this.implement)
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t)
    if (r.parsedType !== Ve.function)
      return Ie(r, { code: be.invalid_type, expected: Ve.function, received: r.parsedType }), ht
    function a(d, h) {
      return eg({
        data: d,
        path: r.path,
        errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, Jv(), Ac].filter(p => !!p),
        issueData: { code: be.invalid_arguments, argumentsError: h }
      })
    }
    function o(d, h) {
      return eg({
        data: d,
        path: r.path,
        errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, Jv(), Ac].filter(p => !!p),
        issueData: { code: be.invalid_return_type, returnTypeError: h }
      })
    }
    const u = { errorMap: r.common.contextualErrorMap },
      l = r.data
    if (this._def.returns instanceof Nc) {
      const d = this
      return Qr(async function (...h) {
        const p = new Oi([]),
          v = await d._def.args.parseAsync(h, u).catch(x => {
            throw (p.addIssue(a(h, x)), p)
          }),
          g = await Reflect.apply(l, this, v)
        return await d._def.returns._def.type.parseAsync(g, u).catch(x => {
          throw (p.addIssue(o(g, x)), p)
        })
      })
    } else {
      const d = this
      return Qr(function (...h) {
        const p = d._def.args.safeParse(h, u)
        if (!p.success) throw new Oi([a(h, p.error)])
        const v = Reflect.apply(l, this, p.data),
          g = d._def.returns.safeParse(v, u)
        if (!g.success) throw new Oi([o(v, g.error)])
        return g.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...t) {
    return new cc({ ...this._def, args: qa.create(t).rest(Pl.create()) })
  }
  returns(t) {
    return new cc({ ...this._def, returns: t })
  }
  implement(t) {
    return this.parse(t)
  }
  strictImplement(t) {
    return this.parse(t)
  }
  static create(t, r, a) {
    return new cc({
      args: t || qa.create([]).rest(Pl.create()),
      returns: r || Pl.create(),
      typeName: at.ZodFunction,
      ...wt(a)
    })
  }
}
class Ch extends Rt {
  get schema() {
    return this._def.getter()
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t)
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r })
  }
}
Ch.create = (e, t) => new Ch({ getter: e, typeName: at.ZodLazy, ...wt(t) })
class wh extends Rt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t)
      return Ie(r, { received: r.data, code: be.invalid_literal, expected: this._def.value }), ht
    }
    return { status: 'valid', value: t.data }
  }
  get value() {
    return this._def.value
  }
}
wh.create = (e, t) => new wh({ value: e, typeName: at.ZodLiteral, ...wt(t) })
function vM(e, t) {
  return new As({ values: e, typeName: at.ZodEnum, ...wt(t) })
}
class As extends Rt {
  constructor() {
    super(...arguments), Wd.set(this, void 0)
  }
  _parse(t) {
    if (typeof t.data != 'string') {
      const r = this._getOrReturnCtx(t),
        a = this._def.values
      return Ie(r, { expected: Kt.joinValues(a), received: r.parsedType, code: be.invalid_type }), ht
    }
    if ((tg(this, Wd) || dM(this, Wd, new Set(this._def.values)), !tg(this, Wd).has(t.data))) {
      const r = this._getOrReturnCtx(t),
        a = this._def.values
      return Ie(r, { received: r.data, code: be.invalid_enum_value, options: a }), ht
    }
    return Qr(t.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const t = {}
    for (const r of this._def.values) t[r] = r
    return t
  }
  get Values() {
    const t = {}
    for (const r of this._def.values) t[r] = r
    return t
  }
  get Enum() {
    const t = {}
    for (const r of this._def.values) t[r] = r
    return t
  }
  extract(t, r = this._def) {
    return As.create(t, { ...this._def, ...r })
  }
  exclude(t, r = this._def) {
    return As.create(
      this.options.filter(a => !t.includes(a)),
      { ...this._def, ...r }
    )
  }
}
Wd = new WeakMap()
As.create = vM
class Rh extends Rt {
  constructor() {
    super(...arguments), Yd.set(this, void 0)
  }
  _parse(t) {
    const r = Kt.getValidEnumValues(this._def.values),
      a = this._getOrReturnCtx(t)
    if (a.parsedType !== Ve.string && a.parsedType !== Ve.number) {
      const o = Kt.objectValues(r)
      return Ie(a, { expected: Kt.joinValues(o), received: a.parsedType, code: be.invalid_type }), ht
    }
    if (
      (tg(this, Yd) || dM(this, Yd, new Set(Kt.getValidEnumValues(this._def.values))),
      !tg(this, Yd).has(t.data))
    ) {
      const o = Kt.objectValues(r)
      return Ie(a, { received: a.data, code: be.invalid_enum_value, options: o }), ht
    }
    return Qr(t.data)
  }
  get enum() {
    return this._def.values
  }
}
Yd = new WeakMap()
Rh.create = (e, t) => new Rh({ values: e, typeName: at.ZodNativeEnum, ...wt(t) })
class Nc extends Rt {
  unwrap() {
    return this._def.type
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t)
    if (r.parsedType !== Ve.promise && r.common.async === !1)
      return Ie(r, { code: be.invalid_type, expected: Ve.promise, received: r.parsedType }), ht
    const a = r.parsedType === Ve.promise ? r.data : Promise.resolve(r.data)
    return Qr(
      a.then(o => this._def.type.parseAsync(o, { path: r.path, errorMap: r.common.contextualErrorMap }))
    )
  }
}
Nc.create = (e, t) => new Nc({ type: e, typeName: at.ZodPromise, ...wt(t) })
class ya extends Rt {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === at.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema
  }
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t),
      o = this._def.effect || null,
      u = {
        addIssue: l => {
          Ie(a, l), l.fatal ? r.abort() : r.dirty()
        },
        get path() {
          return a.path
        }
      }
    if (((u.addIssue = u.addIssue.bind(u)), o.type === 'preprocess')) {
      const l = o.transform(a.data, u)
      if (a.common.async)
        return Promise.resolve(l).then(async d => {
          if (r.value === 'aborted') return ht
          const h = await this._def.schema._parseAsync({ data: d, path: a.path, parent: a })
          return h.status === 'aborted'
            ? ht
            : h.status === 'dirty' || r.value === 'dirty'
              ? rc(h.value)
              : h
        })
      {
        if (r.value === 'aborted') return ht
        const d = this._def.schema._parseSync({ data: l, path: a.path, parent: a })
        return d.status === 'aborted'
          ? ht
          : d.status === 'dirty' || r.value === 'dirty'
            ? rc(d.value)
            : d
      }
    }
    if (o.type === 'refinement') {
      const l = d => {
        const h = o.refinement(d, u)
        if (a.common.async) return Promise.resolve(h)
        if (h instanceof Promise)
          throw new Error(
            'Async refinement encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return d
      }
      if (a.common.async === !1) {
        const d = this._def.schema._parseSync({ data: a.data, path: a.path, parent: a })
        return d.status === 'aborted'
          ? ht
          : (d.status === 'dirty' && r.dirty(), l(d.value), { status: r.value, value: d.value })
      } else
        return this._def.schema
          ._parseAsync({ data: a.data, path: a.path, parent: a })
          .then(d =>
            d.status === 'aborted'
              ? ht
              : (d.status === 'dirty' && r.dirty(),
                l(d.value).then(() => ({ status: r.value, value: d.value })))
          )
    }
    if (o.type === 'transform')
      if (a.common.async === !1) {
        const l = this._def.schema._parseSync({ data: a.data, path: a.path, parent: a })
        if (!vh(l)) return l
        const d = o.transform(l.value, u)
        if (d instanceof Promise)
          throw new Error(
            'Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.'
          )
        return { status: r.value, value: d }
      } else
        return this._def.schema
          ._parseAsync({ data: a.data, path: a.path, parent: a })
          .then(l =>
            vh(l)
              ? Promise.resolve(o.transform(l.value, u)).then(d => ({ status: r.value, value: d }))
              : l
          )
    Kt.assertNever(o)
  }
}
ya.create = (e, t, r) => new ya({ schema: e, typeName: at.ZodEffects, effect: t, ...wt(r) })
ya.createWithPreprocess = (e, t, r) =>
  new ya({ schema: t, effect: { type: 'preprocess', transform: e }, typeName: at.ZodEffects, ...wt(r) })
class za extends Rt {
  _parse(t) {
    return this._getType(t) === Ve.undefined ? Qr(void 0) : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
za.create = (e, t) => new za({ innerType: e, typeName: at.ZodOptional, ...wt(t) })
class Ds extends Rt {
  _parse(t) {
    return this._getType(t) === Ve.null ? Qr(null) : this._def.innerType._parse(t)
  }
  unwrap() {
    return this._def.innerType
  }
}
Ds.create = (e, t) => new Ds({ innerType: e, typeName: at.ZodNullable, ...wt(t) })
class _h extends Rt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t)
    let a = r.data
    return (
      r.parsedType === Ve.undefined && (a = this._def.defaultValue()),
      this._def.innerType._parse({ data: a, path: r.path, parent: r })
    )
  }
  removeDefault() {
    return this._def.innerType
  }
}
_h.create = (e, t) =>
  new _h({
    innerType: e,
    typeName: at.ZodDefault,
    defaultValue: typeof t.default == 'function' ? t.default : () => t.default,
    ...wt(t)
  })
class Oh extends Rt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t),
      a = { ...r, common: { ...r.common, issues: [] } },
      o = this._def.innerType._parse({ data: a.data, path: a.path, parent: { ...a } })
    return gh(o)
      ? o.then(u => ({
          status: 'valid',
          value:
            u.status === 'valid'
              ? u.value
              : this._def.catchValue({
                  get error() {
                    return new Oi(a.common.issues)
                  },
                  input: a.data
                })
        }))
      : {
          status: 'valid',
          value:
            o.status === 'valid'
              ? o.value
              : this._def.catchValue({
                  get error() {
                    return new Oi(a.common.issues)
                  },
                  input: a.data
                })
        }
  }
  removeCatch() {
    return this._def.innerType
  }
}
Oh.create = (e, t) =>
  new Oh({
    innerType: e,
    typeName: at.ZodCatch,
    catchValue: typeof t.catch == 'function' ? t.catch : () => t.catch,
    ...wt(t)
  })
class ag extends Rt {
  _parse(t) {
    if (this._getType(t) !== Ve.nan) {
      const a = this._getOrReturnCtx(t)
      return Ie(a, { code: be.invalid_type, expected: Ve.nan, received: a.parsedType }), ht
    }
    return { status: 'valid', value: t.data }
  }
}
ag.create = e => new ag({ typeName: at.ZodNaN, ...wt(e) })
const mK = Symbol('zod_brand')
class S1 extends Rt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t),
      a = r.data
    return this._def.type._parse({ data: a, path: r.path, parent: r })
  }
  unwrap() {
    return this._def.type
  }
}
class Gh extends Rt {
  _parse(t) {
    const { status: r, ctx: a } = this._processInputParams(t)
    if (a.common.async)
      return (async () => {
        const u = await this._def.in._parseAsync({ data: a.data, path: a.path, parent: a })
        return u.status === 'aborted'
          ? ht
          : u.status === 'dirty'
            ? (r.dirty(), rc(u.value))
            : this._def.out._parseAsync({ data: u.value, path: a.path, parent: a })
      })()
    {
      const o = this._def.in._parseSync({ data: a.data, path: a.path, parent: a })
      return o.status === 'aborted'
        ? ht
        : o.status === 'dirty'
          ? (r.dirty(), { status: 'dirty', value: o.value })
          : this._def.out._parseSync({ data: o.value, path: a.path, parent: a })
    }
  }
  static create(t, r) {
    return new Gh({ in: t, out: r, typeName: at.ZodPipeline })
  }
}
class kh extends Rt {
  _parse(t) {
    const r = this._def.innerType._parse(t),
      a = o => (vh(o) && (o.value = Object.freeze(o.value)), o)
    return gh(r) ? r.then(o => a(o)) : a(r)
  }
  unwrap() {
    return this._def.innerType
  }
}
kh.create = (e, t) => new kh({ innerType: e, typeName: at.ZodReadonly, ...wt(t) })
function gM(e, t = {}, r) {
  return e
    ? Dc.create().superRefine((a, o) => {
        var u, l
        if (!e(a)) {
          const d = typeof t == 'function' ? t(a) : typeof t == 'string' ? { message: t } : t,
            h = (l = (u = d.fatal) !== null && u !== void 0 ? u : r) !== null && l !== void 0 ? l : !0,
            p = typeof d == 'string' ? { message: d } : d
          o.addIssue({ code: 'custom', ...p, fatal: h })
        }
      })
    : Dc.create()
}
const vK = { object: On.lazycreate }
var at
;(function (e) {
  ;(e.ZodString = 'ZodString'),
    (e.ZodNumber = 'ZodNumber'),
    (e.ZodNaN = 'ZodNaN'),
    (e.ZodBigInt = 'ZodBigInt'),
    (e.ZodBoolean = 'ZodBoolean'),
    (e.ZodDate = 'ZodDate'),
    (e.ZodSymbol = 'ZodSymbol'),
    (e.ZodUndefined = 'ZodUndefined'),
    (e.ZodNull = 'ZodNull'),
    (e.ZodAny = 'ZodAny'),
    (e.ZodUnknown = 'ZodUnknown'),
    (e.ZodNever = 'ZodNever'),
    (e.ZodVoid = 'ZodVoid'),
    (e.ZodArray = 'ZodArray'),
    (e.ZodObject = 'ZodObject'),
    (e.ZodUnion = 'ZodUnion'),
    (e.ZodDiscriminatedUnion = 'ZodDiscriminatedUnion'),
    (e.ZodIntersection = 'ZodIntersection'),
    (e.ZodTuple = 'ZodTuple'),
    (e.ZodRecord = 'ZodRecord'),
    (e.ZodMap = 'ZodMap'),
    (e.ZodSet = 'ZodSet'),
    (e.ZodFunction = 'ZodFunction'),
    (e.ZodLazy = 'ZodLazy'),
    (e.ZodLiteral = 'ZodLiteral'),
    (e.ZodEnum = 'ZodEnum'),
    (e.ZodEffects = 'ZodEffects'),
    (e.ZodNativeEnum = 'ZodNativeEnum'),
    (e.ZodOptional = 'ZodOptional'),
    (e.ZodNullable = 'ZodNullable'),
    (e.ZodDefault = 'ZodDefault'),
    (e.ZodCatch = 'ZodCatch'),
    (e.ZodPromise = 'ZodPromise'),
    (e.ZodBranded = 'ZodBranded'),
    (e.ZodPipeline = 'ZodPipeline'),
    (e.ZodReadonly = 'ZodReadonly')
})(at || (at = {}))
const gK = (e, t = { message: `Input not instance of ${e.name}` }) => gM(r => r instanceof e, t),
  yM = ma.create,
  bM = Os.create,
  yK = ag.create,
  bK = ks.create,
  EM = yh.create,
  EK = Bl.create,
  xK = ng.create,
  SK = bh.create,
  TK = Eh.create,
  CK = Dc.create,
  wK = Pl.create,
  RK = ko.create,
  _K = rg.create,
  OK = va.create,
  kK = On.create,
  AK = On.strictCreate,
  DK = xh.create,
  NK = Rg.create,
  MK = Sh.create,
  LK = qa.create,
  PK = Th.create,
  IK = ig.create,
  FK = zl.create,
  VK = cc.create,
  jK = Ch.create,
  UK = wh.create,
  $K = As.create,
  BK = Rh.create,
  zK = Nc.create,
  yk = ya.create,
  HK = za.create,
  WK = Ds.create,
  YK = ya.createWithPreprocess,
  qK = Gh.create,
  GK = () => yM().optional(),
  KK = () => bM().optional(),
  ZK = () => EM().optional(),
  XK = {
    string: e => ma.create({ ...e, coerce: !0 }),
    number: e => Os.create({ ...e, coerce: !0 }),
    boolean: e => yh.create({ ...e, coerce: !0 }),
    bigint: e => ks.create({ ...e, coerce: !0 }),
    date: e => Bl.create({ ...e, coerce: !0 })
  },
  QK = ht
var Gu = Object.freeze({
  __proto__: null,
  defaultErrorMap: Ac,
  setErrorMap: QG,
  getErrorMap: Jv,
  makeIssue: eg,
  EMPTY_PATH: JG,
  addIssueToContext: Ie,
  ParseStatus: Vr,
  INVALID: ht,
  DIRTY: rc,
  OK: Qr,
  isAborted: yS,
  isDirty: bS,
  isValid: vh,
  isAsync: gh,
  get util() {
    return Kt
  },
  get objectUtil() {
    return gS
  },
  ZodParsedType: Ve,
  getParsedType: ds,
  ZodType: Rt,
  datetimeRegex: mM,
  ZodString: ma,
  ZodNumber: Os,
  ZodBigInt: ks,
  ZodBoolean: yh,
  ZodDate: Bl,
  ZodSymbol: ng,
  ZodUndefined: bh,
  ZodNull: Eh,
  ZodAny: Dc,
  ZodUnknown: Pl,
  ZodNever: ko,
  ZodVoid: rg,
  ZodArray: va,
  ZodObject: On,
  ZodUnion: xh,
  ZodDiscriminatedUnion: Rg,
  ZodIntersection: Sh,
  ZodTuple: qa,
  ZodRecord: Th,
  ZodMap: ig,
  ZodSet: zl,
  ZodFunction: cc,
  ZodLazy: Ch,
  ZodLiteral: wh,
  ZodEnum: As,
  ZodNativeEnum: Rh,
  ZodPromise: Nc,
  ZodEffects: ya,
  ZodTransformer: ya,
  ZodOptional: za,
  ZodNullable: Ds,
  ZodDefault: _h,
  ZodCatch: Oh,
  ZodNaN: ag,
  BRAND: mK,
  ZodBranded: S1,
  ZodPipeline: Gh,
  ZodReadonly: kh,
  custom: gM,
  Schema: Rt,
  ZodSchema: Rt,
  late: vK,
  get ZodFirstPartyTypeKind() {
    return at
  },
  coerce: XK,
  any: CK,
  array: OK,
  bigint: bK,
  boolean: EM,
  date: EK,
  discriminatedUnion: NK,
  effect: yk,
  enum: $K,
  function: VK,
  instanceof: gK,
  intersection: MK,
  lazy: jK,
  literal: UK,
  map: IK,
  nan: yK,
  nativeEnum: BK,
  never: RK,
  null: TK,
  nullable: WK,
  number: bM,
  object: kK,
  oboolean: ZK,
  onumber: KK,
  optional: HK,
  ostring: GK,
  pipeline: qK,
  preprocess: YK,
  promise: zK,
  record: PK,
  set: FK,
  strictObject: AK,
  string: yM,
  symbol: xK,
  transformer: yk,
  tuple: LK,
  undefined: SK,
  union: DK,
  unknown: wK,
  void: _K,
  NEVER: QK,
  ZodIssueCode: be,
  quotelessJson: XG,
  ZodError: Oi
})
const JK = Av.filter(e => e.value !== void 0).map(e => e.value),
  eZ = Math.max(...bA),
  tZ = Gu.object({
    limit: Gu.coerce.number().int().positive().max(eZ).default(th),
    offset: Gu.coerce.number().int().nonnegative().default(jh),
    name: Gu.string()
      .trim()
      .transform(e => vk.sanitize(e || ''))
      .optional(),
    type: Gu.string()
      .trim()
      .transform(e => vk.sanitize(e || ''))
      .optional(),
    sort: Gu.enum(JK).optional()
  }),
  nZ = sA('/')({ component: DG, validateSearch: tZ }),
  rZ = sA('/pokemon-details/$name')(),
  iZ = nZ.update({ path: '/', getParentRoute: () => OS }),
  aZ = rZ
    .update({ path: '/pokemon-details/$name', getParentRoute: () => OS })
    .lazy(() => wV(() => import('./pokemon-details._name.lazy-BtPTuuyJ.js'), []).then(e => e.Route)),
  oZ = { IndexRoute: iZ, PokemonDetailsNameLazyRoute: aZ },
  sZ = OS._addFileChildren(oZ)._addFileTypes(),
  lZ = new i9(),
  uZ = G9({ routeTree: sZ }),
  bk = document.getElementById('root')
bk.innerHTML ||
  Tx.createRoot(bk).render(
    le.jsxDEV(
      w.StrictMode,
      {
        children: le.jsxDEV(
          u9,
          {
            client: lZ,
            children: le.jsxDEV(
              vV,
              { router: uZ },
              void 0,
              !1,
              {
                fileName: '/Volumes/workspace/pokemon-frontend/src/main.tsx',
                lineNumber: 28,
                columnNumber: 9
              },
              void 0
            )
          },
          void 0,
          !1,
          {
            fileName: '/Volumes/workspace/pokemon-frontend/src/main.tsx',
            lineNumber: 27,
            columnNumber: 7
          },
          void 0
        )
      },
      void 0,
      !1,
      { fileName: '/Volumes/workspace/pokemon-frontend/src/main.tsx', lineNumber: 26, columnNumber: 5 },
      void 0
    )
  )
export {
  oc as B,
  XV as C,
  KD as D,
  Hv as L,
  AD as M,
  YS as P,
  Gt as R,
  rz as T,
  DD as a,
  bU as b,
  le as c,
  pA as d,
  Ao as e,
  l9 as f,
  qk as g,
  aA as h,
  Ss as i,
  dt as j,
  SZ as k,
  vZ as l,
  sc as m,
  TZ as p,
  w as r,
  dU as s,
  yA as t,
  fB as u
}
